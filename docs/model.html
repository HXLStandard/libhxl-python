<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hxl.model API documentation</title>
<meta name="description" content="Main data-model classes for the Humanitarian Exchange Language (HXL) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hxl.model</code></h1>
</header>
<section id="section-intro">
<p>Main data-model classes for the Humanitarian Exchange Language (HXL).</p>
<p>This module defines the basic classes for working with HXL data. Other
modules have classes derived from these (e.g. in
<a href="filters.html">hxl.filters</a> or <a href="io.html">hxl.input</a>). The core class is
<a href="#hxl.model.Dataset">Dataset</a>, which defines the operations available
on a HXL dataset, including convenience methods for chaining filters.</p>
<p>Typical usage:</p>
<pre><code>source = hxl.data("https://example.org/data.csv")
# returns a hxl.model.Dataset object

result = source.with_lines("#country+name=Kenya").sort()
# a filtered/sorted view of the data
</code></pre>
<p>This code is released into the Public Domain and comes with NO WARRANTY.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Main data-model classes for the Humanitarian Exchange Language (HXL).

This module defines the basic classes for working with HXL data. Other
modules have classes derived from these (e.g. in
[hxl.filters](filters.html) or [hxl.input](io.html)). The core class is
[Dataset](#hxl.model.Dataset), which defines the operations available
on a HXL dataset, including convenience methods for chaining filters.

Typical usage:

    source = hxl.data(&#34;https://example.org/data.csv&#34;)
    # returns a hxl.model.Dataset object

    result = source.with_lines(&#34;#country+name=Kenya&#34;).sort()
    # a filtered/sorted view of the data


This code is released into the Public Domain and comes with NO WARRANTY.

&#34;&#34;&#34;

import abc, copy, csv, dateutil, hashlib, json, logging, operator, re, six

import hxl

logger = logging.getLogger(__name__)


# Cut off for fuzzy detection of a hashtag row
# At least this percentage of cells must parse as HXL hashtags
FUZZY_HASHTAG_PERCENTAGE = 0.5


class TagPattern(object):
    &#34;&#34;&#34;Pattern for matching a HXL hashtag and attributes

    - the pattern &#34;#*&#34; matches any hashtag/attribute combination
    - the pattern &#34;#*+foo&#34; matches any hashtag with the foo attribute
    - the pattern &#34;#tag&#34; matches #tag with any attributes
    - the pattern &#34;#tag+foo&#34; matches #tag with foo among its attributes
    - the pattern &#34;#tag-foo&#34; matches #tag with foo *not* among its attributes
    - the pattern &#34;#tag+foo-bar&#34; matches #tag with foo but not bar
    - the pattern &#34;#tag+foo+bar!&#34; matches #tag with exactly the attributes foo and bar, but *no others*

    The normal way to create a tag pattern is using the
    [parse()](#hxl.model.TagPattern.parse) method rather than the
    constructor:

        pattern = hxl.model.TagPattern.parse(&#34;#affected+f-children&#34;)

    Args:
        tag: the basic hashtag (without attributes)
        include_attributes: a list of attributes that must be present
        exclude_attributes: a list of attributes that must not be present
        is_absolute: if True, no attributes are allowed except those in _include_attributes_

    &#34;&#34;&#34;

    
    PATTERN = r&#39;^\s*#?({token}|\*)((?:\s*[+-]{token})*)\s*(!)?\s*$&#39;.format(token=hxl.datatypes.TOKEN_PATTERN)
    &#34;&#34;&#34;Constant: regular expression to match a HXL tag pattern.
    &#34;&#34;&#34;

    def __init__(self, tag, include_attributes=[], exclude_attributes=[], is_absolute=False):
        self.tag = tag

        self.include_attributes = set(include_attributes)
        &#34;&#34;&#34;Set of all attributes that must be present&#34;&#34;&#34;
        
        self.exclude_attributes = set(exclude_attributes)
        &#34;&#34;&#34;Set of all attributes that must not be present&#34;&#34;&#34;
        
        self.is_absolute = is_absolute
        &#34;&#34;&#34;True if this pattern is absolute (no extra attributes allowed)&#34;&#34;&#34;

    def is_wildcard(self):
        return self.tag == &#39;#*&#39;

    def match(self, column):
        &#34;&#34;&#34;Check whether a Column matches this pattern.
        @param column: the column to check
        @returns: True if the column is a match
        &#34;&#34;&#34;
        if column.tag and (self.is_wildcard() or self.tag == column.tag):
            # all include_attributes must be present
            if self.include_attributes:
                for attribute in self.include_attributes:
                    if attribute not in column.attributes:
                        return False
            # all exclude_attributes must be absent
            if self.exclude_attributes:
                for attribute in self.exclude_attributes:
                    if attribute in column.attributes:
                        return False
            # if absolute, then only specified attributes may be present
            if self.is_absolute:
                for attribute in column.attributes:
                    if attribute not in self.include_attributes:
                        return False
            return True
        else:
            return False

    def get_matching_columns(self, columns):
        &#34;&#34;&#34;Return a list of columns that match the pattern.
        @param columns: a list of L{hxl.model.Column} objects
        @returns: a list (possibly empty)
        &#34;&#34;&#34;
        result = []
        for column in columns:
            if self.match(column):
                result.append(column)
        return result

    def find_column_index(self, columns):
        &#34;&#34;&#34;Get the index of the first matching column.
        @param columns: a list of columns to check
        @returns: the 0-based index of the first matching column, or None for no match
        &#34;&#34;&#34;
        for i in range(len(columns)):
            if self.match(columns[i]):
                return i
        return None

    def find_column(self, columns):
        &#34;&#34;&#34;Check whether there is a match in a list of columns.&#34;&#34;&#34;
        for column in columns:
            if self.match(column):
                return column
        return None

    def __repr__(self):
        s = self.tag
        if self.include_attributes:
            for attribute in self.include_attributes:
                s += &#39;+&#39; + attribute
        if self.exclude_attributes:
            for attribute in self.exclude_attributes:
                s += &#39;-&#39; + attribute
        return s

    __str__ = __repr__

    @staticmethod
    def parse(s):
        &#34;&#34;&#34;Parse a single tag-pattern string.

            pattern = TagPattern.parse(&#34;#affected+f-children&#34;)

        The [parse_list()](#hxl.model.TagPattern.parse_list) method
        will call this method to parse multiple patterns at once.
        
        Args:
            s: the tag-pattern string to parse

        Returns:
            A TagPattern object

        &#34;&#34;&#34;

        if not s:
            # edge case: null value
            raise hxl.HXLException(&#39;Attempt to parse empty tag pattern&#39;)
        elif isinstance(s, TagPattern):
            # edge case: already parsed
            return s

        result = re.match(TagPattern.PATTERN, s)
        if result:
            tag = &#39;#&#39; + result.group(1).lower()
            include_attributes = set()
            exclude_attributes = set()
            attribute_specs = re.split(r&#39;\s*([+-])&#39;, result.group(2))
            for i in range(1, len(attribute_specs), 2):
                if attribute_specs[i] == &#39;+&#39;:
                    include_attributes.add(attribute_specs[i + 1].lower())
                else:
                    exclude_attributes.add(attribute_specs[i + 1].lower())
            if result.group(3) == &#39;!&#39;:
                is_absolute = True
                if exclude_attributes:
                    raise ValueError(&#39;Exclusions not allowed in absolute patterns&#39;)
            else:
                is_absolute = False
            return TagPattern(
                tag,
                include_attributes=include_attributes,
                exclude_attributes=exclude_attributes,
                is_absolute=is_absolute
            )
        else:
            raise hxl.HXLException(&#39;Malformed tag: &#39; + s)

    @staticmethod
    def parse_list(specs):
        &#34;&#34;&#34;Parse a list of tag-pattern strings.

        If _specs_ is a list of already-parsed TagPattern objects, do
        nothing. If it&#39;s a list of strings, apply
        [parse()](#hxl.model.TagPattern.parse) to each one. If it&#39;s a
        single string with multiple patterns separated by commas,
        split the string, then parse the patterns.

            patterns = TagPattern.parse_list(&#34;#affected+f,#inneed+f&#34;)
            # or
            patterns = TagPattern.parse_list(&#34;#affected+f&#34;, &#34;#inneed+f&#34;)
        
        Args:
            specs: the raw input (a list of strings, or a single string with commas separating the patterns)

        Returns:
            A list of TagPattern objects.

        &#34;&#34;&#34;
        if not specs:
            return []
        if isinstance(specs, six.string_types):
            specs = specs.split(&#39;,&#39;)
        return [TagPattern.parse(spec) for spec in specs]

    @staticmethod
    def match_list(column, patterns):
        &#34;&#34;&#34;Test if a column matches any of the patterns in a list.

        This is convenient to use together with [parse_list()](hxl.model.TagPattern.parse_list):

            patterns = TagPattern.parse_list([&#34;#affected+f&#34;, &#34;#inneed+f&#34;])
            if TagPattern.match_list(column, patterns):
                print(&#34;The column matched one of the patterns&#34;)

        Args:
            column: the column to test
            patterns: a list of zero or more patterns.

        Returns:
            True if there is a match

        &#34;&#34;&#34;
        for pattern in patterns:
            if pattern.match(column):
                return True
        return False


class Dataset(object):
    &#34;&#34;&#34;Abstract base class for a HXL data source.

    Any source of parsed HXL data inherits from this class: that
    includes Dataset, HXLReader, and the various filters in the
    hxl.old_filters package.  The contract of a Dataset is that it will
    provide a columns property and a next() method to read through the
    rows.

    The child class must implement the columns() method as a property
    and the __iter__() method to make itself iterable.
    &#34;&#34;&#34;

    __metaclass__ = abc.ABCMeta

    def __init__(self):
        &#34;&#34;&#34;Constructor.&#34;&#34;&#34;
        super().__init__()

    @abc.abstractmethod
    def __iter__(self):
        &#34;&#34;&#34;Get the iterator over the rows.
        @returns: an iterator that returns L{hxl.model.Row} objects
        &#34;&#34;&#34;
        raise RuntimeException(&#34;child class must implement __iter__() method&#34;)

    @property
    def is_cached(self):
        &#34;&#34;&#34;Test whether the source data is cached (replayable).
        By default, this is False, but some subclasses may override.
        @returns: C{True} if the input is cached (replayable); C{False} otherwise.
        &#34;&#34;&#34;
        return False

    @property
    @abc.abstractmethod
    def columns(self):
        &#34;&#34;&#34;Get the column definitions for the dataset.
        @returns: a list of Column objects.
        &#34;&#34;&#34;
        raise RuntimeException(&#34;child class must implement columns property method&#34;)

    @property
    def columns_hash(self):
        &#34;&#34;&#34;Generate a hash across all of the columns in the dataset.

        This function helps detect whether two HXL documents are of
        the same type, even if they contain different data (e.g. the
        HXL API output for the same humanitarian dataset in two
        different months or two different countries).

        It takes into account text headers, hashtags, the order of
        attributes, and the order of columns. Whitespace is
        normalised, and null values are treated as empty strings. The
        MD5 hash digest is generated from a UTF-8 encoded version of
        each header.

        @returns: a 32-character hex-formatted MD5 hash string

        &#34;&#34;&#34;
        return hxl.Column.hash_list(self.columns)

    @property
    def data_hash(self):
        &#34;&#34;&#34;Generate a hash for the entire dataset.

        This function allows checking if two HXL datasets are
        functionally identical. It takes into account text headers,
        hashtags, the order of attributes, and the order of
        columns. Whitespace is normalised, and null values are treated
        as empty strings. The MD5 hash digest is generated from a
        UTF-8 encoded version of each header and data cell.

        @returns: a 32-character hex-formatted MD5 hash string
        &#34;&#34;&#34;
        md5 = hashlib.md5()
        # text header row
        for column in self.columns:
            md5.update(hxl.datatypes.normalise_space(column.header).encode(&#39;utf-8&#39;))
        # hashtag row
        for column in self.columns:
            md5.update(hxl.datatypes.normalise_space(column.display_tag).encode(&#39;utf-8&#39;))
        # data rows
        for row in self:
            for value in row:
                md5.update(hxl.datatypes.normalise_space(value).encode(&#39;utf-8&#39;))
        return md5.hexdigest()
    
    @property
    def headers(self):
        &#34;&#34;&#34;Return a list of header strings (for a spreadsheet row).
        &#34;&#34;&#34;
        return [column.header if column else &#39;&#39; for column in self.columns]

    @property
    def tags(self):
        &#34;&#34;&#34;Get all hashtags (without attributes) as a list
        @returns: a list of base hashtags for the dataset columns
        &#34;&#34;&#34;
        return [column.tag if column else &#39;&#39; for column in self.columns]

    @property
    def display_tags(self):
        &#34;&#34;&#34;Return a list of display tags.
        @returns: a list of strings containing the hashtag and attributes for each column
        &#34;&#34;&#34;
        return [column.display_tag if column else &#39;&#39; for column in self.columns]

    @property
    def has_headers(self):
        &#34;&#34;&#34;Report whether any non-empty header strings exist.
        @returns: C{True} if there is at least one column with a non-empty header string
        &#34;&#34;&#34;
        for column in self.columns:
            if column.header:
                return True
        return False

    @property
    def values(self):
        &#34;&#34;&#34;Get all values for the dataset at once, in an array of arrays.
        This method can be highly inefficient for large datasets.
        @returns: an array of arrays of scalar values
        &#34;&#34;&#34;
        return [row.values for row in self]

    def get_value_set(self, tag_pattern=None, normalise=False):
        &#34;&#34;&#34;Return the set of all values in a dataset (optionally matching a tag pattern for a single column)
        Warning: this method can be highly inefficient for large datasets.
        @param tag_pattern: (optional) return values only for columns matching this tag pattern.
        @param normalise: (optional) normalise the strings with hxl.datatypes.normalise (default: False)
        @returns: a Python set of values
        &#34;&#34;&#34;
        value_set = set([])
        if tag_pattern:
            tag_pattern = TagPattern.parse(tag_pattern)
        for row in self:
            if tag_pattern:
                new_values = row.get_all(tag_pattern)
            else:
                new_values = row.values
            if normalise:
                new_values = [hxl.datatypes.normalise(s) for s in new_values]
            else:
                new_values = [hxl.datatypes.normalise_space(s) for s in new_values]
            value_set.update(new_values)
        return value_set


    def get_column_indices(self, tag_patterns, columns):
        &#34;&#34;&#34;Get a list of indices that match the tag patterns provided
        @param tag_patterns: a list of tag patterns or a string version of the list
        @param columns: a list of columns
        @returns: a (possibly-empty) list of 0-based indices
        &#34;&#34;&#34;
        patterns = TagPattern.parse_list(tag_patterns)
        indices = []
        for i, column in enumerate(columns):
            for pattern in patterns:
                if pattern.match(column):
                    indices.push(i)
        return indices

    #
    # Aggregates
    #

    def _get_minmax(self, pattern, op):
        &#34;&#34;&#34;Calculate the extreme min/max value for a tag pattern
        Will iterate through the dataset, and use values from multiple matching columns.
        Uses numbers, dates, or strings for comparison, based on the first non-empty value found.
        @param pattern: the L{hxl.model.TagPattern} to match
        @param op: operator_lt or operator_gt
        @returns: the extreme value according to operator supplied, or None if no values found
        &#34;&#34;&#34;
        pattern = TagPattern.parse(pattern)
        result_raw = None # what&#39;s actually in the dataset
        result_normalised = None # normalised version for comparison

        # Look at every row
        for row in self:
            # Look at every matching value in every row
            for i, value in enumerate(row.get_all(pattern)):
                # ignore empty values
                if hxl.datatypes.is_empty(value):
                    continue

                # make a normalised value for comparison
                normalised = hxl.datatypes.normalise(value, row.columns[i])

                # first non-empty value is always a match
                if result_normalised is None:
                    result_raw = value
                    result_normalised = normalised
                else:
                    # try comparing the normalised types first, then strings on failure
                    try:
                        if op(normalised, result_normalised):
                            result_raw = value
                            result_normalised = normalised
                    except TypeError:
                        if op(str(normalised), str(result_normalised)):
                            result_raw = value
                            result_normalised = normalised

        return result_raw

    def min(self, pattern):
        &#34;&#34;&#34;Calculate the minimum value for a tag pattern
        Will iterate through the dataset, and use values from multiple matching columns.
        Uses numbers, dates, or strings for comparison, based on the first non-empty value found.
        @param pattern: the L{hxl.model.TagPattern} to match
        @returns: the minimum value according to the &#39;&lt;&#39; operator, or None if no values found
        &#34;&#34;&#34;
        return self._get_minmax(pattern, operator.lt)

    def max(self, pattern):
        &#34;&#34;&#34;Calculate the maximum value for a tag pattern
        Will iterate through the dataset, and use values from multiple matching columns.
        @param pattern: the L{hxl.model.TagPattern} to match
        @returns: the minimum value according to the &#39;&lt;&#39; operator, or None if no values found
        &#34;&#34;&#34;
        return self._get_minmax(pattern, operator.gt)

    #
    # Utility
    #

    def validate(self, schema=None, callback=None):
        &#34;&#34;&#34;
        Validate the current dataset.
        @param schema (optional) the pre-compiled schema, schema filename, URL, file object, etc. Defaults to a built-in schema.
        @param callback (optional) a function to call with each error or warning. Defaults to collecting errors in an array and returning them.
        &#34;&#34;&#34;
        return hxl.schema(schema, callback).validate(self)

    def recipe(self, recipe):
        &#34;&#34;&#34;Parse a recipe (JSON or a list of dicts) and create the appropriate filters.
        @param recipe: a list of dicts, a single dict, or a JSON literal string.
        @return: the new end filter.
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.from_recipe(self, recipe)

    #
    # Filters
    #

    def append(self, append_sources, add_columns=True, queries=[]):
        &#34;&#34;&#34;Append additional datasets.
        @param append_sources: a list of sources to append
        @param add_columns: if True (default), include any extra columns in the append sources
        @param queries: a list of row queries to select rows for inclusion from the append sources.
        @returns: a new HXL source for chaining
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.AppendFilter(self, append_sources, add_columns=add_columns, queries=queries)

    def append_external_list(self, source_list_url, add_columns=True, queries=[]):
        &#34;&#34;&#34;Append additional datasets from an external list
        @param source_list_url: URL of a HXL dataset containing a list of sources to append.
        @param add_columns: if True (default), include any extra columns in the append sources.
        @param queries: a list of row queries to select rows for inclusion from the append sources.
        @returns: a new HXL source for chaining
        &#34;&#34;&#34;
        import hxl.filters
        logger.debug(&#34;Loading append list from %s...&#34;, source_list_url)
        append_sources = hxl.filters.AppendFilter.parse_external_source_list(source_list_url)
        logger.debug(&#34;Done loading&#34;)
        return hxl.filters.AppendFilter(self, append_sources, add_columns=add_columns, queries=queries)

    def cache(self):
        &#34;&#34;&#34;Add a caching filter to the dataset.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.CacheFilter(self)

    def dedup(self, patterns=[], queries=[]):
        &#34;&#34;&#34;Deduplicate a dataset.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.DeduplicationFilter(self, patterns=patterns, queries=queries)

    def with_columns(self, includes):
        &#34;&#34;&#34;Select matching columns.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.ColumnFilter(self, include_tags=includes)

    def without_columns(self, excludes=None, skip_untagged=False):
        &#34;&#34;&#34;Select non-matching columns.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.ColumnFilter(self, exclude_tags=excludes, skip_untagged=skip_untagged)

    def with_rows(self, queries, mask=[]):
        &#34;&#34;&#34;Select matching rows.
        @param queries: a predicate or list of predicates for rows to include
        @param mask: a predicate or list of predicates for rows to test (default: [] to test all)
        @return: a filtered version of the source
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.RowFilter(self, queries=queries, reverse=False, mask=mask)

    def without_rows(self, queries, mask=[]):
        &#34;&#34;&#34;Select non-matching rows.
        @param queries: a predicate or list of predicates for rows to ignore
        @param mask: a predicate or list of predicates for rows to test (default: [] to test all)
        @return: a filtered version of the source
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.RowFilter(self, queries=queries, reverse=True, mask=mask)

    def sort(self, keys=None, reverse=False):
        &#34;&#34;&#34;Sort the dataset (caching).&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.SortFilter(self, tags=keys, reverse=reverse)

    def count(self, patterns=[], aggregators=None, queries=[]):
        &#34;&#34;&#34;Count values in the dataset (caching).&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.CountFilter(
            self, patterns=patterns, aggregators=aggregators, queries=queries
        )

    def row_counter(self, queries=[]):
        &#34;&#34;&#34;Count the number of rows while streaming.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.RowCountFilter(self, queries=queries)

    def replace_data(self, original, replacement, pattern=None, use_regex=False, queries=[]):
        &#34;&#34;&#34;Replace values in a HXL dataset.&#34;&#34;&#34;
        import hxl.filters
        replacement = hxl.filters.ReplaceDataFilter.Replacement(original, replacement, pattern, use_regex)
        return hxl.filters.ReplaceDataFilter(self, [replacement], queries=queries)

    def replace_data_map(self, map_source, queries=[]):
        &#34;&#34;&#34;Replace values in a HXL dataset.&#34;&#34;&#34;
        import hxl.filters
        replacements = hxl.filters.ReplaceDataFilter.Replacement.parse_map(hxl.data(map_source))
        return hxl.filters.ReplaceDataFilter(self, replacements, queries=queries)

    def add_columns(self, specs, before=False):
        &#34;&#34;&#34;Add fixed-value columns to a HXL dataset.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.AddColumnsFilter(self, specs=specs, before=before)

    def rename_columns(self, specs):
        &#34;&#34;&#34;Changes headers and tags on a column.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.RenameFilter(self, specs)

    def clean_data(
            self, whitespace=[], upper=[], lower=[], date=[], date_format=None,
            number=[], number_format=None, latlon=[], purge=False, queries=[]
    ):
        &#34;&#34;&#34;Clean data fields.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.CleanDataFilter(
            self,
            whitespace=whitespace,
            upper=upper,
            lower=lower,
            date=date, date_format=date_format,
            number=number, number_format=number_format,
            latlon=latlon,
            purge=purge,
            queries=queries
        )
    
    def merge_data(self, merge_source, keys, tags, replace=False, overwrite=False, queries=[]):
        &#34;&#34;&#34;Merges values from a second dataset.
        @param merge_source: the second HXL data source
        @param keys: a single tagspec or list of tagspecs for the shared keys
        @param tags: the tags to copy over from the second dataset
        @param replace: if True, replace existing columns when present
        @param overwrite: if True, overwrite individual values in existing columns when available
        @param queries: optional row queries to control the merge
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.MergeDataFilter(self, merge_source, keys, tags, replace, overwrite, queries=queries)

    def expand_lists(self, patterns=None, separator=&#34;|&#34;, correlate=False, queries=[]):
        &#34;&#34;&#34;Expand lists by repeating rows.
        By default, applies to every column with a +list attribute, and uses &#34;|&#34; as the separator.
        @param patterns: a single tag pattern or list of tag patterns for columns to expand
        @param separator: the list-item separator
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.ExpandListsFilter(self, patterns=patterns, separator=separator, correlate=correlate, queries=queries)

    def explode(self, header_attribute=&#39;header&#39;, value_attribute=&#39;value&#39;):
        &#34;&#34;&#34;Explodes a wide dataset into a long datasets.
        @param header_attribute: the attribute to add to the hashtag of the column with the former header (default &#39;header&#39;)
        @param value_attribute: the attribute to add to the hashtag of the column with the former value (default &#39;value&#39;)
        @return: filtered dataset.
        @see hxl.filters.ExplodeFilter
        &#34;&#34;&#34;
        
        import hxl.filters
        return hxl.filters.ExplodeFilter(self, header_attribute, value_attribute)

    def implode(self, label_pattern, value_pattern):
        &#34;&#34;&#34;Implodes a long dataset into a wide dataset
        @param label_pattern: the tag pattern to match the label column
        @param value_pattern: the tag pattern to match the 
        @return: filtered dataset.
        @see hxl.filters.ImplodeFilter
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.ImplodeFilter(self, label_pattern=label_pattern, value_pattern=value_pattern)

    def jsonpath(self, path, patterns=[], queries=[], use_json=True):
        &#34;&#34;&#34;Parse the value as a JSON expression and extract data from it.
        See http://goessner.net/articles/JsonPath/
        @param path: a JSONPath expression for extracting data
        @param patterns: a tag pattern or list of patterns for the columns to use (default to all)
        @param queries: a predicate or list of predicates for the rows to consider.
        @param use_json: if True, serialise multiple results as JSON lists.
        @returns: filtered dataset
        @see: hxl.filters.JSONPathFilter
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.JSONPathFilter(self, path, patterns=patterns, queries=queries, use_json=use_json)

    def fill_data(self, patterns=[], queries=[]):
        &#34;&#34;&#34;Fills empty cells in a column using the last non-empty value.
        @param patterns: a tag pattern or list of patterns for the columns to fill (default to all)
        @param queries: a predicate or list of predicates for rows to fill (leave any blank that don&#39;t match).
        @return filtered dataset
        @see hxl.filters.FillFilter
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.FillDataFilter(self, patterns=patterns, queries=queries)

    #
    # Generators
    #

    def gen_raw(self, show_headers=True, show_tags=True):
        &#34;&#34;&#34;Generate an array representation of a HXL dataset, one at a time.&#34;&#34;&#34;
        if show_headers:
            yield self.headers
        if show_tags:
            yield self.display_tags
        for row in self:
            yield row.values

    def gen_csv(self, show_headers=True, show_tags=True):
        &#34;&#34;&#34;Generate a CSV representation of a HXL dataset, one row at a time.&#34;&#34;&#34;
        class TextOut:
            &#34;&#34;&#34;Simple string output source to capture CSV&#34;&#34;&#34;
            def __init__(self):
                self.data = &#39;&#39;
            def write(self, s):
                self.data += s
            def get(self):
                data = self.data
                self.data = &#39;&#39;
                return data
        output = TextOut()
        writer = csv.writer(output)
        for raw in self.gen_raw(show_headers, show_tags):
            writer.writerow(raw)
            yield output.get()

    def gen_json(self, show_headers=True, show_tags=True, use_objects=False):
        &#34;&#34;&#34;Generate a JSON representation of a HXL dataset, one row at a time.&#34;&#34;&#34;
        is_first = True
        yield &#34;[\n&#34;
        if use_objects:
            for row in self:
                if is_first:
                    is_first = False
                    yield json.dumps(row.dictionary, sort_keys=True, indent=2)
                else:
                    yield &#34;,\n&#34; + json.dumps(row.dictionary, sort_keys=True, indent=2)
        else:
            for raw in self.gen_raw(show_headers, show_tags):
                if is_first:
                    is_first = False
                    yield json.dumps(raw)
                else:
                    yield &#34;,\n&#34; + json.dumps(raw)
        yield &#34;\n]\n&#34;


class Column(object):
    &#34;&#34;&#34;
    The definition of a logical column in the HXL data.
    &#34;&#34;&#34; 

    # Regular expression to match a HXL tag
    PATTERN = r&#39;^\s*(#{token})((?:\s*\+{token})*)\s*$&#39;.format(token=hxl.datatypes.TOKEN_PATTERN)

    # To tighten debugging (may reconsider later -- not really a question of memory efficiency here)
    __slots__ = [&#39;tag&#39;, &#39;attributes&#39;, &#39;attribute_list&#39;, &#39;header&#39;, &#39;column_number&#39;]

    def __init__(self, tag=None, attributes=(), header=None, column_number=None):
        &#34;&#34;&#34;
        Initialise a column definition.
        @param tag: the HXL hashtag for the column (default: None)
        @param attributes: (optional) a sequence of attributes (default: ())
        @param header: (optional) the original plaintext header for the column (default: None)
        @param column_number: (optional) the zero-based column number
        &#34;&#34;&#34;
        if tag:
            tag = tag.lower()
        self.tag = tag
        self.header = header
        self.column_number = column_number
        self.attributes = set([a.lower() for a in attributes])
        self.attribute_list = [a.lower() for a in attributes] # to preserve order

    @property
    def display_tag(self):
        &#34;&#34;&#34;Default display version of a HXL hashtag.
        Attributes are not sorted.
        &#34;&#34;&#34;
        return self.get_display_tag(sort_attributes=False)
    
    def get_display_tag(self, sort_attributes=False):
        &#34;&#34;&#34;
        Generate a display version of the column hashtag
        @param sort_attributes: if True, sort attributes; otherwise, preserve the original order
        @return the reassembled HXL hashtag string, including language code
        &#34;&#34;&#34;
        if self.tag:
            s = self.tag
            for attribute in sorted(self.attribute_list) if sort_attributes else self.attribute_list:
                s += &#39;+&#39; + attribute
            return s
        else:
            return &#39;&#39;

    def has_attribute(self, attribute):
        &#34;&#34;&#34;Check if an attribute is present.&#34;&#34;&#34;
        return (attribute in self.attribute_list)

    def add_attribute(self, attribute):
        &#34;&#34;&#34;Add an attribute to the column.&#34;&#34;&#34;
        if attribute not in self.attributes:
            self.attributes.add(attribute)
            self.attribute_list.append(attribute)
        return self

    def remove_attribute(self, attribute):
        &#34;&#34;&#34;Remove an attribute from the column.&#34;&#34;&#34;
        if attribute in self.attributes:
            self.attributes.remove(attribute)
            self.attribute_list.remove(attribute)
        return self

    def __hash__(self):
        &#34;&#34;&#34;Make columns usable in a dictionary.
        Only the hashtag and attributes are used.
        &#34;&#34;&#34;
        hash_value = hash(self.tag)
        for attribute in self.attributes:
            hash_value += hash(attribute)
        return hash_value

    def __eq__(self, other):
        &#34;&#34;&#34;Test for comparison with another object.
        For equality, only the hashtag and attributes have to be the same.&#34;&#34;&#34;
        try:
            return (self.tag == other.tag and self.attributes == other.attributes)
        except:
            return False

    def __repr__(self):
        return self.display_tag

    __str__ = __repr__

    @staticmethod
    def hash_list(columns):
        &#34;&#34;&#34;Generate a hash across all of the columns in the dataset.

        This function helps detect whether two HXL documents are of
        the same type, even if they contain different data (e.g. the
        HXL API output for the same humanitarian dataset in two
        different months or two different countries).

        It takes into account text headers, hashtags, the order of
        attributes, and the order of columns. Whitespace is
        normalised, and null values are treated as empty strings. The
        MD5 hash digest is generated from a UTF-8 encoded version of
        each header.

        @returns: a 32-character hex-formatted MD5 hash string

        &#34;&#34;&#34;
        md5 = hashlib.md5()
        for column in columns:
            md5.update(hxl.datatypes.normalise_space(column.header).encode(&#39;utf-8&#39;))
        for column in columns:
            md5.update(hxl.datatypes.normalise_space(column.display_tag).encode(&#39;utf-8&#39;))
        return md5.hexdigest()

    @staticmethod
    def parse(raw_string, header=None, use_exception=False, column_number=None):
        &#34;&#34;&#34; Attempt to parse a full hashtag specification.
        @param raw_string: the string representation of the tagspec
        @param header: the text header to include
        @param use_exception: if True, throw an exception for a malformed tagspec
        @returns: None if the string is empty, False if it&#39;s malformed (and use_exception is False), or a Column object otherwise
        &#34;&#34;&#34;
        
        # Already parsed?
        if isinstance(raw_string, Column):
            return raw_string

        # Empty string?
        if hxl.datatypes.is_empty(raw_string):
            return None
        
        # Pattern for a single tag
        result = re.match(Column.PATTERN, raw_string)
        if result:
            tag = result.group(1)
            attribute_string = result.group(2)
            if attribute_string:
                attributes = re.split(r&#39;\s*\+&#39;, attribute_string.strip().strip(&#39;+&#39;))
            else:
                attributes = []
            return Column(tag=tag, attributes=attributes, header=header, column_number=column_number)
        else:
            if use_exception:
                raise hxl.HXLException(&#34;Malformed tag expression: &#34; + raw_string)
            else:
                logger.debug(&#34;Not a HXL hashtag spec: %s&#34;, raw_string)
                return False

    @staticmethod
    def parse_spec(raw_string, default_header=None, use_exception=False, column_number=None):
        &#34;&#34;&#34;Attempt to parse a single-string header/hashtag spec&#34;&#34;&#34;
        # Already parsed?
        if isinstance(raw_string, Column):
            return raw_string
        
        matches = re.match(r&#39;^(.*)(#.*)$&#39;, raw_string)
        if matches:
            header = matches.group(1) if matches.group(1) else default_header
            return Column.parse(matches.group(2), header=header, column_number=column_number)
        else:
            return Column.parse(&#39;#&#39; + raw_string, header=default_header, column_number=column_number)

    @staticmethod
    def parse_list(raw_row, previous_row=None):
        &#34;&#34;&#34;Try parsing a raw data row as a HXL hashtag row.

        Args:
            raw_row (list): a raw row from a ``hxl.input.AbstractInput`` object
            previous_row (list): the previous raw row, for extracting headers

        Returns:
            list: a list of hxl.model.Column objects if successfully parsed; None otherwise.

        &#34;&#34;&#34;
        # how many values we&#39;ve seen
        nonEmptyCount = 0

        # the logical column number
        hashtags_found = 0

        columns = []
        failed_hashtags = []

        for source_column_number, raw_string in enumerate(raw_row):
            if previous_row and source_column_number &lt; len(previous_row):
                header = previous_row[source_column_number]
            else:
                header = None
            if not hxl.datatypes.is_empty(raw_string):
                raw_string = hxl.datatypes.normalise_string(raw_string)
                nonEmptyCount += 1
                column = hxl.model.Column.parse(raw_string, header=header, column_number=source_column_number)
                if column:
                    columns.append(column)
                    hashtags_found += 1
                    continue
                elif column is False:
                    failed_hashtags.append(raw_string)

            columns.append(hxl.model.Column(header=header, column_number=source_column_number))

        # Have we seen at least FUZZY_HASHTAG_PERCENTAGE?
        if (nonEmptyCount &gt; 0) and ((hashtags_found/float(nonEmptyCount)) &gt;= FUZZY_HASHTAG_PERCENTAGE):
            if len(failed_hashtags) &gt; 0:
                logger.error(&#39;Skipping column(s) with malformed hashtag specs: %s&#39;, &#39;, &#39;.join(failed_hashtags))
            return columns
        else:
            return None
    

class Row(object):
    &#34;&#34;&#34; An iterable row of values in a HXL dataset.

    If a value is part of a merged area, and not in the top left position, it will be a MergedCell object.
    &#34;&#34;&#34;

    # Predefine the slots for efficiency (may reconsider later)
    __slots__ = [&#39;columns&#39;, &#39;values&#39;, &#39;row_number&#39;, &#39;source_row_number&#39;]

    def __init__(self, columns, values=[], row_number=None, source_row_number=None):
        &#34;&#34;&#34;
        Set up a new row.
        @param columns: The column definitions (array of Column objects).
        @param values: (optional) The string values for the row (default: [])
        @param row_number: (optional) The zero-based logical row number in the input dataset, if available (default: None)
        @param source_row_number: (optional) The zero-based source row number in the input dataset, if available (default: None)
        &#34;&#34;&#34;
        self.columns = columns
        self.values = copy.copy(values)
        self.row_number = row_number
        self.source_row_number = source_row_number

    def append(self, value):
        &#34;&#34;&#34;
        Append a value to the row.
        @param value The new value to append.
        @return The new value
        &#34;&#34;&#34;
        self.values.append(value)
        return value

    def get(self, tag, index=None, default=None, parsed=False):
        &#34;&#34;&#34;
        Get a single value for a tag in a row.
        If no index is provided (&#34;None&#34;), return the first non-empty value.
        @param tag: A TagPattern or a string value for a tag.
        @param index: The zero-based index if there are multiple values for the tag (default: None)
        @param default: The default value if not found (default: None). Never parsed, even if parsed=True
        @param parsed: If true, use attributes as hints to try to parse the value (e.g. number, list, date)
        @return The value found, or the default value provided. If parsed=True, the return value will be a list (default: False)
        &#34;&#34;&#34;

        # FIXME - move externally, use for get_all as well, and support numbers and dates
        def parse(column, value):
            if parsed:
                if column.has_attribute(&#39;list&#39;):
                    return re.split(r&#39;\s*,\s*&#39;, value)
                else:
                    return [value]
            return value

        if type(tag) is TagPattern:
            pattern = tag
        else:
            pattern = TagPattern.parse(tag)

        for i, column in enumerate(self.columns):
            if i &gt;= len(self.values):
                break
            if pattern.match(column):
                if index is None:
                    # None (the default) is a special case: it means look
                    # for the first truthy value
                    if self.values[i]:
                        return parse(column, self.values[i])
                else:
                    # Otherwise, look for a specific index
                    if index == 0:
                        return parse(column, self.values[i])
                    else:
                        index = index - 1
        return default

    def get_all(self, tag, default=None):
        &#34;&#34;&#34;
        Get all values for a specific tag in a row
        @param tag A TagPattern or a string value for a tag.
        @return An array of values for the HXL hashtag.
        &#34;&#34;&#34;

        if type(tag) is TagPattern:
            pattern = tag
        else:
            pattern = TagPattern.parse(tag)

        result = []
        for i, column in enumerate(self.columns):
            if i &gt;= len(self.values):
                break
            if pattern.match(column):
                value = self.values[i]
                if default is not None and not value:
                    value = default
                result.append(value)
        return result

    def key(self, patterns=None, indices=None):
        &#34;&#34;&#34;Generate a unique key tuple for the row, based on a list of tag patterns
        @param patterns: a list of L{TagPattern} objects, or a parseable string
        @returns: the key as a tuple (might be empty)
        &#34;&#34;&#34;

        key = []

        # if the user doesn&#39;t provide indices, get indices from the pattern
        if not indices and patterns:
            indices = get_column_indices(patterns, self.columns)

        if indices:
            # if we have indices, use them to build the key
            for i in indices:
                if i &lt; len(self.values):
                    key.append(hxl.datatypes.normalise(self.values[i], self.columns[i]))
        else:
            # if there are still no indices, use the whole row for the key
            for i, value in enumerate(self.values):
                key.append(hxl.datatypes.normalise(value, self.columns[i]))

        return tuple(key) # make it into a tuple so that it&#39;s hashable


    @property
    def dictionary(self):
        &#34;&#34;&#34;Return the row as a Python dict.
        The keys will be HXL hashtags and attributes, normalised per HXL 1.1.
        If two or more columns have the same hashtags and attributes, only the first will be included.
        @return: The row as a Python dictionary.
        &#34;&#34;&#34;
        data = {}
        for i, col in enumerate(self.columns):
            key = col.get_display_tag(sort_attributes=True)
            if key and (not key in data) and (i &lt; len(self.values)):
                data[key] = self.values[i]
        return data

    def __getitem__(self, index):
        &#34;&#34;&#34;
        Array-access method to make this class iterable.
        @param index The zero-based index of a value to look up.
        @return The value if it exists.
        @exception IndexError if the index is out of range.
        &#34;&#34;&#34;
        return self.values[index]

    def __str__(self):
        &#34;&#34;&#34;
        Create a string representation of a row for debugging.
        &#34;&#34;&#34;
        s = &#39;&lt;Row&#39;;
        for column_number, value in enumerate(self.values):
            s += &#34;\n  &#34; + str(self.columns[column_number]) + &#34;=&#34; + str(value)
        s += &#34;\n&gt;&#34;
        return s


class RowQuery(object):
    &#34;&#34;&#34;Query to execute against a row of HXL data.&#34;&#34;&#34;

    def __init__(self, pattern, op, value, is_aggregate=False):
        &#34;&#34;&#34;Constructor
        @param pattern: the L{TagPattern} to match in the row
        @param op: the operator function to use for comparison
        @param value: the value to compare against
        @param is_aggregate: if True, the value is a special placeholder like &#34;min&#34; or &#34;max&#34; that needs to be calculated
        &#34;&#34;&#34;
        self.pattern = TagPattern.parse(pattern)
        self.op = op
        self.value = value

        # if the value is a formula, extract it
        self.formula = None
        result = re.match(r&#39;^{{(.+)}}$&#39;, hxl.datatypes.normalise_space(value))
        if result:
            self.formula = result.group(1)

        self.is_aggregate=is_aggregate
        self.needs_aggregate = False
        &#34;&#34;&#34;Need to calculate an aggregate value&#34;&#34;&#34;
        
        if is_aggregate:
            self.needs_aggregate = True

        # calculate later
        self.date_value = None
        self.number_value = None
        self._saved_indices = None

    def calc_aggregate(self, dataset):
        &#34;&#34;&#34;Calculate the aggregate value that we need for the row query
        Substitute the special values &#34;min&#34; and &#34;max&#34; with aggregates.
        @param dataset: the HXL dataset to use (must be cached)
        &#34;&#34;&#34;
        if not self.needs_aggregate:
            logger.warning(&#34;no aggregate calculation needed&#34;)
            return # no need to calculate
        if not dataset.is_cached:
            raise HXLException(&#34;need a cached dataset for calculating an aggregate value&#34;)
        if self.value == &#39;min&#39;:
            self.value = dataset.min(self.pattern)
            self.op = operator.eq
        elif self.value == &#39;max&#39;:
            self.value = dataset.max(self.pattern)
            self.op = operator.eq
        elif self.value == &#39;not min&#39;:
            self.value = dataset.min(self.pattern)
            self.op = operator.ne
        elif self.value == &#39;not max&#39;:
            self.value = dataset.max(self.pattern)
            self.op = operator.ne
        else:
            raise HXLException(&#34;Unrecognised aggregate: {}&#34;.format(value))
        self.needs_aggregate = False
                               
    def match_row(self, row):
        &#34;&#34;&#34;Check if a key-value pair appears in a HXL row&#34;&#34;&#34;

        # fail if we need an aggregate and haven&#39;t calculated it
        if self.needs_aggregate and not self.aggregate_is_calculated:
            raise HXLException(&#34;must call calc_aggregate before matching an &#39;is min&#39; or &#39;is max&#39; condition&#34;)

        # initialise is this is the first time matching for the row query
        if self._saved_indices is None or self.formula:

            # if it&#39;s a row formula, evaluate first
            if self.formula:
                value = hxl.formulas.eval.eval(row, self.formula)
            else:
                value = self.value

            if self.pattern.tag == &#39;#date&#39;:
                try:
                    self.date_value = hxl.datatypes.normalise_date(value)
                except ValueError:
                    self.date_value = None

            try:
                self.number_value = hxl.datatypes.normalise_number(value)
            except ValueError:
                self.number_value = None

            self.string_value = hxl.datatypes.normalise_string(value)

        # try all the matching column values
        indices = self._get_saved_indices(row.columns)
        for i in indices:
            if i &lt; len(row.values) and self.match_value(row.values[i], self.op):
                return True
        return False


    def match_value(self, value, op):
        &#34;&#34;&#34;Try matching as dates, then as numbers, then as simple strings&#34;&#34;&#34;
        if self.date_value is not None:
            try:
                return op(hxl.datatypes.normalise_date(value), self.date_value)
            except ValueError:
                pass

        if self.number_value is not None:
            try:
                return op(hxl.datatypes.normalise_number(value), self.number_value)
            except:
                pass

        return self.op(hxl.datatypes.normalise_string(value), self.string_value)

    def _get_saved_indices(self, columns):
        &#34;&#34;&#34;Cache the column tests, so that we run them only once.&#34;&#34;&#34;
        # FIXME - assuming that the columns never change
        self._saved_indices = []
        for i in range(len(columns)):
            if self.pattern.match(columns[i]):
                self._saved_indices.append(i)
        return self._saved_indices

    @staticmethod
    def parse(query):
        &#34;&#34;&#34;Parse a filter expression&#34;&#34;&#34;
        if isinstance(query, RowQuery):
            # already parsed
            return query
        parts = re.split(r&#39;([&lt;&gt;]=?|!?=|!?~|\bis\b)&#39;, hxl.datatypes.normalise_string(query), maxsplit=1)
        pattern = TagPattern.parse(parts[0])
        op_name = hxl.datatypes.normalise_string(parts[1])
        op = RowQuery.OPERATOR_MAP.get(op_name)
        value = hxl.datatypes.normalise_string(parts[2])
        is_aggregate = False
        # special handling for aggregates (FIXME)
        if op_name == &#39;is&#39; and value in (&#39;min&#39;, &#39;max&#39;, &#39;not min&#39;, &#39;not max&#39;):
            is_aggregate = True
        return RowQuery(pattern, op, value, is_aggregate)

    @staticmethod
    def parse_list(queries):
        &#34;&#34;&#34;Parse a single query spec or a list of specs.&#34;&#34;&#34;
        if queries:
            if not hasattr(queries, &#39;__len__&#39;) or isinstance(queries, six.string_types):
                # make a list if needed
                queries = [queries]
            return [hxl.model.RowQuery.parse(query) for query in queries]
        else:
            return []

    @staticmethod
    def match_list(row, queries=None, reverse=False):
        &#34;&#34;&#34;See if any query in a list matches a row.&#34;&#34;&#34;
        if not queries:
            # no queries = pass
            return True
        else:
            # otherwise, must match at least one
            for query in queries:
                if query.match_row(row):
                    return not reverse
            return reverse

    @staticmethod
    def operator_re(s, pattern):
        &#34;&#34;&#34;Regular-expression comparison operator.&#34;&#34;&#34;
        return re.search(pattern, s)

    @staticmethod
    def operator_nre(s, pattern):
        &#34;&#34;&#34;Regular-expression negative comparison operator.&#34;&#34;&#34;
        return not re.search(pattern, s)

    @staticmethod
    def operator_is(s, condition):
        &#34;&#34;&#34;Advanced tests
        Note: this won&#39;t be called for aggregate values like &#34;is min&#34; or &#34;is not max&#34;;
        for these, the aggregate will already be calculated, and a simple comparison
        operator substituted by L{calc_aggregate}.
        &#34;&#34;&#34;
        if condition == &#39;empty&#39;:
            return hxl.datatypes.is_empty(s)
        elif condition == &#39;not empty&#39;:
            return not hxl.datatypes.is_empty(s)
        elif condition == &#39;number&#39;:
            return hxl.datatypes.is_number(s)
        elif condition == &#39;not number&#39;:
            return not hxl.datatypes.is_number(s)
        elif condition == &#39;date&#39;:
            return (hxl.datatypes.is_date(s))
        elif condition == &#39;not date&#39;:
            return (hxl.datatypes.is_date(s) is False)
        else:
            raise hxl.HXLException(&#39;Unknown is condition: {}&#39;.format(condition))
    

    # Constant map of comparison operators
    OPERATOR_MAP = {
        &#39;=&#39;: operator.eq,
        &#39;!=&#39;: operator.ne,
        &#39;&lt;&#39;: operator.lt,
        &#39;&lt;=&#39;: operator.le,
        &#39;&gt;&#39;: operator.gt,
        &#39;&gt;=&#39;: operator.ge,
    }

    
# Static functions

def get_column_indices(tag_patterns, columns):
    &#34;&#34;&#34;Get a list of column indices that match the tag patterns provided
    @param tag_patterns: a list of tag patterns or a string version of the list
    @param columns: a list of columns
    @returns: a (possibly-empty) list of 0-based indices
    &#34;&#34;&#34;
    tag_patterns = TagPattern.parse_list(tag_patterns)
    columns = [Column.parse(column) for column in columns]
    indices = []
    for i, column in enumerate(columns):
        for pattern in tag_patterns:
            if pattern.match(column):
                indices.append(i)
    return indices


# Extra static initialisation
RowQuery.OPERATOR_MAP[&#39;~&#39;] = RowQuery.operator_re
RowQuery.OPERATOR_MAP[&#39;!~&#39;] = RowQuery.operator_nre
RowQuery.OPERATOR_MAP[&#39;is&#39;] = RowQuery.operator_is


# end</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hxl.model.get_column_indices"><code class="name flex">
<span>def <span class="ident">get_column_indices</span></span>(<span>tag_patterns, columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of column indices that match the tag patterns provided
@param tag_patterns: a list of tag patterns or a string version of the list
@param columns: a list of columns
@returns: a (possibly-empty) list of 0-based indices</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column_indices(tag_patterns, columns):
    &#34;&#34;&#34;Get a list of column indices that match the tag patterns provided
    @param tag_patterns: a list of tag patterns or a string version of the list
    @param columns: a list of columns
    @returns: a (possibly-empty) list of 0-based indices
    &#34;&#34;&#34;
    tag_patterns = TagPattern.parse_list(tag_patterns)
    columns = [Column.parse(column) for column in columns]
    indices = []
    for i, column in enumerate(columns):
        for pattern in tag_patterns:
            if pattern.match(column):
                indices.append(i)
    return indices</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hxl.model.Column"><code class="flex name class">
<span>class <span class="ident">Column</span></span>
<span>(</span><span>tag=None, attributes=(), header=None, column_number=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The definition of a logical column in the HXL data.</p>
<p>Initialise a column definition.
@param tag: the HXL hashtag for the column (default: None)
@param attributes: (optional) a sequence of attributes (default: ())
@param header: (optional) the original plaintext header for the column (default: None)
@param column_number: (optional) the zero-based column number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Column(object):
    &#34;&#34;&#34;
    The definition of a logical column in the HXL data.
    &#34;&#34;&#34; 

    # Regular expression to match a HXL tag
    PATTERN = r&#39;^\s*(#{token})((?:\s*\+{token})*)\s*$&#39;.format(token=hxl.datatypes.TOKEN_PATTERN)

    # To tighten debugging (may reconsider later -- not really a question of memory efficiency here)
    __slots__ = [&#39;tag&#39;, &#39;attributes&#39;, &#39;attribute_list&#39;, &#39;header&#39;, &#39;column_number&#39;]

    def __init__(self, tag=None, attributes=(), header=None, column_number=None):
        &#34;&#34;&#34;
        Initialise a column definition.
        @param tag: the HXL hashtag for the column (default: None)
        @param attributes: (optional) a sequence of attributes (default: ())
        @param header: (optional) the original plaintext header for the column (default: None)
        @param column_number: (optional) the zero-based column number
        &#34;&#34;&#34;
        if tag:
            tag = tag.lower()
        self.tag = tag
        self.header = header
        self.column_number = column_number
        self.attributes = set([a.lower() for a in attributes])
        self.attribute_list = [a.lower() for a in attributes] # to preserve order

    @property
    def display_tag(self):
        &#34;&#34;&#34;Default display version of a HXL hashtag.
        Attributes are not sorted.
        &#34;&#34;&#34;
        return self.get_display_tag(sort_attributes=False)
    
    def get_display_tag(self, sort_attributes=False):
        &#34;&#34;&#34;
        Generate a display version of the column hashtag
        @param sort_attributes: if True, sort attributes; otherwise, preserve the original order
        @return the reassembled HXL hashtag string, including language code
        &#34;&#34;&#34;
        if self.tag:
            s = self.tag
            for attribute in sorted(self.attribute_list) if sort_attributes else self.attribute_list:
                s += &#39;+&#39; + attribute
            return s
        else:
            return &#39;&#39;

    def has_attribute(self, attribute):
        &#34;&#34;&#34;Check if an attribute is present.&#34;&#34;&#34;
        return (attribute in self.attribute_list)

    def add_attribute(self, attribute):
        &#34;&#34;&#34;Add an attribute to the column.&#34;&#34;&#34;
        if attribute not in self.attributes:
            self.attributes.add(attribute)
            self.attribute_list.append(attribute)
        return self

    def remove_attribute(self, attribute):
        &#34;&#34;&#34;Remove an attribute from the column.&#34;&#34;&#34;
        if attribute in self.attributes:
            self.attributes.remove(attribute)
            self.attribute_list.remove(attribute)
        return self

    def __hash__(self):
        &#34;&#34;&#34;Make columns usable in a dictionary.
        Only the hashtag and attributes are used.
        &#34;&#34;&#34;
        hash_value = hash(self.tag)
        for attribute in self.attributes:
            hash_value += hash(attribute)
        return hash_value

    def __eq__(self, other):
        &#34;&#34;&#34;Test for comparison with another object.
        For equality, only the hashtag and attributes have to be the same.&#34;&#34;&#34;
        try:
            return (self.tag == other.tag and self.attributes == other.attributes)
        except:
            return False

    def __repr__(self):
        return self.display_tag

    __str__ = __repr__

    @staticmethod
    def hash_list(columns):
        &#34;&#34;&#34;Generate a hash across all of the columns in the dataset.

        This function helps detect whether two HXL documents are of
        the same type, even if they contain different data (e.g. the
        HXL API output for the same humanitarian dataset in two
        different months or two different countries).

        It takes into account text headers, hashtags, the order of
        attributes, and the order of columns. Whitespace is
        normalised, and null values are treated as empty strings. The
        MD5 hash digest is generated from a UTF-8 encoded version of
        each header.

        @returns: a 32-character hex-formatted MD5 hash string

        &#34;&#34;&#34;
        md5 = hashlib.md5()
        for column in columns:
            md5.update(hxl.datatypes.normalise_space(column.header).encode(&#39;utf-8&#39;))
        for column in columns:
            md5.update(hxl.datatypes.normalise_space(column.display_tag).encode(&#39;utf-8&#39;))
        return md5.hexdigest()

    @staticmethod
    def parse(raw_string, header=None, use_exception=False, column_number=None):
        &#34;&#34;&#34; Attempt to parse a full hashtag specification.
        @param raw_string: the string representation of the tagspec
        @param header: the text header to include
        @param use_exception: if True, throw an exception for a malformed tagspec
        @returns: None if the string is empty, False if it&#39;s malformed (and use_exception is False), or a Column object otherwise
        &#34;&#34;&#34;
        
        # Already parsed?
        if isinstance(raw_string, Column):
            return raw_string

        # Empty string?
        if hxl.datatypes.is_empty(raw_string):
            return None
        
        # Pattern for a single tag
        result = re.match(Column.PATTERN, raw_string)
        if result:
            tag = result.group(1)
            attribute_string = result.group(2)
            if attribute_string:
                attributes = re.split(r&#39;\s*\+&#39;, attribute_string.strip().strip(&#39;+&#39;))
            else:
                attributes = []
            return Column(tag=tag, attributes=attributes, header=header, column_number=column_number)
        else:
            if use_exception:
                raise hxl.HXLException(&#34;Malformed tag expression: &#34; + raw_string)
            else:
                logger.debug(&#34;Not a HXL hashtag spec: %s&#34;, raw_string)
                return False

    @staticmethod
    def parse_spec(raw_string, default_header=None, use_exception=False, column_number=None):
        &#34;&#34;&#34;Attempt to parse a single-string header/hashtag spec&#34;&#34;&#34;
        # Already parsed?
        if isinstance(raw_string, Column):
            return raw_string
        
        matches = re.match(r&#39;^(.*)(#.*)$&#39;, raw_string)
        if matches:
            header = matches.group(1) if matches.group(1) else default_header
            return Column.parse(matches.group(2), header=header, column_number=column_number)
        else:
            return Column.parse(&#39;#&#39; + raw_string, header=default_header, column_number=column_number)

    @staticmethod
    def parse_list(raw_row, previous_row=None):
        &#34;&#34;&#34;Try parsing a raw data row as a HXL hashtag row.

        Args:
            raw_row (list): a raw row from a ``hxl.input.AbstractInput`` object
            previous_row (list): the previous raw row, for extracting headers

        Returns:
            list: a list of hxl.model.Column objects if successfully parsed; None otherwise.

        &#34;&#34;&#34;
        # how many values we&#39;ve seen
        nonEmptyCount = 0

        # the logical column number
        hashtags_found = 0

        columns = []
        failed_hashtags = []

        for source_column_number, raw_string in enumerate(raw_row):
            if previous_row and source_column_number &lt; len(previous_row):
                header = previous_row[source_column_number]
            else:
                header = None
            if not hxl.datatypes.is_empty(raw_string):
                raw_string = hxl.datatypes.normalise_string(raw_string)
                nonEmptyCount += 1
                column = hxl.model.Column.parse(raw_string, header=header, column_number=source_column_number)
                if column:
                    columns.append(column)
                    hashtags_found += 1
                    continue
                elif column is False:
                    failed_hashtags.append(raw_string)

            columns.append(hxl.model.Column(header=header, column_number=source_column_number))

        # Have we seen at least FUZZY_HASHTAG_PERCENTAGE?
        if (nonEmptyCount &gt; 0) and ((hashtags_found/float(nonEmptyCount)) &gt;= FUZZY_HASHTAG_PERCENTAGE):
            if len(failed_hashtags) &gt; 0:
                logger.error(&#39;Skipping column(s) with malformed hashtag specs: %s&#39;, &#39;, &#39;.join(failed_hashtags))
            return columns
        else:
            return None</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="hxl.model.Column.PATTERN"><code class="name">var <span class="ident">PATTERN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="hxl.model.Column.hash_list"><code class="name flex">
<span>def <span class="ident">hash_list</span></span>(<span>columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a hash across all of the columns in the dataset.</p>
<p>This function helps detect whether two HXL documents are of
the same type, even if they contain different data (e.g. the
HXL API output for the same humanitarian dataset in two
different months or two different countries).</p>
<p>It takes into account text headers, hashtags, the order of
attributes, and the order of columns. Whitespace is
normalised, and null values are treated as empty strings. The
MD5 hash digest is generated from a UTF-8 encoded version of
each header.</p>
<p>@returns: a 32-character hex-formatted MD5 hash string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def hash_list(columns):
    &#34;&#34;&#34;Generate a hash across all of the columns in the dataset.

    This function helps detect whether two HXL documents are of
    the same type, even if they contain different data (e.g. the
    HXL API output for the same humanitarian dataset in two
    different months or two different countries).

    It takes into account text headers, hashtags, the order of
    attributes, and the order of columns. Whitespace is
    normalised, and null values are treated as empty strings. The
    MD5 hash digest is generated from a UTF-8 encoded version of
    each header.

    @returns: a 32-character hex-formatted MD5 hash string

    &#34;&#34;&#34;
    md5 = hashlib.md5()
    for column in columns:
        md5.update(hxl.datatypes.normalise_space(column.header).encode(&#39;utf-8&#39;))
    for column in columns:
        md5.update(hxl.datatypes.normalise_space(column.display_tag).encode(&#39;utf-8&#39;))
    return md5.hexdigest()</code></pre>
</details>
</dd>
<dt id="hxl.model.Column.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>raw_string, header=None, use_exception=False, column_number=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to parse a full hashtag specification.
@param raw_string: the string representation of the tagspec
@param header: the text header to include
@param use_exception: if True, throw an exception for a malformed tagspec
@returns: None if the string is empty, False if it's malformed (and use_exception is False), or a Column object otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(raw_string, header=None, use_exception=False, column_number=None):
    &#34;&#34;&#34; Attempt to parse a full hashtag specification.
    @param raw_string: the string representation of the tagspec
    @param header: the text header to include
    @param use_exception: if True, throw an exception for a malformed tagspec
    @returns: None if the string is empty, False if it&#39;s malformed (and use_exception is False), or a Column object otherwise
    &#34;&#34;&#34;
    
    # Already parsed?
    if isinstance(raw_string, Column):
        return raw_string

    # Empty string?
    if hxl.datatypes.is_empty(raw_string):
        return None
    
    # Pattern for a single tag
    result = re.match(Column.PATTERN, raw_string)
    if result:
        tag = result.group(1)
        attribute_string = result.group(2)
        if attribute_string:
            attributes = re.split(r&#39;\s*\+&#39;, attribute_string.strip().strip(&#39;+&#39;))
        else:
            attributes = []
        return Column(tag=tag, attributes=attributes, header=header, column_number=column_number)
    else:
        if use_exception:
            raise hxl.HXLException(&#34;Malformed tag expression: &#34; + raw_string)
        else:
            logger.debug(&#34;Not a HXL hashtag spec: %s&#34;, raw_string)
            return False</code></pre>
</details>
</dd>
<dt id="hxl.model.Column.parse_list"><code class="name flex">
<span>def <span class="ident">parse_list</span></span>(<span>raw_row, previous_row=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Try parsing a raw data row as a HXL hashtag row.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_row</code></strong> :&ensp;<code>list</code></dt>
<dd>a raw row from a <code><a title="hxl.input.AbstractInput" href="input.html#hxl.input.AbstractInput">AbstractInput</a></code> object</dd>
<dt><strong><code>previous_row</code></strong> :&ensp;<code>list</code></dt>
<dd>the previous raw row, for extracting headers</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>a list of hxl.model.Column objects if successfully parsed; None otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_list(raw_row, previous_row=None):
    &#34;&#34;&#34;Try parsing a raw data row as a HXL hashtag row.

    Args:
        raw_row (list): a raw row from a ``hxl.input.AbstractInput`` object
        previous_row (list): the previous raw row, for extracting headers

    Returns:
        list: a list of hxl.model.Column objects if successfully parsed; None otherwise.

    &#34;&#34;&#34;
    # how many values we&#39;ve seen
    nonEmptyCount = 0

    # the logical column number
    hashtags_found = 0

    columns = []
    failed_hashtags = []

    for source_column_number, raw_string in enumerate(raw_row):
        if previous_row and source_column_number &lt; len(previous_row):
            header = previous_row[source_column_number]
        else:
            header = None
        if not hxl.datatypes.is_empty(raw_string):
            raw_string = hxl.datatypes.normalise_string(raw_string)
            nonEmptyCount += 1
            column = hxl.model.Column.parse(raw_string, header=header, column_number=source_column_number)
            if column:
                columns.append(column)
                hashtags_found += 1
                continue
            elif column is False:
                failed_hashtags.append(raw_string)

        columns.append(hxl.model.Column(header=header, column_number=source_column_number))

    # Have we seen at least FUZZY_HASHTAG_PERCENTAGE?
    if (nonEmptyCount &gt; 0) and ((hashtags_found/float(nonEmptyCount)) &gt;= FUZZY_HASHTAG_PERCENTAGE):
        if len(failed_hashtags) &gt; 0:
            logger.error(&#39;Skipping column(s) with malformed hashtag specs: %s&#39;, &#39;, &#39;.join(failed_hashtags))
        return columns
    else:
        return None</code></pre>
</details>
</dd>
<dt id="hxl.model.Column.parse_spec"><code class="name flex">
<span>def <span class="ident">parse_spec</span></span>(<span>raw_string, default_header=None, use_exception=False, column_number=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to parse a single-string header/hashtag spec</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_spec(raw_string, default_header=None, use_exception=False, column_number=None):
    &#34;&#34;&#34;Attempt to parse a single-string header/hashtag spec&#34;&#34;&#34;
    # Already parsed?
    if isinstance(raw_string, Column):
        return raw_string
    
    matches = re.match(r&#39;^(.*)(#.*)$&#39;, raw_string)
    if matches:
        header = matches.group(1) if matches.group(1) else default_header
        return Column.parse(matches.group(2), header=header, column_number=column_number)
    else:
        return Column.parse(&#39;#&#39; + raw_string, header=default_header, column_number=column_number)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.model.Column.attribute_list"><code class="name">var <span class="ident">attribute_list</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="hxl.model.Column.attributes"><code class="name">var <span class="ident">attributes</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="hxl.model.Column.column_number"><code class="name">var <span class="ident">column_number</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="hxl.model.Column.display_tag"><code class="name">var <span class="ident">display_tag</span></code></dt>
<dd>
<div class="desc"><p>Default display version of a HXL hashtag.
Attributes are not sorted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def display_tag(self):
    &#34;&#34;&#34;Default display version of a HXL hashtag.
    Attributes are not sorted.
    &#34;&#34;&#34;
    return self.get_display_tag(sort_attributes=False)</code></pre>
</details>
</dd>
<dt id="hxl.model.Column.header"><code class="name">var <span class="ident">header</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="hxl.model.Column.tag"><code class="name">var <span class="ident">tag</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.model.Column.add_attribute"><code class="name flex">
<span>def <span class="ident">add_attribute</span></span>(<span>self, attribute)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an attribute to the column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_attribute(self, attribute):
    &#34;&#34;&#34;Add an attribute to the column.&#34;&#34;&#34;
    if attribute not in self.attributes:
        self.attributes.add(attribute)
        self.attribute_list.append(attribute)
    return self</code></pre>
</details>
</dd>
<dt id="hxl.model.Column.get_display_tag"><code class="name flex">
<span>def <span class="ident">get_display_tag</span></span>(<span>self, sort_attributes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a display version of the column hashtag
@param sort_attributes: if True, sort attributes; otherwise, preserve the original order
@return the reassembled HXL hashtag string, including language code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_display_tag(self, sort_attributes=False):
    &#34;&#34;&#34;
    Generate a display version of the column hashtag
    @param sort_attributes: if True, sort attributes; otherwise, preserve the original order
    @return the reassembled HXL hashtag string, including language code
    &#34;&#34;&#34;
    if self.tag:
        s = self.tag
        for attribute in sorted(self.attribute_list) if sort_attributes else self.attribute_list:
            s += &#39;+&#39; + attribute
        return s
    else:
        return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="hxl.model.Column.has_attribute"><code class="name flex">
<span>def <span class="ident">has_attribute</span></span>(<span>self, attribute)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if an attribute is present.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_attribute(self, attribute):
    &#34;&#34;&#34;Check if an attribute is present.&#34;&#34;&#34;
    return (attribute in self.attribute_list)</code></pre>
</details>
</dd>
<dt id="hxl.model.Column.remove_attribute"><code class="name flex">
<span>def <span class="ident">remove_attribute</span></span>(<span>self, attribute)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an attribute from the column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_attribute(self, attribute):
    &#34;&#34;&#34;Remove an attribute from the column.&#34;&#34;&#34;
    if attribute in self.attributes:
        self.attributes.remove(attribute)
        self.attribute_list.remove(attribute)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hxl.model.Dataset"><code class="flex name class">
<span>class <span class="ident">Dataset</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for a HXL data source.</p>
<p>Any source of parsed HXL data inherits from this class: that
includes Dataset, HXLReader, and the various filters in the
hxl.old_filters package.
The contract of a Dataset is that it will
provide a columns property and a next() method to read through the
rows.</p>
<p>The child class must implement the columns() method as a property
and the <strong>iter</strong>() method to make itself iterable.</p>
<p>Constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dataset(object):
    &#34;&#34;&#34;Abstract base class for a HXL data source.

    Any source of parsed HXL data inherits from this class: that
    includes Dataset, HXLReader, and the various filters in the
    hxl.old_filters package.  The contract of a Dataset is that it will
    provide a columns property and a next() method to read through the
    rows.

    The child class must implement the columns() method as a property
    and the __iter__() method to make itself iterable.
    &#34;&#34;&#34;

    __metaclass__ = abc.ABCMeta

    def __init__(self):
        &#34;&#34;&#34;Constructor.&#34;&#34;&#34;
        super().__init__()

    @abc.abstractmethod
    def __iter__(self):
        &#34;&#34;&#34;Get the iterator over the rows.
        @returns: an iterator that returns L{hxl.model.Row} objects
        &#34;&#34;&#34;
        raise RuntimeException(&#34;child class must implement __iter__() method&#34;)

    @property
    def is_cached(self):
        &#34;&#34;&#34;Test whether the source data is cached (replayable).
        By default, this is False, but some subclasses may override.
        @returns: C{True} if the input is cached (replayable); C{False} otherwise.
        &#34;&#34;&#34;
        return False

    @property
    @abc.abstractmethod
    def columns(self):
        &#34;&#34;&#34;Get the column definitions for the dataset.
        @returns: a list of Column objects.
        &#34;&#34;&#34;
        raise RuntimeException(&#34;child class must implement columns property method&#34;)

    @property
    def columns_hash(self):
        &#34;&#34;&#34;Generate a hash across all of the columns in the dataset.

        This function helps detect whether two HXL documents are of
        the same type, even if they contain different data (e.g. the
        HXL API output for the same humanitarian dataset in two
        different months or two different countries).

        It takes into account text headers, hashtags, the order of
        attributes, and the order of columns. Whitespace is
        normalised, and null values are treated as empty strings. The
        MD5 hash digest is generated from a UTF-8 encoded version of
        each header.

        @returns: a 32-character hex-formatted MD5 hash string

        &#34;&#34;&#34;
        return hxl.Column.hash_list(self.columns)

    @property
    def data_hash(self):
        &#34;&#34;&#34;Generate a hash for the entire dataset.

        This function allows checking if two HXL datasets are
        functionally identical. It takes into account text headers,
        hashtags, the order of attributes, and the order of
        columns. Whitespace is normalised, and null values are treated
        as empty strings. The MD5 hash digest is generated from a
        UTF-8 encoded version of each header and data cell.

        @returns: a 32-character hex-formatted MD5 hash string
        &#34;&#34;&#34;
        md5 = hashlib.md5()
        # text header row
        for column in self.columns:
            md5.update(hxl.datatypes.normalise_space(column.header).encode(&#39;utf-8&#39;))
        # hashtag row
        for column in self.columns:
            md5.update(hxl.datatypes.normalise_space(column.display_tag).encode(&#39;utf-8&#39;))
        # data rows
        for row in self:
            for value in row:
                md5.update(hxl.datatypes.normalise_space(value).encode(&#39;utf-8&#39;))
        return md5.hexdigest()
    
    @property
    def headers(self):
        &#34;&#34;&#34;Return a list of header strings (for a spreadsheet row).
        &#34;&#34;&#34;
        return [column.header if column else &#39;&#39; for column in self.columns]

    @property
    def tags(self):
        &#34;&#34;&#34;Get all hashtags (without attributes) as a list
        @returns: a list of base hashtags for the dataset columns
        &#34;&#34;&#34;
        return [column.tag if column else &#39;&#39; for column in self.columns]

    @property
    def display_tags(self):
        &#34;&#34;&#34;Return a list of display tags.
        @returns: a list of strings containing the hashtag and attributes for each column
        &#34;&#34;&#34;
        return [column.display_tag if column else &#39;&#39; for column in self.columns]

    @property
    def has_headers(self):
        &#34;&#34;&#34;Report whether any non-empty header strings exist.
        @returns: C{True} if there is at least one column with a non-empty header string
        &#34;&#34;&#34;
        for column in self.columns:
            if column.header:
                return True
        return False

    @property
    def values(self):
        &#34;&#34;&#34;Get all values for the dataset at once, in an array of arrays.
        This method can be highly inefficient for large datasets.
        @returns: an array of arrays of scalar values
        &#34;&#34;&#34;
        return [row.values for row in self]

    def get_value_set(self, tag_pattern=None, normalise=False):
        &#34;&#34;&#34;Return the set of all values in a dataset (optionally matching a tag pattern for a single column)
        Warning: this method can be highly inefficient for large datasets.
        @param tag_pattern: (optional) return values only for columns matching this tag pattern.
        @param normalise: (optional) normalise the strings with hxl.datatypes.normalise (default: False)
        @returns: a Python set of values
        &#34;&#34;&#34;
        value_set = set([])
        if tag_pattern:
            tag_pattern = TagPattern.parse(tag_pattern)
        for row in self:
            if tag_pattern:
                new_values = row.get_all(tag_pattern)
            else:
                new_values = row.values
            if normalise:
                new_values = [hxl.datatypes.normalise(s) for s in new_values]
            else:
                new_values = [hxl.datatypes.normalise_space(s) for s in new_values]
            value_set.update(new_values)
        return value_set


    def get_column_indices(self, tag_patterns, columns):
        &#34;&#34;&#34;Get a list of indices that match the tag patterns provided
        @param tag_patterns: a list of tag patterns or a string version of the list
        @param columns: a list of columns
        @returns: a (possibly-empty) list of 0-based indices
        &#34;&#34;&#34;
        patterns = TagPattern.parse_list(tag_patterns)
        indices = []
        for i, column in enumerate(columns):
            for pattern in patterns:
                if pattern.match(column):
                    indices.push(i)
        return indices

    #
    # Aggregates
    #

    def _get_minmax(self, pattern, op):
        &#34;&#34;&#34;Calculate the extreme min/max value for a tag pattern
        Will iterate through the dataset, and use values from multiple matching columns.
        Uses numbers, dates, or strings for comparison, based on the first non-empty value found.
        @param pattern: the L{hxl.model.TagPattern} to match
        @param op: operator_lt or operator_gt
        @returns: the extreme value according to operator supplied, or None if no values found
        &#34;&#34;&#34;
        pattern = TagPattern.parse(pattern)
        result_raw = None # what&#39;s actually in the dataset
        result_normalised = None # normalised version for comparison

        # Look at every row
        for row in self:
            # Look at every matching value in every row
            for i, value in enumerate(row.get_all(pattern)):
                # ignore empty values
                if hxl.datatypes.is_empty(value):
                    continue

                # make a normalised value for comparison
                normalised = hxl.datatypes.normalise(value, row.columns[i])

                # first non-empty value is always a match
                if result_normalised is None:
                    result_raw = value
                    result_normalised = normalised
                else:
                    # try comparing the normalised types first, then strings on failure
                    try:
                        if op(normalised, result_normalised):
                            result_raw = value
                            result_normalised = normalised
                    except TypeError:
                        if op(str(normalised), str(result_normalised)):
                            result_raw = value
                            result_normalised = normalised

        return result_raw

    def min(self, pattern):
        &#34;&#34;&#34;Calculate the minimum value for a tag pattern
        Will iterate through the dataset, and use values from multiple matching columns.
        Uses numbers, dates, or strings for comparison, based on the first non-empty value found.
        @param pattern: the L{hxl.model.TagPattern} to match
        @returns: the minimum value according to the &#39;&lt;&#39; operator, or None if no values found
        &#34;&#34;&#34;
        return self._get_minmax(pattern, operator.lt)

    def max(self, pattern):
        &#34;&#34;&#34;Calculate the maximum value for a tag pattern
        Will iterate through the dataset, and use values from multiple matching columns.
        @param pattern: the L{hxl.model.TagPattern} to match
        @returns: the minimum value according to the &#39;&lt;&#39; operator, or None if no values found
        &#34;&#34;&#34;
        return self._get_minmax(pattern, operator.gt)

    #
    # Utility
    #

    def validate(self, schema=None, callback=None):
        &#34;&#34;&#34;
        Validate the current dataset.
        @param schema (optional) the pre-compiled schema, schema filename, URL, file object, etc. Defaults to a built-in schema.
        @param callback (optional) a function to call with each error or warning. Defaults to collecting errors in an array and returning them.
        &#34;&#34;&#34;
        return hxl.schema(schema, callback).validate(self)

    def recipe(self, recipe):
        &#34;&#34;&#34;Parse a recipe (JSON or a list of dicts) and create the appropriate filters.
        @param recipe: a list of dicts, a single dict, or a JSON literal string.
        @return: the new end filter.
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.from_recipe(self, recipe)

    #
    # Filters
    #

    def append(self, append_sources, add_columns=True, queries=[]):
        &#34;&#34;&#34;Append additional datasets.
        @param append_sources: a list of sources to append
        @param add_columns: if True (default), include any extra columns in the append sources
        @param queries: a list of row queries to select rows for inclusion from the append sources.
        @returns: a new HXL source for chaining
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.AppendFilter(self, append_sources, add_columns=add_columns, queries=queries)

    def append_external_list(self, source_list_url, add_columns=True, queries=[]):
        &#34;&#34;&#34;Append additional datasets from an external list
        @param source_list_url: URL of a HXL dataset containing a list of sources to append.
        @param add_columns: if True (default), include any extra columns in the append sources.
        @param queries: a list of row queries to select rows for inclusion from the append sources.
        @returns: a new HXL source for chaining
        &#34;&#34;&#34;
        import hxl.filters
        logger.debug(&#34;Loading append list from %s...&#34;, source_list_url)
        append_sources = hxl.filters.AppendFilter.parse_external_source_list(source_list_url)
        logger.debug(&#34;Done loading&#34;)
        return hxl.filters.AppendFilter(self, append_sources, add_columns=add_columns, queries=queries)

    def cache(self):
        &#34;&#34;&#34;Add a caching filter to the dataset.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.CacheFilter(self)

    def dedup(self, patterns=[], queries=[]):
        &#34;&#34;&#34;Deduplicate a dataset.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.DeduplicationFilter(self, patterns=patterns, queries=queries)

    def with_columns(self, includes):
        &#34;&#34;&#34;Select matching columns.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.ColumnFilter(self, include_tags=includes)

    def without_columns(self, excludes=None, skip_untagged=False):
        &#34;&#34;&#34;Select non-matching columns.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.ColumnFilter(self, exclude_tags=excludes, skip_untagged=skip_untagged)

    def with_rows(self, queries, mask=[]):
        &#34;&#34;&#34;Select matching rows.
        @param queries: a predicate or list of predicates for rows to include
        @param mask: a predicate or list of predicates for rows to test (default: [] to test all)
        @return: a filtered version of the source
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.RowFilter(self, queries=queries, reverse=False, mask=mask)

    def without_rows(self, queries, mask=[]):
        &#34;&#34;&#34;Select non-matching rows.
        @param queries: a predicate or list of predicates for rows to ignore
        @param mask: a predicate or list of predicates for rows to test (default: [] to test all)
        @return: a filtered version of the source
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.RowFilter(self, queries=queries, reverse=True, mask=mask)

    def sort(self, keys=None, reverse=False):
        &#34;&#34;&#34;Sort the dataset (caching).&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.SortFilter(self, tags=keys, reverse=reverse)

    def count(self, patterns=[], aggregators=None, queries=[]):
        &#34;&#34;&#34;Count values in the dataset (caching).&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.CountFilter(
            self, patterns=patterns, aggregators=aggregators, queries=queries
        )

    def row_counter(self, queries=[]):
        &#34;&#34;&#34;Count the number of rows while streaming.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.RowCountFilter(self, queries=queries)

    def replace_data(self, original, replacement, pattern=None, use_regex=False, queries=[]):
        &#34;&#34;&#34;Replace values in a HXL dataset.&#34;&#34;&#34;
        import hxl.filters
        replacement = hxl.filters.ReplaceDataFilter.Replacement(original, replacement, pattern, use_regex)
        return hxl.filters.ReplaceDataFilter(self, [replacement], queries=queries)

    def replace_data_map(self, map_source, queries=[]):
        &#34;&#34;&#34;Replace values in a HXL dataset.&#34;&#34;&#34;
        import hxl.filters
        replacements = hxl.filters.ReplaceDataFilter.Replacement.parse_map(hxl.data(map_source))
        return hxl.filters.ReplaceDataFilter(self, replacements, queries=queries)

    def add_columns(self, specs, before=False):
        &#34;&#34;&#34;Add fixed-value columns to a HXL dataset.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.AddColumnsFilter(self, specs=specs, before=before)

    def rename_columns(self, specs):
        &#34;&#34;&#34;Changes headers and tags on a column.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.RenameFilter(self, specs)

    def clean_data(
            self, whitespace=[], upper=[], lower=[], date=[], date_format=None,
            number=[], number_format=None, latlon=[], purge=False, queries=[]
    ):
        &#34;&#34;&#34;Clean data fields.&#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.CleanDataFilter(
            self,
            whitespace=whitespace,
            upper=upper,
            lower=lower,
            date=date, date_format=date_format,
            number=number, number_format=number_format,
            latlon=latlon,
            purge=purge,
            queries=queries
        )
    
    def merge_data(self, merge_source, keys, tags, replace=False, overwrite=False, queries=[]):
        &#34;&#34;&#34;Merges values from a second dataset.
        @param merge_source: the second HXL data source
        @param keys: a single tagspec or list of tagspecs for the shared keys
        @param tags: the tags to copy over from the second dataset
        @param replace: if True, replace existing columns when present
        @param overwrite: if True, overwrite individual values in existing columns when available
        @param queries: optional row queries to control the merge
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.MergeDataFilter(self, merge_source, keys, tags, replace, overwrite, queries=queries)

    def expand_lists(self, patterns=None, separator=&#34;|&#34;, correlate=False, queries=[]):
        &#34;&#34;&#34;Expand lists by repeating rows.
        By default, applies to every column with a +list attribute, and uses &#34;|&#34; as the separator.
        @param patterns: a single tag pattern or list of tag patterns for columns to expand
        @param separator: the list-item separator
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.ExpandListsFilter(self, patterns=patterns, separator=separator, correlate=correlate, queries=queries)

    def explode(self, header_attribute=&#39;header&#39;, value_attribute=&#39;value&#39;):
        &#34;&#34;&#34;Explodes a wide dataset into a long datasets.
        @param header_attribute: the attribute to add to the hashtag of the column with the former header (default &#39;header&#39;)
        @param value_attribute: the attribute to add to the hashtag of the column with the former value (default &#39;value&#39;)
        @return: filtered dataset.
        @see hxl.filters.ExplodeFilter
        &#34;&#34;&#34;
        
        import hxl.filters
        return hxl.filters.ExplodeFilter(self, header_attribute, value_attribute)

    def implode(self, label_pattern, value_pattern):
        &#34;&#34;&#34;Implodes a long dataset into a wide dataset
        @param label_pattern: the tag pattern to match the label column
        @param value_pattern: the tag pattern to match the 
        @return: filtered dataset.
        @see hxl.filters.ImplodeFilter
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.ImplodeFilter(self, label_pattern=label_pattern, value_pattern=value_pattern)

    def jsonpath(self, path, patterns=[], queries=[], use_json=True):
        &#34;&#34;&#34;Parse the value as a JSON expression and extract data from it.
        See http://goessner.net/articles/JsonPath/
        @param path: a JSONPath expression for extracting data
        @param patterns: a tag pattern or list of patterns for the columns to use (default to all)
        @param queries: a predicate or list of predicates for the rows to consider.
        @param use_json: if True, serialise multiple results as JSON lists.
        @returns: filtered dataset
        @see: hxl.filters.JSONPathFilter
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.JSONPathFilter(self, path, patterns=patterns, queries=queries, use_json=use_json)

    def fill_data(self, patterns=[], queries=[]):
        &#34;&#34;&#34;Fills empty cells in a column using the last non-empty value.
        @param patterns: a tag pattern or list of patterns for the columns to fill (default to all)
        @param queries: a predicate or list of predicates for rows to fill (leave any blank that don&#39;t match).
        @return filtered dataset
        @see hxl.filters.FillFilter
        &#34;&#34;&#34;
        import hxl.filters
        return hxl.filters.FillDataFilter(self, patterns=patterns, queries=queries)

    #
    # Generators
    #

    def gen_raw(self, show_headers=True, show_tags=True):
        &#34;&#34;&#34;Generate an array representation of a HXL dataset, one at a time.&#34;&#34;&#34;
        if show_headers:
            yield self.headers
        if show_tags:
            yield self.display_tags
        for row in self:
            yield row.values

    def gen_csv(self, show_headers=True, show_tags=True):
        &#34;&#34;&#34;Generate a CSV representation of a HXL dataset, one row at a time.&#34;&#34;&#34;
        class TextOut:
            &#34;&#34;&#34;Simple string output source to capture CSV&#34;&#34;&#34;
            def __init__(self):
                self.data = &#39;&#39;
            def write(self, s):
                self.data += s
            def get(self):
                data = self.data
                self.data = &#39;&#39;
                return data
        output = TextOut()
        writer = csv.writer(output)
        for raw in self.gen_raw(show_headers, show_tags):
            writer.writerow(raw)
            yield output.get()

    def gen_json(self, show_headers=True, show_tags=True, use_objects=False):
        &#34;&#34;&#34;Generate a JSON representation of a HXL dataset, one row at a time.&#34;&#34;&#34;
        is_first = True
        yield &#34;[\n&#34;
        if use_objects:
            for row in self:
                if is_first:
                    is_first = False
                    yield json.dumps(row.dictionary, sort_keys=True, indent=2)
                else:
                    yield &#34;,\n&#34; + json.dumps(row.dictionary, sort_keys=True, indent=2)
        else:
            for raw in self.gen_raw(show_headers, show_tags):
                if is_first:
                    is_first = False
                    yield json.dumps(raw)
                else:
                    yield &#34;,\n&#34; + json.dumps(raw)
        yield &#34;\n]\n&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractBaseFilter" href="filters.html#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.input.HXLReader" href="input.html#hxl.input.HXLReader">HXLReader</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.model.Dataset.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"><p>Get the column definitions for the dataset.
@returns: a list of Column objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def columns(self):
    &#34;&#34;&#34;Get the column definitions for the dataset.
    @returns: a list of Column objects.
    &#34;&#34;&#34;
    raise RuntimeException(&#34;child class must implement columns property method&#34;)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.columns_hash"><code class="name">var <span class="ident">columns_hash</span></code></dt>
<dd>
<div class="desc"><p>Generate a hash across all of the columns in the dataset.</p>
<p>This function helps detect whether two HXL documents are of
the same type, even if they contain different data (e.g. the
HXL API output for the same humanitarian dataset in two
different months or two different countries).</p>
<p>It takes into account text headers, hashtags, the order of
attributes, and the order of columns. Whitespace is
normalised, and null values are treated as empty strings. The
MD5 hash digest is generated from a UTF-8 encoded version of
each header.</p>
<p>@returns: a 32-character hex-formatted MD5 hash string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def columns_hash(self):
    &#34;&#34;&#34;Generate a hash across all of the columns in the dataset.

    This function helps detect whether two HXL documents are of
    the same type, even if they contain different data (e.g. the
    HXL API output for the same humanitarian dataset in two
    different months or two different countries).

    It takes into account text headers, hashtags, the order of
    attributes, and the order of columns. Whitespace is
    normalised, and null values are treated as empty strings. The
    MD5 hash digest is generated from a UTF-8 encoded version of
    each header.

    @returns: a 32-character hex-formatted MD5 hash string

    &#34;&#34;&#34;
    return hxl.Column.hash_list(self.columns)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.data_hash"><code class="name">var <span class="ident">data_hash</span></code></dt>
<dd>
<div class="desc"><p>Generate a hash for the entire dataset.</p>
<p>This function allows checking if two HXL datasets are
functionally identical. It takes into account text headers,
hashtags, the order of attributes, and the order of
columns. Whitespace is normalised, and null values are treated
as empty strings. The MD5 hash digest is generated from a
UTF-8 encoded version of each header and data cell.</p>
<p>@returns: a 32-character hex-formatted MD5 hash string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_hash(self):
    &#34;&#34;&#34;Generate a hash for the entire dataset.

    This function allows checking if two HXL datasets are
    functionally identical. It takes into account text headers,
    hashtags, the order of attributes, and the order of
    columns. Whitespace is normalised, and null values are treated
    as empty strings. The MD5 hash digest is generated from a
    UTF-8 encoded version of each header and data cell.

    @returns: a 32-character hex-formatted MD5 hash string
    &#34;&#34;&#34;
    md5 = hashlib.md5()
    # text header row
    for column in self.columns:
        md5.update(hxl.datatypes.normalise_space(column.header).encode(&#39;utf-8&#39;))
    # hashtag row
    for column in self.columns:
        md5.update(hxl.datatypes.normalise_space(column.display_tag).encode(&#39;utf-8&#39;))
    # data rows
    for row in self:
        for value in row:
            md5.update(hxl.datatypes.normalise_space(value).encode(&#39;utf-8&#39;))
    return md5.hexdigest()</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.display_tags"><code class="name">var <span class="ident">display_tags</span></code></dt>
<dd>
<div class="desc"><p>Return a list of display tags.
@returns: a list of strings containing the hashtag and attributes for each column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def display_tags(self):
    &#34;&#34;&#34;Return a list of display tags.
    @returns: a list of strings containing the hashtag and attributes for each column
    &#34;&#34;&#34;
    return [column.display_tag if column else &#39;&#39; for column in self.columns]</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.has_headers"><code class="name">var <span class="ident">has_headers</span></code></dt>
<dd>
<div class="desc"><p>Report whether any non-empty header strings exist.
@returns: C{True} if there is at least one column with a non-empty header string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_headers(self):
    &#34;&#34;&#34;Report whether any non-empty header strings exist.
    @returns: C{True} if there is at least one column with a non-empty header string
    &#34;&#34;&#34;
    for column in self.columns:
        if column.header:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.headers"><code class="name">var <span class="ident">headers</span></code></dt>
<dd>
<div class="desc"><p>Return a list of header strings (for a spreadsheet row).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def headers(self):
    &#34;&#34;&#34;Return a list of header strings (for a spreadsheet row).
    &#34;&#34;&#34;
    return [column.header if column else &#39;&#39; for column in self.columns]</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.is_cached"><code class="name">var <span class="ident">is_cached</span></code></dt>
<dd>
<div class="desc"><p>Test whether the source data is cached (replayable).
By default, this is False, but some subclasses may override.
@returns: C{True} if the input is cached (replayable); C{False} otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_cached(self):
    &#34;&#34;&#34;Test whether the source data is cached (replayable).
    By default, this is False, but some subclasses may override.
    @returns: C{True} if the input is cached (replayable); C{False} otherwise.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.tags"><code class="name">var <span class="ident">tags</span></code></dt>
<dd>
<div class="desc"><p>Get all hashtags (without attributes) as a list
@returns: a list of base hashtags for the dataset columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tags(self):
    &#34;&#34;&#34;Get all hashtags (without attributes) as a list
    @returns: a list of base hashtags for the dataset columns
    &#34;&#34;&#34;
    return [column.tag if column else &#39;&#39; for column in self.columns]</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>Get all values for the dataset at once, in an array of arrays.
This method can be highly inefficient for large datasets.
@returns: an array of arrays of scalar values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self):
    &#34;&#34;&#34;Get all values for the dataset at once, in an array of arrays.
    This method can be highly inefficient for large datasets.
    @returns: an array of arrays of scalar values
    &#34;&#34;&#34;
    return [row.values for row in self]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.model.Dataset.add_columns"><code class="name flex">
<span>def <span class="ident">add_columns</span></span>(<span>self, specs, before=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add fixed-value columns to a HXL dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_columns(self, specs, before=False):
    &#34;&#34;&#34;Add fixed-value columns to a HXL dataset.&#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.AddColumnsFilter(self, specs=specs, before=before)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, append_sources, add_columns=True, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Append additional datasets.
@param append_sources: a list of sources to append
@param add_columns: if True (default), include any extra columns in the append sources
@param queries: a list of row queries to select rows for inclusion from the append sources.
@returns: a new HXL source for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, append_sources, add_columns=True, queries=[]):
    &#34;&#34;&#34;Append additional datasets.
    @param append_sources: a list of sources to append
    @param add_columns: if True (default), include any extra columns in the append sources
    @param queries: a list of row queries to select rows for inclusion from the append sources.
    @returns: a new HXL source for chaining
    &#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.AppendFilter(self, append_sources, add_columns=add_columns, queries=queries)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.append_external_list"><code class="name flex">
<span>def <span class="ident">append_external_list</span></span>(<span>self, source_list_url, add_columns=True, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Append additional datasets from an external list
@param source_list_url: URL of a HXL dataset containing a list of sources to append.
@param add_columns: if True (default), include any extra columns in the append sources.
@param queries: a list of row queries to select rows for inclusion from the append sources.
@returns: a new HXL source for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_external_list(self, source_list_url, add_columns=True, queries=[]):
    &#34;&#34;&#34;Append additional datasets from an external list
    @param source_list_url: URL of a HXL dataset containing a list of sources to append.
    @param add_columns: if True (default), include any extra columns in the append sources.
    @param queries: a list of row queries to select rows for inclusion from the append sources.
    @returns: a new HXL source for chaining
    &#34;&#34;&#34;
    import hxl.filters
    logger.debug(&#34;Loading append list from %s...&#34;, source_list_url)
    append_sources = hxl.filters.AppendFilter.parse_external_source_list(source_list_url)
    logger.debug(&#34;Done loading&#34;)
    return hxl.filters.AppendFilter(self, append_sources, add_columns=add_columns, queries=queries)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.cache"><code class="name flex">
<span>def <span class="ident">cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a caching filter to the dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache(self):
    &#34;&#34;&#34;Add a caching filter to the dataset.&#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.CacheFilter(self)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.clean_data"><code class="name flex">
<span>def <span class="ident">clean_data</span></span>(<span>self, whitespace=[], upper=[], lower=[], date=[], date_format=None, number=[], number_format=None, latlon=[], purge=False, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Clean data fields.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_data(
        self, whitespace=[], upper=[], lower=[], date=[], date_format=None,
        number=[], number_format=None, latlon=[], purge=False, queries=[]
):
    &#34;&#34;&#34;Clean data fields.&#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.CleanDataFilter(
        self,
        whitespace=whitespace,
        upper=upper,
        lower=lower,
        date=date, date_format=date_format,
        number=number, number_format=number_format,
        latlon=latlon,
        purge=purge,
        queries=queries
    )</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self, patterns=[], aggregators=None, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Count values in the dataset (caching).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self, patterns=[], aggregators=None, queries=[]):
    &#34;&#34;&#34;Count values in the dataset (caching).&#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.CountFilter(
        self, patterns=patterns, aggregators=aggregators, queries=queries
    )</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.dedup"><code class="name flex">
<span>def <span class="ident">dedup</span></span>(<span>self, patterns=[], queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Deduplicate a dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dedup(self, patterns=[], queries=[]):
    &#34;&#34;&#34;Deduplicate a dataset.&#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.DeduplicationFilter(self, patterns=patterns, queries=queries)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.expand_lists"><code class="name flex">
<span>def <span class="ident">expand_lists</span></span>(<span>self, patterns=None, separator='|', correlate=False, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Expand lists by repeating rows.
By default, applies to every column with a +list attribute, and uses "|" as the separator.
@param patterns: a single tag pattern or list of tag patterns for columns to expand
@param separator: the list-item separator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_lists(self, patterns=None, separator=&#34;|&#34;, correlate=False, queries=[]):
    &#34;&#34;&#34;Expand lists by repeating rows.
    By default, applies to every column with a +list attribute, and uses &#34;|&#34; as the separator.
    @param patterns: a single tag pattern or list of tag patterns for columns to expand
    @param separator: the list-item separator
    &#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.ExpandListsFilter(self, patterns=patterns, separator=separator, correlate=correlate, queries=queries)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.explode"><code class="name flex">
<span>def <span class="ident">explode</span></span>(<span>self, header_attribute='header', value_attribute='value')</span>
</code></dt>
<dd>
<div class="desc"><p>Explodes a wide dataset into a long datasets.
@param header_attribute: the attribute to add to the hashtag of the column with the former header (default 'header')
@param value_attribute: the attribute to add to the hashtag of the column with the former value (default 'value')
@return: filtered dataset.
@see hxl.filters.ExplodeFilter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def explode(self, header_attribute=&#39;header&#39;, value_attribute=&#39;value&#39;):
    &#34;&#34;&#34;Explodes a wide dataset into a long datasets.
    @param header_attribute: the attribute to add to the hashtag of the column with the former header (default &#39;header&#39;)
    @param value_attribute: the attribute to add to the hashtag of the column with the former value (default &#39;value&#39;)
    @return: filtered dataset.
    @see hxl.filters.ExplodeFilter
    &#34;&#34;&#34;
    
    import hxl.filters
    return hxl.filters.ExplodeFilter(self, header_attribute, value_attribute)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.fill_data"><code class="name flex">
<span>def <span class="ident">fill_data</span></span>(<span>self, patterns=[], queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Fills empty cells in a column using the last non-empty value.
@param patterns: a tag pattern or list of patterns for the columns to fill (default to all)
@param queries: a predicate or list of predicates for rows to fill (leave any blank that don't match).
@return filtered dataset
@see hxl.filters.FillFilter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_data(self, patterns=[], queries=[]):
    &#34;&#34;&#34;Fills empty cells in a column using the last non-empty value.
    @param patterns: a tag pattern or list of patterns for the columns to fill (default to all)
    @param queries: a predicate or list of predicates for rows to fill (leave any blank that don&#39;t match).
    @return filtered dataset
    @see hxl.filters.FillFilter
    &#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.FillDataFilter(self, patterns=patterns, queries=queries)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.gen_csv"><code class="name flex">
<span>def <span class="ident">gen_csv</span></span>(<span>self, show_headers=True, show_tags=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a CSV representation of a HXL dataset, one row at a time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_csv(self, show_headers=True, show_tags=True):
    &#34;&#34;&#34;Generate a CSV representation of a HXL dataset, one row at a time.&#34;&#34;&#34;
    class TextOut:
        &#34;&#34;&#34;Simple string output source to capture CSV&#34;&#34;&#34;
        def __init__(self):
            self.data = &#39;&#39;
        def write(self, s):
            self.data += s
        def get(self):
            data = self.data
            self.data = &#39;&#39;
            return data
    output = TextOut()
    writer = csv.writer(output)
    for raw in self.gen_raw(show_headers, show_tags):
        writer.writerow(raw)
        yield output.get()</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.gen_json"><code class="name flex">
<span>def <span class="ident">gen_json</span></span>(<span>self, show_headers=True, show_tags=True, use_objects=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a JSON representation of a HXL dataset, one row at a time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_json(self, show_headers=True, show_tags=True, use_objects=False):
    &#34;&#34;&#34;Generate a JSON representation of a HXL dataset, one row at a time.&#34;&#34;&#34;
    is_first = True
    yield &#34;[\n&#34;
    if use_objects:
        for row in self:
            if is_first:
                is_first = False
                yield json.dumps(row.dictionary, sort_keys=True, indent=2)
            else:
                yield &#34;,\n&#34; + json.dumps(row.dictionary, sort_keys=True, indent=2)
    else:
        for raw in self.gen_raw(show_headers, show_tags):
            if is_first:
                is_first = False
                yield json.dumps(raw)
            else:
                yield &#34;,\n&#34; + json.dumps(raw)
    yield &#34;\n]\n&#34;</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.gen_raw"><code class="name flex">
<span>def <span class="ident">gen_raw</span></span>(<span>self, show_headers=True, show_tags=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an array representation of a HXL dataset, one at a time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_raw(self, show_headers=True, show_tags=True):
    &#34;&#34;&#34;Generate an array representation of a HXL dataset, one at a time.&#34;&#34;&#34;
    if show_headers:
        yield self.headers
    if show_tags:
        yield self.display_tags
    for row in self:
        yield row.values</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.get_column_indices"><code class="name flex">
<span>def <span class="ident">get_column_indices</span></span>(<span>self, tag_patterns, columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of indices that match the tag patterns provided
@param tag_patterns: a list of tag patterns or a string version of the list
@param columns: a list of columns
@returns: a (possibly-empty) list of 0-based indices</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column_indices(self, tag_patterns, columns):
    &#34;&#34;&#34;Get a list of indices that match the tag patterns provided
    @param tag_patterns: a list of tag patterns or a string version of the list
    @param columns: a list of columns
    @returns: a (possibly-empty) list of 0-based indices
    &#34;&#34;&#34;
    patterns = TagPattern.parse_list(tag_patterns)
    indices = []
    for i, column in enumerate(columns):
        for pattern in patterns:
            if pattern.match(column):
                indices.push(i)
    return indices</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.get_value_set"><code class="name flex">
<span>def <span class="ident">get_value_set</span></span>(<span>self, tag_pattern=None, normalise=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the set of all values in a dataset (optionally matching a tag pattern for a single column)
Warning: this method can be highly inefficient for large datasets.
@param tag_pattern: (optional) return values only for columns matching this tag pattern.
@param normalise: (optional) normalise the strings with hxl.datatypes.normalise (default: False)
@returns: a Python set of values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_set(self, tag_pattern=None, normalise=False):
    &#34;&#34;&#34;Return the set of all values in a dataset (optionally matching a tag pattern for a single column)
    Warning: this method can be highly inefficient for large datasets.
    @param tag_pattern: (optional) return values only for columns matching this tag pattern.
    @param normalise: (optional) normalise the strings with hxl.datatypes.normalise (default: False)
    @returns: a Python set of values
    &#34;&#34;&#34;
    value_set = set([])
    if tag_pattern:
        tag_pattern = TagPattern.parse(tag_pattern)
    for row in self:
        if tag_pattern:
            new_values = row.get_all(tag_pattern)
        else:
            new_values = row.values
        if normalise:
            new_values = [hxl.datatypes.normalise(s) for s in new_values]
        else:
            new_values = [hxl.datatypes.normalise_space(s) for s in new_values]
        value_set.update(new_values)
    return value_set</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.implode"><code class="name flex">
<span>def <span class="ident">implode</span></span>(<span>self, label_pattern, value_pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Implodes a long dataset into a wide dataset
@param label_pattern: the tag pattern to match the label column
@param value_pattern: the tag pattern to match the
@return: filtered dataset.
@see hxl.filters.ImplodeFilter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def implode(self, label_pattern, value_pattern):
    &#34;&#34;&#34;Implodes a long dataset into a wide dataset
    @param label_pattern: the tag pattern to match the label column
    @param value_pattern: the tag pattern to match the 
    @return: filtered dataset.
    @see hxl.filters.ImplodeFilter
    &#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.ImplodeFilter(self, label_pattern=label_pattern, value_pattern=value_pattern)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.jsonpath"><code class="name flex">
<span>def <span class="ident">jsonpath</span></span>(<span>self, path, patterns=[], queries=[], use_json=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the value as a JSON expression and extract data from it.
See <a href="http://goessner.net/articles/JsonPath/">http://goessner.net/articles/JsonPath/</a>
@param path: a JSONPath expression for extracting data
@param patterns: a tag pattern or list of patterns for the columns to use (default to all)
@param queries: a predicate or list of predicates for the rows to consider.
@param use_json: if True, serialise multiple results as JSON lists.
@returns: filtered dataset
@see: hxl.filters.JSONPathFilter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsonpath(self, path, patterns=[], queries=[], use_json=True):
    &#34;&#34;&#34;Parse the value as a JSON expression and extract data from it.
    See http://goessner.net/articles/JsonPath/
    @param path: a JSONPath expression for extracting data
    @param patterns: a tag pattern or list of patterns for the columns to use (default to all)
    @param queries: a predicate or list of predicates for the rows to consider.
    @param use_json: if True, serialise multiple results as JSON lists.
    @returns: filtered dataset
    @see: hxl.filters.JSONPathFilter
    &#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.JSONPathFilter(self, path, patterns=patterns, queries=queries, use_json=use_json)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.max"><code class="name flex">
<span>def <span class="ident">max</span></span>(<span>self, pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the maximum value for a tag pattern
Will iterate through the dataset, and use values from multiple matching columns.
@param pattern: the L{hxl.model.TagPattern} to match
@returns: the minimum value according to the '&lt;' operator, or None if no values found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max(self, pattern):
    &#34;&#34;&#34;Calculate the maximum value for a tag pattern
    Will iterate through the dataset, and use values from multiple matching columns.
    @param pattern: the L{hxl.model.TagPattern} to match
    @returns: the minimum value according to the &#39;&lt;&#39; operator, or None if no values found
    &#34;&#34;&#34;
    return self._get_minmax(pattern, operator.gt)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.merge_data"><code class="name flex">
<span>def <span class="ident">merge_data</span></span>(<span>self, merge_source, keys, tags, replace=False, overwrite=False, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Merges values from a second dataset.
@param merge_source: the second HXL data source
@param keys: a single tagspec or list of tagspecs for the shared keys
@param tags: the tags to copy over from the second dataset
@param replace: if True, replace existing columns when present
@param overwrite: if True, overwrite individual values in existing columns when available
@param queries: optional row queries to control the merge</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_data(self, merge_source, keys, tags, replace=False, overwrite=False, queries=[]):
    &#34;&#34;&#34;Merges values from a second dataset.
    @param merge_source: the second HXL data source
    @param keys: a single tagspec or list of tagspecs for the shared keys
    @param tags: the tags to copy over from the second dataset
    @param replace: if True, replace existing columns when present
    @param overwrite: if True, overwrite individual values in existing columns when available
    @param queries: optional row queries to control the merge
    &#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.MergeDataFilter(self, merge_source, keys, tags, replace, overwrite, queries=queries)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.min"><code class="name flex">
<span>def <span class="ident">min</span></span>(<span>self, pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the minimum value for a tag pattern
Will iterate through the dataset, and use values from multiple matching columns.
Uses numbers, dates, or strings for comparison, based on the first non-empty value found.
@param pattern: the L{hxl.model.TagPattern} to match
@returns: the minimum value according to the '&lt;' operator, or None if no values found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min(self, pattern):
    &#34;&#34;&#34;Calculate the minimum value for a tag pattern
    Will iterate through the dataset, and use values from multiple matching columns.
    Uses numbers, dates, or strings for comparison, based on the first non-empty value found.
    @param pattern: the L{hxl.model.TagPattern} to match
    @returns: the minimum value according to the &#39;&lt;&#39; operator, or None if no values found
    &#34;&#34;&#34;
    return self._get_minmax(pattern, operator.lt)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.recipe"><code class="name flex">
<span>def <span class="ident">recipe</span></span>(<span>self, recipe)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a recipe (JSON or a list of dicts) and create the appropriate filters.
@param recipe: a list of dicts, a single dict, or a JSON literal string.
@return: the new end filter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recipe(self, recipe):
    &#34;&#34;&#34;Parse a recipe (JSON or a list of dicts) and create the appropriate filters.
    @param recipe: a list of dicts, a single dict, or a JSON literal string.
    @return: the new end filter.
    &#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.from_recipe(self, recipe)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.rename_columns"><code class="name flex">
<span>def <span class="ident">rename_columns</span></span>(<span>self, specs)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes headers and tags on a column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_columns(self, specs):
    &#34;&#34;&#34;Changes headers and tags on a column.&#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.RenameFilter(self, specs)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.replace_data"><code class="name flex">
<span>def <span class="ident">replace_data</span></span>(<span>self, original, replacement, pattern=None, use_regex=False, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Replace values in a HXL dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_data(self, original, replacement, pattern=None, use_regex=False, queries=[]):
    &#34;&#34;&#34;Replace values in a HXL dataset.&#34;&#34;&#34;
    import hxl.filters
    replacement = hxl.filters.ReplaceDataFilter.Replacement(original, replacement, pattern, use_regex)
    return hxl.filters.ReplaceDataFilter(self, [replacement], queries=queries)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.replace_data_map"><code class="name flex">
<span>def <span class="ident">replace_data_map</span></span>(<span>self, map_source, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Replace values in a HXL dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_data_map(self, map_source, queries=[]):
    &#34;&#34;&#34;Replace values in a HXL dataset.&#34;&#34;&#34;
    import hxl.filters
    replacements = hxl.filters.ReplaceDataFilter.Replacement.parse_map(hxl.data(map_source))
    return hxl.filters.ReplaceDataFilter(self, replacements, queries=queries)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.row_counter"><code class="name flex">
<span>def <span class="ident">row_counter</span></span>(<span>self, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of rows while streaming.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def row_counter(self, queries=[]):
    &#34;&#34;&#34;Count the number of rows while streaming.&#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.RowCountFilter(self, queries=queries)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, keys=None, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort the dataset (caching).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, keys=None, reverse=False):
    &#34;&#34;&#34;Sort the dataset (caching).&#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.SortFilter(self, tags=keys, reverse=reverse)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self, schema=None, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the current dataset.
@param schema (optional) the pre-compiled schema, schema filename, URL, file object, etc. Defaults to a built-in schema.
@param callback (optional) a function to call with each error or warning. Defaults to collecting errors in an array and returning them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self, schema=None, callback=None):
    &#34;&#34;&#34;
    Validate the current dataset.
    @param schema (optional) the pre-compiled schema, schema filename, URL, file object, etc. Defaults to a built-in schema.
    @param callback (optional) a function to call with each error or warning. Defaults to collecting errors in an array and returning them.
    &#34;&#34;&#34;
    return hxl.schema(schema, callback).validate(self)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.with_columns"><code class="name flex">
<span>def <span class="ident">with_columns</span></span>(<span>self, includes)</span>
</code></dt>
<dd>
<div class="desc"><p>Select matching columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_columns(self, includes):
    &#34;&#34;&#34;Select matching columns.&#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.ColumnFilter(self, include_tags=includes)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.with_rows"><code class="name flex">
<span>def <span class="ident">with_rows</span></span>(<span>self, queries, mask=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Select matching rows.
@param queries: a predicate or list of predicates for rows to include
@param mask: a predicate or list of predicates for rows to test (default: [] to test all)
@return: a filtered version of the source</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_rows(self, queries, mask=[]):
    &#34;&#34;&#34;Select matching rows.
    @param queries: a predicate or list of predicates for rows to include
    @param mask: a predicate or list of predicates for rows to test (default: [] to test all)
    @return: a filtered version of the source
    &#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.RowFilter(self, queries=queries, reverse=False, mask=mask)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.without_columns"><code class="name flex">
<span>def <span class="ident">without_columns</span></span>(<span>self, excludes=None, skip_untagged=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Select non-matching columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def without_columns(self, excludes=None, skip_untagged=False):
    &#34;&#34;&#34;Select non-matching columns.&#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.ColumnFilter(self, exclude_tags=excludes, skip_untagged=skip_untagged)</code></pre>
</details>
</dd>
<dt id="hxl.model.Dataset.without_rows"><code class="name flex">
<span>def <span class="ident">without_rows</span></span>(<span>self, queries, mask=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Select non-matching rows.
@param queries: a predicate or list of predicates for rows to ignore
@param mask: a predicate or list of predicates for rows to test (default: [] to test all)
@return: a filtered version of the source</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def without_rows(self, queries, mask=[]):
    &#34;&#34;&#34;Select non-matching rows.
    @param queries: a predicate or list of predicates for rows to ignore
    @param mask: a predicate or list of predicates for rows to test (default: [] to test all)
    @return: a filtered version of the source
    &#34;&#34;&#34;
    import hxl.filters
    return hxl.filters.RowFilter(self, queries=queries, reverse=True, mask=mask)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hxl.model.Row"><code class="flex name class">
<span>class <span class="ident">Row</span></span>
<span>(</span><span>columns, values=[], row_number=None, source_row_number=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An iterable row of values in a HXL dataset.</p>
<p>If a value is part of a merged area, and not in the top left position, it will be a MergedCell object.</p>
<p>Set up a new row.
@param columns: The column definitions (array of Column objects).
@param values: (optional) The string values for the row (default: [])
@param row_number: (optional) The zero-based logical row number in the input dataset, if available (default: None)
@param source_row_number: (optional) The zero-based source row number in the input dataset, if available (default: None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Row(object):
    &#34;&#34;&#34; An iterable row of values in a HXL dataset.

    If a value is part of a merged area, and not in the top left position, it will be a MergedCell object.
    &#34;&#34;&#34;

    # Predefine the slots for efficiency (may reconsider later)
    __slots__ = [&#39;columns&#39;, &#39;values&#39;, &#39;row_number&#39;, &#39;source_row_number&#39;]

    def __init__(self, columns, values=[], row_number=None, source_row_number=None):
        &#34;&#34;&#34;
        Set up a new row.
        @param columns: The column definitions (array of Column objects).
        @param values: (optional) The string values for the row (default: [])
        @param row_number: (optional) The zero-based logical row number in the input dataset, if available (default: None)
        @param source_row_number: (optional) The zero-based source row number in the input dataset, if available (default: None)
        &#34;&#34;&#34;
        self.columns = columns
        self.values = copy.copy(values)
        self.row_number = row_number
        self.source_row_number = source_row_number

    def append(self, value):
        &#34;&#34;&#34;
        Append a value to the row.
        @param value The new value to append.
        @return The new value
        &#34;&#34;&#34;
        self.values.append(value)
        return value

    def get(self, tag, index=None, default=None, parsed=False):
        &#34;&#34;&#34;
        Get a single value for a tag in a row.
        If no index is provided (&#34;None&#34;), return the first non-empty value.
        @param tag: A TagPattern or a string value for a tag.
        @param index: The zero-based index if there are multiple values for the tag (default: None)
        @param default: The default value if not found (default: None). Never parsed, even if parsed=True
        @param parsed: If true, use attributes as hints to try to parse the value (e.g. number, list, date)
        @return The value found, or the default value provided. If parsed=True, the return value will be a list (default: False)
        &#34;&#34;&#34;

        # FIXME - move externally, use for get_all as well, and support numbers and dates
        def parse(column, value):
            if parsed:
                if column.has_attribute(&#39;list&#39;):
                    return re.split(r&#39;\s*,\s*&#39;, value)
                else:
                    return [value]
            return value

        if type(tag) is TagPattern:
            pattern = tag
        else:
            pattern = TagPattern.parse(tag)

        for i, column in enumerate(self.columns):
            if i &gt;= len(self.values):
                break
            if pattern.match(column):
                if index is None:
                    # None (the default) is a special case: it means look
                    # for the first truthy value
                    if self.values[i]:
                        return parse(column, self.values[i])
                else:
                    # Otherwise, look for a specific index
                    if index == 0:
                        return parse(column, self.values[i])
                    else:
                        index = index - 1
        return default

    def get_all(self, tag, default=None):
        &#34;&#34;&#34;
        Get all values for a specific tag in a row
        @param tag A TagPattern or a string value for a tag.
        @return An array of values for the HXL hashtag.
        &#34;&#34;&#34;

        if type(tag) is TagPattern:
            pattern = tag
        else:
            pattern = TagPattern.parse(tag)

        result = []
        for i, column in enumerate(self.columns):
            if i &gt;= len(self.values):
                break
            if pattern.match(column):
                value = self.values[i]
                if default is not None and not value:
                    value = default
                result.append(value)
        return result

    def key(self, patterns=None, indices=None):
        &#34;&#34;&#34;Generate a unique key tuple for the row, based on a list of tag patterns
        @param patterns: a list of L{TagPattern} objects, or a parseable string
        @returns: the key as a tuple (might be empty)
        &#34;&#34;&#34;

        key = []

        # if the user doesn&#39;t provide indices, get indices from the pattern
        if not indices and patterns:
            indices = get_column_indices(patterns, self.columns)

        if indices:
            # if we have indices, use them to build the key
            for i in indices:
                if i &lt; len(self.values):
                    key.append(hxl.datatypes.normalise(self.values[i], self.columns[i]))
        else:
            # if there are still no indices, use the whole row for the key
            for i, value in enumerate(self.values):
                key.append(hxl.datatypes.normalise(value, self.columns[i]))

        return tuple(key) # make it into a tuple so that it&#39;s hashable


    @property
    def dictionary(self):
        &#34;&#34;&#34;Return the row as a Python dict.
        The keys will be HXL hashtags and attributes, normalised per HXL 1.1.
        If two or more columns have the same hashtags and attributes, only the first will be included.
        @return: The row as a Python dictionary.
        &#34;&#34;&#34;
        data = {}
        for i, col in enumerate(self.columns):
            key = col.get_display_tag(sort_attributes=True)
            if key and (not key in data) and (i &lt; len(self.values)):
                data[key] = self.values[i]
        return data

    def __getitem__(self, index):
        &#34;&#34;&#34;
        Array-access method to make this class iterable.
        @param index The zero-based index of a value to look up.
        @return The value if it exists.
        @exception IndexError if the index is out of range.
        &#34;&#34;&#34;
        return self.values[index]

    def __str__(self):
        &#34;&#34;&#34;
        Create a string representation of a row for debugging.
        &#34;&#34;&#34;
        s = &#39;&lt;Row&#39;;
        for column_number, value in enumerate(self.values):
            s += &#34;\n  &#34; + str(self.columns[column_number]) + &#34;=&#34; + str(value)
        s += &#34;\n&gt;&#34;
        return s</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.model.Row.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="hxl.model.Row.dictionary"><code class="name">var <span class="ident">dictionary</span></code></dt>
<dd>
<div class="desc"><p>Return the row as a Python dict.
The keys will be HXL hashtags and attributes, normalised per HXL 1.1.
If two or more columns have the same hashtags and attributes, only the first will be included.
@return: The row as a Python dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dictionary(self):
    &#34;&#34;&#34;Return the row as a Python dict.
    The keys will be HXL hashtags and attributes, normalised per HXL 1.1.
    If two or more columns have the same hashtags and attributes, only the first will be included.
    @return: The row as a Python dictionary.
    &#34;&#34;&#34;
    data = {}
    for i, col in enumerate(self.columns):
        key = col.get_display_tag(sort_attributes=True)
        if key and (not key in data) and (i &lt; len(self.values)):
            data[key] = self.values[i]
    return data</code></pre>
</details>
</dd>
<dt id="hxl.model.Row.row_number"><code class="name">var <span class="ident">row_number</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="hxl.model.Row.source_row_number"><code class="name">var <span class="ident">source_row_number</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="hxl.model.Row.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.model.Row.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a value to the row.
@param value The new value to append.
@return The new value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, value):
    &#34;&#34;&#34;
    Append a value to the row.
    @param value The new value to append.
    @return The new value
    &#34;&#34;&#34;
    self.values.append(value)
    return value</code></pre>
</details>
</dd>
<dt id="hxl.model.Row.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, tag, index=None, default=None, parsed=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a single value for a tag in a row.
If no index is provided ("None"), return the first non-empty value.
@param tag: A TagPattern or a string value for a tag.
@param index: The zero-based index if there are multiple values for the tag (default: None)
@param default: The default value if not found (default: None). Never parsed, even if parsed=True
@param parsed: If true, use attributes as hints to try to parse the value (e.g. number, list, date)
@return The value found, or the default value provided. If parsed=True, the return value will be a list (default: False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, tag, index=None, default=None, parsed=False):
    &#34;&#34;&#34;
    Get a single value for a tag in a row.
    If no index is provided (&#34;None&#34;), return the first non-empty value.
    @param tag: A TagPattern or a string value for a tag.
    @param index: The zero-based index if there are multiple values for the tag (default: None)
    @param default: The default value if not found (default: None). Never parsed, even if parsed=True
    @param parsed: If true, use attributes as hints to try to parse the value (e.g. number, list, date)
    @return The value found, or the default value provided. If parsed=True, the return value will be a list (default: False)
    &#34;&#34;&#34;

    # FIXME - move externally, use for get_all as well, and support numbers and dates
    def parse(column, value):
        if parsed:
            if column.has_attribute(&#39;list&#39;):
                return re.split(r&#39;\s*,\s*&#39;, value)
            else:
                return [value]
        return value

    if type(tag) is TagPattern:
        pattern = tag
    else:
        pattern = TagPattern.parse(tag)

    for i, column in enumerate(self.columns):
        if i &gt;= len(self.values):
            break
        if pattern.match(column):
            if index is None:
                # None (the default) is a special case: it means look
                # for the first truthy value
                if self.values[i]:
                    return parse(column, self.values[i])
            else:
                # Otherwise, look for a specific index
                if index == 0:
                    return parse(column, self.values[i])
                else:
                    index = index - 1
    return default</code></pre>
</details>
</dd>
<dt id="hxl.model.Row.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>self, tag, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all values for a specific tag in a row
@param tag A TagPattern or a string value for a tag.
@return An array of values for the HXL hashtag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(self, tag, default=None):
    &#34;&#34;&#34;
    Get all values for a specific tag in a row
    @param tag A TagPattern or a string value for a tag.
    @return An array of values for the HXL hashtag.
    &#34;&#34;&#34;

    if type(tag) is TagPattern:
        pattern = tag
    else:
        pattern = TagPattern.parse(tag)

    result = []
    for i, column in enumerate(self.columns):
        if i &gt;= len(self.values):
            break
        if pattern.match(column):
            value = self.values[i]
            if default is not None and not value:
                value = default
            result.append(value)
    return result</code></pre>
</details>
</dd>
<dt id="hxl.model.Row.key"><code class="name flex">
<span>def <span class="ident">key</span></span>(<span>self, patterns=None, indices=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a unique key tuple for the row, based on a list of tag patterns
@param patterns: a list of L{TagPattern} objects, or a parseable string
@returns: the key as a tuple (might be empty)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key(self, patterns=None, indices=None):
    &#34;&#34;&#34;Generate a unique key tuple for the row, based on a list of tag patterns
    @param patterns: a list of L{TagPattern} objects, or a parseable string
    @returns: the key as a tuple (might be empty)
    &#34;&#34;&#34;

    key = []

    # if the user doesn&#39;t provide indices, get indices from the pattern
    if not indices and patterns:
        indices = get_column_indices(patterns, self.columns)

    if indices:
        # if we have indices, use them to build the key
        for i in indices:
            if i &lt; len(self.values):
                key.append(hxl.datatypes.normalise(self.values[i], self.columns[i]))
    else:
        # if there are still no indices, use the whole row for the key
        for i, value in enumerate(self.values):
            key.append(hxl.datatypes.normalise(value, self.columns[i]))

    return tuple(key) # make it into a tuple so that it&#39;s hashable</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hxl.model.RowQuery"><code class="flex name class">
<span>class <span class="ident">RowQuery</span></span>
<span>(</span><span>pattern, op, value, is_aggregate=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Query to execute against a row of HXL data.</p>
<p>Constructor
@param pattern: the L{TagPattern} to match in the row
@param op: the operator function to use for comparison
@param value: the value to compare against
@param is_aggregate: if True, the value is a special placeholder like "min" or "max" that needs to be calculated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RowQuery(object):
    &#34;&#34;&#34;Query to execute against a row of HXL data.&#34;&#34;&#34;

    def __init__(self, pattern, op, value, is_aggregate=False):
        &#34;&#34;&#34;Constructor
        @param pattern: the L{TagPattern} to match in the row
        @param op: the operator function to use for comparison
        @param value: the value to compare against
        @param is_aggregate: if True, the value is a special placeholder like &#34;min&#34; or &#34;max&#34; that needs to be calculated
        &#34;&#34;&#34;
        self.pattern = TagPattern.parse(pattern)
        self.op = op
        self.value = value

        # if the value is a formula, extract it
        self.formula = None
        result = re.match(r&#39;^{{(.+)}}$&#39;, hxl.datatypes.normalise_space(value))
        if result:
            self.formula = result.group(1)

        self.is_aggregate=is_aggregate
        self.needs_aggregate = False
        &#34;&#34;&#34;Need to calculate an aggregate value&#34;&#34;&#34;
        
        if is_aggregate:
            self.needs_aggregate = True

        # calculate later
        self.date_value = None
        self.number_value = None
        self._saved_indices = None

    def calc_aggregate(self, dataset):
        &#34;&#34;&#34;Calculate the aggregate value that we need for the row query
        Substitute the special values &#34;min&#34; and &#34;max&#34; with aggregates.
        @param dataset: the HXL dataset to use (must be cached)
        &#34;&#34;&#34;
        if not self.needs_aggregate:
            logger.warning(&#34;no aggregate calculation needed&#34;)
            return # no need to calculate
        if not dataset.is_cached:
            raise HXLException(&#34;need a cached dataset for calculating an aggregate value&#34;)
        if self.value == &#39;min&#39;:
            self.value = dataset.min(self.pattern)
            self.op = operator.eq
        elif self.value == &#39;max&#39;:
            self.value = dataset.max(self.pattern)
            self.op = operator.eq
        elif self.value == &#39;not min&#39;:
            self.value = dataset.min(self.pattern)
            self.op = operator.ne
        elif self.value == &#39;not max&#39;:
            self.value = dataset.max(self.pattern)
            self.op = operator.ne
        else:
            raise HXLException(&#34;Unrecognised aggregate: {}&#34;.format(value))
        self.needs_aggregate = False
                               
    def match_row(self, row):
        &#34;&#34;&#34;Check if a key-value pair appears in a HXL row&#34;&#34;&#34;

        # fail if we need an aggregate and haven&#39;t calculated it
        if self.needs_aggregate and not self.aggregate_is_calculated:
            raise HXLException(&#34;must call calc_aggregate before matching an &#39;is min&#39; or &#39;is max&#39; condition&#34;)

        # initialise is this is the first time matching for the row query
        if self._saved_indices is None or self.formula:

            # if it&#39;s a row formula, evaluate first
            if self.formula:
                value = hxl.formulas.eval.eval(row, self.formula)
            else:
                value = self.value

            if self.pattern.tag == &#39;#date&#39;:
                try:
                    self.date_value = hxl.datatypes.normalise_date(value)
                except ValueError:
                    self.date_value = None

            try:
                self.number_value = hxl.datatypes.normalise_number(value)
            except ValueError:
                self.number_value = None

            self.string_value = hxl.datatypes.normalise_string(value)

        # try all the matching column values
        indices = self._get_saved_indices(row.columns)
        for i in indices:
            if i &lt; len(row.values) and self.match_value(row.values[i], self.op):
                return True
        return False


    def match_value(self, value, op):
        &#34;&#34;&#34;Try matching as dates, then as numbers, then as simple strings&#34;&#34;&#34;
        if self.date_value is not None:
            try:
                return op(hxl.datatypes.normalise_date(value), self.date_value)
            except ValueError:
                pass

        if self.number_value is not None:
            try:
                return op(hxl.datatypes.normalise_number(value), self.number_value)
            except:
                pass

        return self.op(hxl.datatypes.normalise_string(value), self.string_value)

    def _get_saved_indices(self, columns):
        &#34;&#34;&#34;Cache the column tests, so that we run them only once.&#34;&#34;&#34;
        # FIXME - assuming that the columns never change
        self._saved_indices = []
        for i in range(len(columns)):
            if self.pattern.match(columns[i]):
                self._saved_indices.append(i)
        return self._saved_indices

    @staticmethod
    def parse(query):
        &#34;&#34;&#34;Parse a filter expression&#34;&#34;&#34;
        if isinstance(query, RowQuery):
            # already parsed
            return query
        parts = re.split(r&#39;([&lt;&gt;]=?|!?=|!?~|\bis\b)&#39;, hxl.datatypes.normalise_string(query), maxsplit=1)
        pattern = TagPattern.parse(parts[0])
        op_name = hxl.datatypes.normalise_string(parts[1])
        op = RowQuery.OPERATOR_MAP.get(op_name)
        value = hxl.datatypes.normalise_string(parts[2])
        is_aggregate = False
        # special handling for aggregates (FIXME)
        if op_name == &#39;is&#39; and value in (&#39;min&#39;, &#39;max&#39;, &#39;not min&#39;, &#39;not max&#39;):
            is_aggregate = True
        return RowQuery(pattern, op, value, is_aggregate)

    @staticmethod
    def parse_list(queries):
        &#34;&#34;&#34;Parse a single query spec or a list of specs.&#34;&#34;&#34;
        if queries:
            if not hasattr(queries, &#39;__len__&#39;) or isinstance(queries, six.string_types):
                # make a list if needed
                queries = [queries]
            return [hxl.model.RowQuery.parse(query) for query in queries]
        else:
            return []

    @staticmethod
    def match_list(row, queries=None, reverse=False):
        &#34;&#34;&#34;See if any query in a list matches a row.&#34;&#34;&#34;
        if not queries:
            # no queries = pass
            return True
        else:
            # otherwise, must match at least one
            for query in queries:
                if query.match_row(row):
                    return not reverse
            return reverse

    @staticmethod
    def operator_re(s, pattern):
        &#34;&#34;&#34;Regular-expression comparison operator.&#34;&#34;&#34;
        return re.search(pattern, s)

    @staticmethod
    def operator_nre(s, pattern):
        &#34;&#34;&#34;Regular-expression negative comparison operator.&#34;&#34;&#34;
        return not re.search(pattern, s)

    @staticmethod
    def operator_is(s, condition):
        &#34;&#34;&#34;Advanced tests
        Note: this won&#39;t be called for aggregate values like &#34;is min&#34; or &#34;is not max&#34;;
        for these, the aggregate will already be calculated, and a simple comparison
        operator substituted by L{calc_aggregate}.
        &#34;&#34;&#34;
        if condition == &#39;empty&#39;:
            return hxl.datatypes.is_empty(s)
        elif condition == &#39;not empty&#39;:
            return not hxl.datatypes.is_empty(s)
        elif condition == &#39;number&#39;:
            return hxl.datatypes.is_number(s)
        elif condition == &#39;not number&#39;:
            return not hxl.datatypes.is_number(s)
        elif condition == &#39;date&#39;:
            return (hxl.datatypes.is_date(s))
        elif condition == &#39;not date&#39;:
            return (hxl.datatypes.is_date(s) is False)
        else:
            raise hxl.HXLException(&#39;Unknown is condition: {}&#39;.format(condition))
    

    # Constant map of comparison operators
    OPERATOR_MAP = {
        &#39;=&#39;: operator.eq,
        &#39;!=&#39;: operator.ne,
        &#39;&lt;&#39;: operator.lt,
        &#39;&lt;=&#39;: operator.le,
        &#39;&gt;&#39;: operator.gt,
        &#39;&gt;=&#39;: operator.ge,
    }</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="hxl.model.RowQuery.OPERATOR_MAP"><code class="name">var <span class="ident">OPERATOR_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="hxl.model.RowQuery.match_list"><code class="name flex">
<span>def <span class="ident">match_list</span></span>(<span>row, queries=None, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>See if any query in a list matches a row.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def match_list(row, queries=None, reverse=False):
    &#34;&#34;&#34;See if any query in a list matches a row.&#34;&#34;&#34;
    if not queries:
        # no queries = pass
        return True
    else:
        # otherwise, must match at least one
        for query in queries:
            if query.match_row(row):
                return not reverse
        return reverse</code></pre>
</details>
</dd>
<dt id="hxl.model.RowQuery.operator_is"><code class="name flex">
<span>def <span class="ident">operator_is</span></span>(<span>s, condition)</span>
</code></dt>
<dd>
<div class="desc"><p>Advanced tests
Note: this won't be called for aggregate values like "is min" or "is not max";
for these, the aggregate will already be calculated, and a simple comparison
operator substituted by L{calc_aggregate}.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def operator_is(s, condition):
    &#34;&#34;&#34;Advanced tests
    Note: this won&#39;t be called for aggregate values like &#34;is min&#34; or &#34;is not max&#34;;
    for these, the aggregate will already be calculated, and a simple comparison
    operator substituted by L{calc_aggregate}.
    &#34;&#34;&#34;
    if condition == &#39;empty&#39;:
        return hxl.datatypes.is_empty(s)
    elif condition == &#39;not empty&#39;:
        return not hxl.datatypes.is_empty(s)
    elif condition == &#39;number&#39;:
        return hxl.datatypes.is_number(s)
    elif condition == &#39;not number&#39;:
        return not hxl.datatypes.is_number(s)
    elif condition == &#39;date&#39;:
        return (hxl.datatypes.is_date(s))
    elif condition == &#39;not date&#39;:
        return (hxl.datatypes.is_date(s) is False)
    else:
        raise hxl.HXLException(&#39;Unknown is condition: {}&#39;.format(condition))</code></pre>
</details>
</dd>
<dt id="hxl.model.RowQuery.operator_nre"><code class="name flex">
<span>def <span class="ident">operator_nre</span></span>(<span>s, pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Regular-expression negative comparison operator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def operator_nre(s, pattern):
    &#34;&#34;&#34;Regular-expression negative comparison operator.&#34;&#34;&#34;
    return not re.search(pattern, s)</code></pre>
</details>
</dd>
<dt id="hxl.model.RowQuery.operator_re"><code class="name flex">
<span>def <span class="ident">operator_re</span></span>(<span>s, pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Regular-expression comparison operator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def operator_re(s, pattern):
    &#34;&#34;&#34;Regular-expression comparison operator.&#34;&#34;&#34;
    return re.search(pattern, s)</code></pre>
</details>
</dd>
<dt id="hxl.model.RowQuery.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a filter expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(query):
    &#34;&#34;&#34;Parse a filter expression&#34;&#34;&#34;
    if isinstance(query, RowQuery):
        # already parsed
        return query
    parts = re.split(r&#39;([&lt;&gt;]=?|!?=|!?~|\bis\b)&#39;, hxl.datatypes.normalise_string(query), maxsplit=1)
    pattern = TagPattern.parse(parts[0])
    op_name = hxl.datatypes.normalise_string(parts[1])
    op = RowQuery.OPERATOR_MAP.get(op_name)
    value = hxl.datatypes.normalise_string(parts[2])
    is_aggregate = False
    # special handling for aggregates (FIXME)
    if op_name == &#39;is&#39; and value in (&#39;min&#39;, &#39;max&#39;, &#39;not min&#39;, &#39;not max&#39;):
        is_aggregate = True
    return RowQuery(pattern, op, value, is_aggregate)</code></pre>
</details>
</dd>
<dt id="hxl.model.RowQuery.parse_list"><code class="name flex">
<span>def <span class="ident">parse_list</span></span>(<span>queries)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a single query spec or a list of specs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_list(queries):
    &#34;&#34;&#34;Parse a single query spec or a list of specs.&#34;&#34;&#34;
    if queries:
        if not hasattr(queries, &#39;__len__&#39;) or isinstance(queries, six.string_types):
            # make a list if needed
            queries = [queries]
        return [hxl.model.RowQuery.parse(query) for query in queries]
    else:
        return []</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.model.RowQuery.needs_aggregate"><code class="name">var <span class="ident">needs_aggregate</span></code></dt>
<dd>
<div class="desc"><p>Need to calculate an aggregate value</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.model.RowQuery.calc_aggregate"><code class="name flex">
<span>def <span class="ident">calc_aggregate</span></span>(<span>self, dataset)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the aggregate value that we need for the row query
Substitute the special values "min" and "max" with aggregates.
@param dataset: the HXL dataset to use (must be cached)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_aggregate(self, dataset):
    &#34;&#34;&#34;Calculate the aggregate value that we need for the row query
    Substitute the special values &#34;min&#34; and &#34;max&#34; with aggregates.
    @param dataset: the HXL dataset to use (must be cached)
    &#34;&#34;&#34;
    if not self.needs_aggregate:
        logger.warning(&#34;no aggregate calculation needed&#34;)
        return # no need to calculate
    if not dataset.is_cached:
        raise HXLException(&#34;need a cached dataset for calculating an aggregate value&#34;)
    if self.value == &#39;min&#39;:
        self.value = dataset.min(self.pattern)
        self.op = operator.eq
    elif self.value == &#39;max&#39;:
        self.value = dataset.max(self.pattern)
        self.op = operator.eq
    elif self.value == &#39;not min&#39;:
        self.value = dataset.min(self.pattern)
        self.op = operator.ne
    elif self.value == &#39;not max&#39;:
        self.value = dataset.max(self.pattern)
        self.op = operator.ne
    else:
        raise HXLException(&#34;Unrecognised aggregate: {}&#34;.format(value))
    self.needs_aggregate = False</code></pre>
</details>
</dd>
<dt id="hxl.model.RowQuery.match_row"><code class="name flex">
<span>def <span class="ident">match_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a key-value pair appears in a HXL row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_row(self, row):
    &#34;&#34;&#34;Check if a key-value pair appears in a HXL row&#34;&#34;&#34;

    # fail if we need an aggregate and haven&#39;t calculated it
    if self.needs_aggregate and not self.aggregate_is_calculated:
        raise HXLException(&#34;must call calc_aggregate before matching an &#39;is min&#39; or &#39;is max&#39; condition&#34;)

    # initialise is this is the first time matching for the row query
    if self._saved_indices is None or self.formula:

        # if it&#39;s a row formula, evaluate first
        if self.formula:
            value = hxl.formulas.eval.eval(row, self.formula)
        else:
            value = self.value

        if self.pattern.tag == &#39;#date&#39;:
            try:
                self.date_value = hxl.datatypes.normalise_date(value)
            except ValueError:
                self.date_value = None

        try:
            self.number_value = hxl.datatypes.normalise_number(value)
        except ValueError:
            self.number_value = None

        self.string_value = hxl.datatypes.normalise_string(value)

    # try all the matching column values
    indices = self._get_saved_indices(row.columns)
    for i in indices:
        if i &lt; len(row.values) and self.match_value(row.values[i], self.op):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="hxl.model.RowQuery.match_value"><code class="name flex">
<span>def <span class="ident">match_value</span></span>(<span>self, value, op)</span>
</code></dt>
<dd>
<div class="desc"><p>Try matching as dates, then as numbers, then as simple strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_value(self, value, op):
    &#34;&#34;&#34;Try matching as dates, then as numbers, then as simple strings&#34;&#34;&#34;
    if self.date_value is not None:
        try:
            return op(hxl.datatypes.normalise_date(value), self.date_value)
        except ValueError:
            pass

    if self.number_value is not None:
        try:
            return op(hxl.datatypes.normalise_number(value), self.number_value)
        except:
            pass

    return self.op(hxl.datatypes.normalise_string(value), self.string_value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hxl.model.TagPattern"><code class="flex name class">
<span>class <span class="ident">TagPattern</span></span>
<span>(</span><span>tag, include_attributes=[], exclude_attributes=[], is_absolute=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Pattern for matching a HXL hashtag and attributes</p>
<ul>
<li>the pattern "#*" matches any hashtag/attribute combination</li>
<li>the pattern "#*+foo" matches any hashtag with the foo attribute</li>
<li>the pattern "#tag" matches #tag with any attributes</li>
<li>the pattern "#tag+foo" matches #tag with foo among its attributes</li>
<li>the pattern "#tag-foo" matches #tag with foo <em>not</em> among its attributes</li>
<li>the pattern "#tag+foo-bar" matches #tag with foo but not bar</li>
<li>the pattern "#tag+foo+bar!" matches #tag with exactly the attributes foo and bar, but <em>no others</em></li>
</ul>
<p>The normal way to create a tag pattern is using the
<a href="#hxl.model.TagPattern.parse">parse()</a> method rather than the
constructor:</p>
<pre><code>pattern = hxl.model.TagPattern.parse("#affected+f-children")
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tag</code></strong></dt>
<dd>the basic hashtag (without attributes)</dd>
<dt><strong><code>include_attributes</code></strong></dt>
<dd>a list of attributes that must be present</dd>
<dt><strong><code>exclude_attributes</code></strong></dt>
<dd>a list of attributes that must not be present</dd>
<dt><strong><code>is_absolute</code></strong></dt>
<dd>if True, no attributes are allowed except those in <em>include_attributes</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TagPattern(object):
    &#34;&#34;&#34;Pattern for matching a HXL hashtag and attributes

    - the pattern &#34;#*&#34; matches any hashtag/attribute combination
    - the pattern &#34;#*+foo&#34; matches any hashtag with the foo attribute
    - the pattern &#34;#tag&#34; matches #tag with any attributes
    - the pattern &#34;#tag+foo&#34; matches #tag with foo among its attributes
    - the pattern &#34;#tag-foo&#34; matches #tag with foo *not* among its attributes
    - the pattern &#34;#tag+foo-bar&#34; matches #tag with foo but not bar
    - the pattern &#34;#tag+foo+bar!&#34; matches #tag with exactly the attributes foo and bar, but *no others*

    The normal way to create a tag pattern is using the
    [parse()](#hxl.model.TagPattern.parse) method rather than the
    constructor:

        pattern = hxl.model.TagPattern.parse(&#34;#affected+f-children&#34;)

    Args:
        tag: the basic hashtag (without attributes)
        include_attributes: a list of attributes that must be present
        exclude_attributes: a list of attributes that must not be present
        is_absolute: if True, no attributes are allowed except those in _include_attributes_

    &#34;&#34;&#34;

    
    PATTERN = r&#39;^\s*#?({token}|\*)((?:\s*[+-]{token})*)\s*(!)?\s*$&#39;.format(token=hxl.datatypes.TOKEN_PATTERN)
    &#34;&#34;&#34;Constant: regular expression to match a HXL tag pattern.
    &#34;&#34;&#34;

    def __init__(self, tag, include_attributes=[], exclude_attributes=[], is_absolute=False):
        self.tag = tag

        self.include_attributes = set(include_attributes)
        &#34;&#34;&#34;Set of all attributes that must be present&#34;&#34;&#34;
        
        self.exclude_attributes = set(exclude_attributes)
        &#34;&#34;&#34;Set of all attributes that must not be present&#34;&#34;&#34;
        
        self.is_absolute = is_absolute
        &#34;&#34;&#34;True if this pattern is absolute (no extra attributes allowed)&#34;&#34;&#34;

    def is_wildcard(self):
        return self.tag == &#39;#*&#39;

    def match(self, column):
        &#34;&#34;&#34;Check whether a Column matches this pattern.
        @param column: the column to check
        @returns: True if the column is a match
        &#34;&#34;&#34;
        if column.tag and (self.is_wildcard() or self.tag == column.tag):
            # all include_attributes must be present
            if self.include_attributes:
                for attribute in self.include_attributes:
                    if attribute not in column.attributes:
                        return False
            # all exclude_attributes must be absent
            if self.exclude_attributes:
                for attribute in self.exclude_attributes:
                    if attribute in column.attributes:
                        return False
            # if absolute, then only specified attributes may be present
            if self.is_absolute:
                for attribute in column.attributes:
                    if attribute not in self.include_attributes:
                        return False
            return True
        else:
            return False

    def get_matching_columns(self, columns):
        &#34;&#34;&#34;Return a list of columns that match the pattern.
        @param columns: a list of L{hxl.model.Column} objects
        @returns: a list (possibly empty)
        &#34;&#34;&#34;
        result = []
        for column in columns:
            if self.match(column):
                result.append(column)
        return result

    def find_column_index(self, columns):
        &#34;&#34;&#34;Get the index of the first matching column.
        @param columns: a list of columns to check
        @returns: the 0-based index of the first matching column, or None for no match
        &#34;&#34;&#34;
        for i in range(len(columns)):
            if self.match(columns[i]):
                return i
        return None

    def find_column(self, columns):
        &#34;&#34;&#34;Check whether there is a match in a list of columns.&#34;&#34;&#34;
        for column in columns:
            if self.match(column):
                return column
        return None

    def __repr__(self):
        s = self.tag
        if self.include_attributes:
            for attribute in self.include_attributes:
                s += &#39;+&#39; + attribute
        if self.exclude_attributes:
            for attribute in self.exclude_attributes:
                s += &#39;-&#39; + attribute
        return s

    __str__ = __repr__

    @staticmethod
    def parse(s):
        &#34;&#34;&#34;Parse a single tag-pattern string.

            pattern = TagPattern.parse(&#34;#affected+f-children&#34;)

        The [parse_list()](#hxl.model.TagPattern.parse_list) method
        will call this method to parse multiple patterns at once.
        
        Args:
            s: the tag-pattern string to parse

        Returns:
            A TagPattern object

        &#34;&#34;&#34;

        if not s:
            # edge case: null value
            raise hxl.HXLException(&#39;Attempt to parse empty tag pattern&#39;)
        elif isinstance(s, TagPattern):
            # edge case: already parsed
            return s

        result = re.match(TagPattern.PATTERN, s)
        if result:
            tag = &#39;#&#39; + result.group(1).lower()
            include_attributes = set()
            exclude_attributes = set()
            attribute_specs = re.split(r&#39;\s*([+-])&#39;, result.group(2))
            for i in range(1, len(attribute_specs), 2):
                if attribute_specs[i] == &#39;+&#39;:
                    include_attributes.add(attribute_specs[i + 1].lower())
                else:
                    exclude_attributes.add(attribute_specs[i + 1].lower())
            if result.group(3) == &#39;!&#39;:
                is_absolute = True
                if exclude_attributes:
                    raise ValueError(&#39;Exclusions not allowed in absolute patterns&#39;)
            else:
                is_absolute = False
            return TagPattern(
                tag,
                include_attributes=include_attributes,
                exclude_attributes=exclude_attributes,
                is_absolute=is_absolute
            )
        else:
            raise hxl.HXLException(&#39;Malformed tag: &#39; + s)

    @staticmethod
    def parse_list(specs):
        &#34;&#34;&#34;Parse a list of tag-pattern strings.

        If _specs_ is a list of already-parsed TagPattern objects, do
        nothing. If it&#39;s a list of strings, apply
        [parse()](#hxl.model.TagPattern.parse) to each one. If it&#39;s a
        single string with multiple patterns separated by commas,
        split the string, then parse the patterns.

            patterns = TagPattern.parse_list(&#34;#affected+f,#inneed+f&#34;)
            # or
            patterns = TagPattern.parse_list(&#34;#affected+f&#34;, &#34;#inneed+f&#34;)
        
        Args:
            specs: the raw input (a list of strings, or a single string with commas separating the patterns)

        Returns:
            A list of TagPattern objects.

        &#34;&#34;&#34;
        if not specs:
            return []
        if isinstance(specs, six.string_types):
            specs = specs.split(&#39;,&#39;)
        return [TagPattern.parse(spec) for spec in specs]

    @staticmethod
    def match_list(column, patterns):
        &#34;&#34;&#34;Test if a column matches any of the patterns in a list.

        This is convenient to use together with [parse_list()](hxl.model.TagPattern.parse_list):

            patterns = TagPattern.parse_list([&#34;#affected+f&#34;, &#34;#inneed+f&#34;])
            if TagPattern.match_list(column, patterns):
                print(&#34;The column matched one of the patterns&#34;)

        Args:
            column: the column to test
            patterns: a list of zero or more patterns.

        Returns:
            True if there is a match

        &#34;&#34;&#34;
        for pattern in patterns:
            if pattern.match(column):
                return True
        return False</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="hxl.model.TagPattern.PATTERN"><code class="name">var <span class="ident">PATTERN</span></code></dt>
<dd>
<div class="desc"><p>Constant: regular expression to match a HXL tag pattern.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="hxl.model.TagPattern.match_list"><code class="name flex">
<span>def <span class="ident">match_list</span></span>(<span>column, patterns)</span>
</code></dt>
<dd>
<div class="desc"><p>Test if a column matches any of the patterns in a list.</p>
<p>This is convenient to use together with <a href="hxl.model.TagPattern.parse_list">parse_list()</a>:</p>
<pre><code>patterns = TagPattern.parse_list(["#affected+f", "#inneed+f"])
if TagPattern.match_list(column, patterns):
    print("The column matched one of the patterns")
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong></dt>
<dd>the column to test</dd>
<dt><strong><code>patterns</code></strong></dt>
<dd>a list of zero or more patterns.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if there is a match</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def match_list(column, patterns):
    &#34;&#34;&#34;Test if a column matches any of the patterns in a list.

    This is convenient to use together with [parse_list()](hxl.model.TagPattern.parse_list):

        patterns = TagPattern.parse_list([&#34;#affected+f&#34;, &#34;#inneed+f&#34;])
        if TagPattern.match_list(column, patterns):
            print(&#34;The column matched one of the patterns&#34;)

    Args:
        column: the column to test
        patterns: a list of zero or more patterns.

    Returns:
        True if there is a match

    &#34;&#34;&#34;
    for pattern in patterns:
        if pattern.match(column):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="hxl.model.TagPattern.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a single tag-pattern string.</p>
<pre><code>pattern = TagPattern.parse("#affected+f-children")
</code></pre>
<p>The <a href="#hxl.model.TagPattern.parse_list">parse_list()</a> method
will call this method to parse multiple patterns at once.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong></dt>
<dd>the tag-pattern string to parse</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A TagPattern object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(s):
    &#34;&#34;&#34;Parse a single tag-pattern string.

        pattern = TagPattern.parse(&#34;#affected+f-children&#34;)

    The [parse_list()](#hxl.model.TagPattern.parse_list) method
    will call this method to parse multiple patterns at once.
    
    Args:
        s: the tag-pattern string to parse

    Returns:
        A TagPattern object

    &#34;&#34;&#34;

    if not s:
        # edge case: null value
        raise hxl.HXLException(&#39;Attempt to parse empty tag pattern&#39;)
    elif isinstance(s, TagPattern):
        # edge case: already parsed
        return s

    result = re.match(TagPattern.PATTERN, s)
    if result:
        tag = &#39;#&#39; + result.group(1).lower()
        include_attributes = set()
        exclude_attributes = set()
        attribute_specs = re.split(r&#39;\s*([+-])&#39;, result.group(2))
        for i in range(1, len(attribute_specs), 2):
            if attribute_specs[i] == &#39;+&#39;:
                include_attributes.add(attribute_specs[i + 1].lower())
            else:
                exclude_attributes.add(attribute_specs[i + 1].lower())
        if result.group(3) == &#39;!&#39;:
            is_absolute = True
            if exclude_attributes:
                raise ValueError(&#39;Exclusions not allowed in absolute patterns&#39;)
        else:
            is_absolute = False
        return TagPattern(
            tag,
            include_attributes=include_attributes,
            exclude_attributes=exclude_attributes,
            is_absolute=is_absolute
        )
    else:
        raise hxl.HXLException(&#39;Malformed tag: &#39; + s)</code></pre>
</details>
</dd>
<dt id="hxl.model.TagPattern.parse_list"><code class="name flex">
<span>def <span class="ident">parse_list</span></span>(<span>specs)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a list of tag-pattern strings.</p>
<p>If <em>specs</em> is a list of already-parsed TagPattern objects, do
nothing. If it's a list of strings, apply
<a href="#hxl.model.TagPattern.parse">parse()</a> to each one. If it's a
single string with multiple patterns separated by commas,
split the string, then parse the patterns.</p>
<pre><code>patterns = TagPattern.parse_list("#affected+f,#inneed+f")
# or
patterns = TagPattern.parse_list("#affected+f", "#inneed+f")
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>specs</code></strong></dt>
<dd>the raw input (a list of strings, or a single string with commas separating the patterns)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of TagPattern objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_list(specs):
    &#34;&#34;&#34;Parse a list of tag-pattern strings.

    If _specs_ is a list of already-parsed TagPattern objects, do
    nothing. If it&#39;s a list of strings, apply
    [parse()](#hxl.model.TagPattern.parse) to each one. If it&#39;s a
    single string with multiple patterns separated by commas,
    split the string, then parse the patterns.

        patterns = TagPattern.parse_list(&#34;#affected+f,#inneed+f&#34;)
        # or
        patterns = TagPattern.parse_list(&#34;#affected+f&#34;, &#34;#inneed+f&#34;)
    
    Args:
        specs: the raw input (a list of strings, or a single string with commas separating the patterns)

    Returns:
        A list of TagPattern objects.

    &#34;&#34;&#34;
    if not specs:
        return []
    if isinstance(specs, six.string_types):
        specs = specs.split(&#39;,&#39;)
    return [TagPattern.parse(spec) for spec in specs]</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.model.TagPattern.exclude_attributes"><code class="name">var <span class="ident">exclude_attributes</span></code></dt>
<dd>
<div class="desc"><p>Set of all attributes that must not be present</p></div>
</dd>
<dt id="hxl.model.TagPattern.include_attributes"><code class="name">var <span class="ident">include_attributes</span></code></dt>
<dd>
<div class="desc"><p>Set of all attributes that must be present</p></div>
</dd>
<dt id="hxl.model.TagPattern.is_absolute"><code class="name">var <span class="ident">is_absolute</span></code></dt>
<dd>
<div class="desc"><p>True if this pattern is absolute (no extra attributes allowed)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.model.TagPattern.find_column"><code class="name flex">
<span>def <span class="ident">find_column</span></span>(<span>self, columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether there is a match in a list of columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_column(self, columns):
    &#34;&#34;&#34;Check whether there is a match in a list of columns.&#34;&#34;&#34;
    for column in columns:
        if self.match(column):
            return column
    return None</code></pre>
</details>
</dd>
<dt id="hxl.model.TagPattern.find_column_index"><code class="name flex">
<span>def <span class="ident">find_column_index</span></span>(<span>self, columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the index of the first matching column.
@param columns: a list of columns to check
@returns: the 0-based index of the first matching column, or None for no match</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_column_index(self, columns):
    &#34;&#34;&#34;Get the index of the first matching column.
    @param columns: a list of columns to check
    @returns: the 0-based index of the first matching column, or None for no match
    &#34;&#34;&#34;
    for i in range(len(columns)):
        if self.match(columns[i]):
            return i
    return None</code></pre>
</details>
</dd>
<dt id="hxl.model.TagPattern.get_matching_columns"><code class="name flex">
<span>def <span class="ident">get_matching_columns</span></span>(<span>self, columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of columns that match the pattern.
@param columns: a list of L{hxl.model.Column} objects
@returns: a list (possibly empty)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_matching_columns(self, columns):
    &#34;&#34;&#34;Return a list of columns that match the pattern.
    @param columns: a list of L{hxl.model.Column} objects
    @returns: a list (possibly empty)
    &#34;&#34;&#34;
    result = []
    for column in columns:
        if self.match(column):
            result.append(column)
    return result</code></pre>
</details>
</dd>
<dt id="hxl.model.TagPattern.is_wildcard"><code class="name flex">
<span>def <span class="ident">is_wildcard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_wildcard(self):
    return self.tag == &#39;#*&#39;</code></pre>
</details>
</dd>
<dt id="hxl.model.TagPattern.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether a Column matches this pattern.
@param column: the column to check
@returns: True if the column is a match</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, column):
    &#34;&#34;&#34;Check whether a Column matches this pattern.
    @param column: the column to check
    @returns: True if the column is a match
    &#34;&#34;&#34;
    if column.tag and (self.is_wildcard() or self.tag == column.tag):
        # all include_attributes must be present
        if self.include_attributes:
            for attribute in self.include_attributes:
                if attribute not in column.attributes:
                    return False
        # all exclude_attributes must be absent
        if self.exclude_attributes:
            for attribute in self.exclude_attributes:
                if attribute in column.attributes:
                    return False
        # if absolute, then only specified attributes may be present
        if self.is_absolute:
            for attribute in column.attributes:
                if attribute not in self.include_attributes:
                    return False
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hxl" href="index.html">hxl</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hxl.model.get_column_indices" href="#hxl.model.get_column_indices">get_column_indices</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hxl.model.Column" href="#hxl.model.Column">Column</a></code></h4>
<ul class="two-column">
<li><code><a title="hxl.model.Column.PATTERN" href="#hxl.model.Column.PATTERN">PATTERN</a></code></li>
<li><code><a title="hxl.model.Column.add_attribute" href="#hxl.model.Column.add_attribute">add_attribute</a></code></li>
<li><code><a title="hxl.model.Column.attribute_list" href="#hxl.model.Column.attribute_list">attribute_list</a></code></li>
<li><code><a title="hxl.model.Column.attributes" href="#hxl.model.Column.attributes">attributes</a></code></li>
<li><code><a title="hxl.model.Column.column_number" href="#hxl.model.Column.column_number">column_number</a></code></li>
<li><code><a title="hxl.model.Column.display_tag" href="#hxl.model.Column.display_tag">display_tag</a></code></li>
<li><code><a title="hxl.model.Column.get_display_tag" href="#hxl.model.Column.get_display_tag">get_display_tag</a></code></li>
<li><code><a title="hxl.model.Column.has_attribute" href="#hxl.model.Column.has_attribute">has_attribute</a></code></li>
<li><code><a title="hxl.model.Column.hash_list" href="#hxl.model.Column.hash_list">hash_list</a></code></li>
<li><code><a title="hxl.model.Column.header" href="#hxl.model.Column.header">header</a></code></li>
<li><code><a title="hxl.model.Column.parse" href="#hxl.model.Column.parse">parse</a></code></li>
<li><code><a title="hxl.model.Column.parse_list" href="#hxl.model.Column.parse_list">parse_list</a></code></li>
<li><code><a title="hxl.model.Column.parse_spec" href="#hxl.model.Column.parse_spec">parse_spec</a></code></li>
<li><code><a title="hxl.model.Column.remove_attribute" href="#hxl.model.Column.remove_attribute">remove_attribute</a></code></li>
<li><code><a title="hxl.model.Column.tag" href="#hxl.model.Column.tag">tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.model.Dataset" href="#hxl.model.Dataset">Dataset</a></code></h4>
<ul class="">
<li><code><a title="hxl.model.Dataset.add_columns" href="#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.model.Dataset.append" href="#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.model.Dataset.append_external_list" href="#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.model.Dataset.cache" href="#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.model.Dataset.clean_data" href="#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.model.Dataset.columns" href="#hxl.model.Dataset.columns">columns</a></code></li>
<li><code><a title="hxl.model.Dataset.columns_hash" href="#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.model.Dataset.count" href="#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.model.Dataset.data_hash" href="#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.model.Dataset.dedup" href="#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.model.Dataset.display_tags" href="#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.model.Dataset.expand_lists" href="#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.model.Dataset.explode" href="#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.model.Dataset.fill_data" href="#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.model.Dataset.gen_csv" href="#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.model.Dataset.gen_json" href="#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.model.Dataset.gen_raw" href="#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.model.Dataset.get_column_indices" href="#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.model.Dataset.get_value_set" href="#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.model.Dataset.has_headers" href="#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.model.Dataset.headers" href="#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.model.Dataset.implode" href="#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.model.Dataset.is_cached" href="#hxl.model.Dataset.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.model.Dataset.jsonpath" href="#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.model.Dataset.max" href="#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.model.Dataset.merge_data" href="#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.model.Dataset.min" href="#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.model.Dataset.recipe" href="#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.model.Dataset.rename_columns" href="#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.model.Dataset.replace_data" href="#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.model.Dataset.replace_data_map" href="#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.model.Dataset.row_counter" href="#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.model.Dataset.sort" href="#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.model.Dataset.tags" href="#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.model.Dataset.validate" href="#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.model.Dataset.values" href="#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.model.Dataset.with_columns" href="#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.model.Dataset.with_rows" href="#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.model.Dataset.without_columns" href="#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.model.Dataset.without_rows" href="#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.model.Row" href="#hxl.model.Row">Row</a></code></h4>
<ul class="two-column">
<li><code><a title="hxl.model.Row.append" href="#hxl.model.Row.append">append</a></code></li>
<li><code><a title="hxl.model.Row.columns" href="#hxl.model.Row.columns">columns</a></code></li>
<li><code><a title="hxl.model.Row.dictionary" href="#hxl.model.Row.dictionary">dictionary</a></code></li>
<li><code><a title="hxl.model.Row.get" href="#hxl.model.Row.get">get</a></code></li>
<li><code><a title="hxl.model.Row.get_all" href="#hxl.model.Row.get_all">get_all</a></code></li>
<li><code><a title="hxl.model.Row.key" href="#hxl.model.Row.key">key</a></code></li>
<li><code><a title="hxl.model.Row.row_number" href="#hxl.model.Row.row_number">row_number</a></code></li>
<li><code><a title="hxl.model.Row.source_row_number" href="#hxl.model.Row.source_row_number">source_row_number</a></code></li>
<li><code><a title="hxl.model.Row.values" href="#hxl.model.Row.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.model.RowQuery" href="#hxl.model.RowQuery">RowQuery</a></code></h4>
<ul class="two-column">
<li><code><a title="hxl.model.RowQuery.OPERATOR_MAP" href="#hxl.model.RowQuery.OPERATOR_MAP">OPERATOR_MAP</a></code></li>
<li><code><a title="hxl.model.RowQuery.calc_aggregate" href="#hxl.model.RowQuery.calc_aggregate">calc_aggregate</a></code></li>
<li><code><a title="hxl.model.RowQuery.match_list" href="#hxl.model.RowQuery.match_list">match_list</a></code></li>
<li><code><a title="hxl.model.RowQuery.match_row" href="#hxl.model.RowQuery.match_row">match_row</a></code></li>
<li><code><a title="hxl.model.RowQuery.match_value" href="#hxl.model.RowQuery.match_value">match_value</a></code></li>
<li><code><a title="hxl.model.RowQuery.needs_aggregate" href="#hxl.model.RowQuery.needs_aggregate">needs_aggregate</a></code></li>
<li><code><a title="hxl.model.RowQuery.operator_is" href="#hxl.model.RowQuery.operator_is">operator_is</a></code></li>
<li><code><a title="hxl.model.RowQuery.operator_nre" href="#hxl.model.RowQuery.operator_nre">operator_nre</a></code></li>
<li><code><a title="hxl.model.RowQuery.operator_re" href="#hxl.model.RowQuery.operator_re">operator_re</a></code></li>
<li><code><a title="hxl.model.RowQuery.parse" href="#hxl.model.RowQuery.parse">parse</a></code></li>
<li><code><a title="hxl.model.RowQuery.parse_list" href="#hxl.model.RowQuery.parse_list">parse_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.model.TagPattern" href="#hxl.model.TagPattern">TagPattern</a></code></h4>
<ul class="">
<li><code><a title="hxl.model.TagPattern.PATTERN" href="#hxl.model.TagPattern.PATTERN">PATTERN</a></code></li>
<li><code><a title="hxl.model.TagPattern.exclude_attributes" href="#hxl.model.TagPattern.exclude_attributes">exclude_attributes</a></code></li>
<li><code><a title="hxl.model.TagPattern.find_column" href="#hxl.model.TagPattern.find_column">find_column</a></code></li>
<li><code><a title="hxl.model.TagPattern.find_column_index" href="#hxl.model.TagPattern.find_column_index">find_column_index</a></code></li>
<li><code><a title="hxl.model.TagPattern.get_matching_columns" href="#hxl.model.TagPattern.get_matching_columns">get_matching_columns</a></code></li>
<li><code><a title="hxl.model.TagPattern.include_attributes" href="#hxl.model.TagPattern.include_attributes">include_attributes</a></code></li>
<li><code><a title="hxl.model.TagPattern.is_absolute" href="#hxl.model.TagPattern.is_absolute">is_absolute</a></code></li>
<li><code><a title="hxl.model.TagPattern.is_wildcard" href="#hxl.model.TagPattern.is_wildcard">is_wildcard</a></code></li>
<li><code><a title="hxl.model.TagPattern.match" href="#hxl.model.TagPattern.match">match</a></code></li>
<li><code><a title="hxl.model.TagPattern.match_list" href="#hxl.model.TagPattern.match_list">match_list</a></code></li>
<li><code><a title="hxl.model.TagPattern.parse" href="#hxl.model.TagPattern.parse">parse</a></code></li>
<li><code><a title="hxl.model.TagPattern.parse_list" href="#hxl.model.TagPattern.parse_list">parse_list</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>