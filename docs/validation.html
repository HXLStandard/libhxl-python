<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hxl.validation API documentation</title>
<meta name="description" content="Validation code for the Humanitarian Exchange Language (HXL) v1.0
David Megginson
Started October 2014 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hxl.validation</code></h1>
</header>
<section id="section-intro">
<p>Validation code for the Humanitarian Exchange Language (HXL) v1.0
David Megginson
Started October 2014</p>
<p>License: Public Domain
Documentation: <a href="https://github.com/HXLStandard/libhxl-python/wiki">https://github.com/HXLStandard/libhxl-python/wiki</a></p>
<p>A Schema is the top-level class for validating a HXL dataset. The
easiest way to create a schema is via the hxl.schema() method. The
validate() function validates a dataset. Here is a simple validation
example:</p>
<pre><code>def callback(e):
    print("Validation error:", e.message)

source = hxl.data(data_url)
if not hxl.schema(schema_url, callback=callback).validate(source):
    print('Validation failed')
</code></pre>
<p>Each schema contains one or more SchemaRule objects.</p>
<p>Each schema rule contains one or more objects implementing
AbstractRuleTest. To add a new test, create a class extending
AbstractRuleTest, override the methods you need (validate_cell() is
the most common), then add code to Schema.parse() method to parse and
create your new test from the HXL schema.</p>
<p>Validation tests go through the following workflow:</p>
<ul>
<li>needs_scan() to check if the test needs multiple passes</li>
<li>start()</li>
<li>scan_row(hxl.model.Row) for each row in the dataset (only if needs_scan() returned True)</li>
<li>scan_cell(value, hxl.model.Row, hxl.model.Column) for each non-empty cell in each row (only if needs_scan() returned True)</li>
<li>end_scan() (only if needs_scan() returned True)</li>
<li>validate_dataset(hxl.model.Dataset)</li>
<li>validate_row(hxl.model.Row) for each row (row-level validations only)</li>
<li>validate_cell(value, hxl.model.Row, hxl.model.Column) for each cell in each row</li>
<li>end()</li>
</ul>
<p>Any failure means that the entire test, rule, and schema fail
validation, though error reporting will continue to the end.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Validation code for the Humanitarian Exchange Language (HXL) v1.0
David Megginson
Started October 2014

License: Public Domain
Documentation: https://github.com/HXLStandard/libhxl-python/wiki

A Schema is the top-level class for validating a HXL dataset. The
easiest way to create a schema is via the hxl.schema() method. The
validate() function validates a dataset. Here is a simple validation
example:

    def callback(e):
        print(&#34;Validation error:&#34;, e.message)

    source = hxl.data(data_url)
    if not hxl.schema(schema_url, callback=callback).validate(source):
        print(&#39;Validation failed&#39;)

Each schema contains one or more SchemaRule objects.

Each schema rule contains one or more objects implementing
AbstractRuleTest. To add a new test, create a class extending
AbstractRuleTest, override the methods you need (validate_cell() is
the most common), then add code to Schema.parse() method to parse and
create your new test from the HXL schema.

Validation tests go through the following workflow:

- needs_scan() to check if the test needs multiple passes
- start()
- scan_row(hxl.model.Row) for each row in the dataset (only if needs_scan() returned True)
- scan_cell(value, hxl.model.Row, hxl.model.Column) for each non-empty cell in each row (only if needs_scan() returned True)
- end_scan() (only if needs_scan() returned True)
- validate_dataset(hxl.model.Dataset)
- validate_row(hxl.model.Row) for each row (row-level validations only)
- validate_cell(value, hxl.model.Row, hxl.model.Column) for each cell in each row
- end()

Any failure means that the entire test, rule, and schema fail
validation, though error reporting will continue to the end.
&#34;&#34;&#34;

import hxl
import base64, datetime, hashlib, logging, math, os, re, urllib

logger = logging.getLogger(__name__)


class HXLValidationException(hxl.HXLException):
    &#34;&#34;&#34;Data structure to hold a HXL validation error.

    Normally, this exception isn&#39;t thrown, but is passed as a
    parameter to callbacks via Schema, SchemaRule, and classes
    extending AbstractRuleTest.
    &#34;&#34;&#34;

    SCOPES = (&#39;dataset&#39;, &#39;column&#39;, &#39;row&#39;, &#39;cell&#39;,)
    &#34;&#34;&#34;Allowed values for the error scope&#34;&#34;&#34;

    def __init__(self, message, rule=None, value=None, row=None, column=None, suggested_value=None, scope=&#39;cell&#39;, is_external=False):
        &#34;&#34;&#34;Construct a new validation error report.
        @param message: the text message for the error
        @param rule: the rule associated with the error (it may have a more-general descriptive message)
        @param value: the value that triggered the error, if available
        @param row: the hxl.model.Row object associated with the error, if any
        @param column: the hxl.model.Column object associated with the error, if any
        @param suggested_value: the suggested replacement value, if known
        @param scope: the error scope (dataset, column, row, or cell)
        @param is_external: if True, the error is external to the data itself
        &#34;&#34;&#34;
        super().__init__(message)
        
        self.rule = rule
        self.value = value
        self.row = row
        self.column = column
        self.suggested_value = suggested_value
        self.is_external = is_external

        scope = hxl.datatypes.normalise_string(scope)
        if scope in HXLValidationException.SCOPES:
            self.scope = scope
        else:
            raise hxl.HXLException(&#34;Unrecognised validation-error scope: {}&#34;.format(scope))

    def __str__(self):
        &#34;&#34;&#34;Get a string rendition of this error.&#34;&#34;&#34;
        s = &#39;&lt;HXLValidationException &#39;
        if self.message:
            s += self.message + &#39; &#39;
        if self.rule:
            if self.rule.tag_pattern:
                if self.value:
                    s += &#39;{}={} &#39;.format(str(self.rule.tag_pattern), str(self.value))
                else:
                    s += &#39;{} &#39;.format(str(self.rule.tag_pattern))
            if self.message:
                s += &#39;- {}&#39;.format(self.message)
        return s


#
# Individual tests within a Schema Rule
#

class AbstractRuleTest(object):
    &#34;&#34;&#34;Base class for a single test inside a validation rule.

    Workflow (triggered by SchemaRule):

    - needs_scan()
    - start()
    - scan_row() for each row (only if needs_scan() returned True)
    - scan_cell() for each non-empty matching cell (only if needs_scan() returned True)
    - end_scan() (only if needs_scan() returned True)
    - validate_dataset()
    - validate_row() for each row
    - validate_cell() for each matching non-empty cell in each row
    - end()
    &#34;&#34;&#34;

    def __init__(self, callback=None):
        &#34;&#34;&#34;Set up a schema test.
        @param callback: a callback function to receive error reports
        &#34;&#34;&#34;
        self.callback = callback

    def needs_scan(self):
        &#34;&#34;&#34;Report whether this test requires a cached dataset.

        A cached dataset is one that can be processed more than
        once. It requires more memory and processing time, so return
        True only if absolutely necessary.

        If this method returns True, then the validation engine will
        call scan_row() for each row in the dataset, scan_cell() for
        each non-empty matching cell, and end_scan() before invoking
        any of the validate_* methods.

        @returns: True if the test requires a cached dataset.

        &#34;&#34;&#34;
        return False

    def start(self):
        &#34;&#34;&#34;Setup code to run before validating each dataset.
        This code should not report errors, since it hasn&#39;t seen the data yet.
        &#34;&#34;&#34;
        return True

    def end(self):
        &#34;&#34;&#34;Code to run after validating each dataset.
        Will report errors via the test&#39;s callback, if available.
        @returns: True if there are no new validation errors
        &#34;&#34;&#34;
        return True

    def scan_row(self, row, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Scan a row of the dataset to collect information.

        Will be called for each row in the dataset, but only if
        needs_scan() returns True.

        This method does not report any errors; it simply collects
        information for the validate_*() methods to use later.

        @param row: the L{hxl.model.Row} object to pre-scan.
        @param indices: optional pre-compiled indices for the rule to
        look at (in lieu of tag_pattern)
        @param tag_pattern: optional tag pattern for the rule to use.

        &#34;&#34;&#34;
        return

    def scan_cell(self, value, row, column):
        &#34;&#34;&#34;Pre-scan a single cell to collect information.
        Will be called for each maching non-empty cell in each row,
        but only if needs_scan() returns True.

        This method does not report any errors; it simply collects
        information for the validate_*() methods to use later.

        @param value: the non-empty value to validate
        @param row: a hxl.model.Row object for location
        @param column: a hxl.model.Column object for location
        &#34;&#34;&#34;
        return

    def end_scan(self):
        &#34;&#34;&#34;Clean-up calculations after scanning and before validation.
        Will be called only if needs_scan() returned True
        Does not report any errors
        &#34;&#34;&#34;
        return

    def validate_dataset(self, dataset, indices=None, tag_pattern=None):

        &#34;&#34;&#34;Apply test at the dataset level
        Called before validate_row() or validate_value()
        Will report errors via the test&#39;s callback, if available.
        @param dataset: a hxl.model.Dataset object to validate
        @param indices: optional pre-compiled indices for columns matching tag_pattern
        @returns: True if there are no new validation errors.
        &#34;&#34;&#34;
        return True

    def validate_row(self, row, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Apply test at the row level
        Called for each row before validate_cell() calls.
        Will report errors via the test&#39;s callback, if available.
        @param row: a hxl.model.Row object to validate
        @param indices: optional pre-compiled indices for columns matching tag_pattern
        @returns: True if there are no new validation errors.
        &#34;&#34;&#34;
        return True

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Apply test at the cell level
        Called for each matching non-empty value.
        Will also report errors via the test&#39;s callback, if available.
        @param value: the non-empty value to validate
        @param row: a hxl.model.Row object for location
        @param column: a hxl.model.Column object for location
        @returns: True if there are no new validation errors.
        &#34;&#34;&#34;
        return True

    def get_indices(self, indices, tag_pattern, columns):
        &#34;&#34;&#34;Get a set of column indices by hook or by crook, based on what we have&#34;&#34;&#34;
        if indices is not None:
            return indices
        elif tag_pattern is not None:
            tag_pattern = hxl.model.TagPattern.parse(tag_pattern)
            return hxl.model.get_column_indices([tag_pattern], columns)
        else:
            raise hxl.HXLException(&#34;Internal error: rule test requires a tag pattern or a list of indices&#34;)

    def report_error(self, message, row=None, column=None, value=None, suggested_value=None, scope=&#39;cell&#39;):
        &#34;&#34;&#34;Report an error from this test, if there is a callback function available.&#34;&#34;&#34;
        if self.callback:
            self.callback(HXLValidationException(
                message,
                value=value,
                row=row,
                column=column,
                suggested_value=suggested_value,
                scope=scope,
                is_external=False
            ))
        return False # for convenience


class RequiredTest(AbstractRuleTest):
    &#34;&#34;&#34;Test min/max occurrence
    HXL schema: #valid_required
    If the columns don&#39;t exist at all, report only a single error.
    Otherwise, report an error for each row where the test fails.
    &#34;&#34;&#34;

    def __init__(self, min_occurs=None, max_occurs=None):
        &#34;&#34;&#34;Constructor
        @param min: minimum occurrence required (or None)
        @param max: maximum occurrence allowed (or None)
        &#34;&#34;&#34;
        super().__init__()
        self.min_occurs = min_occurs
        self.max_occurs = max_occurs
        self.test_rows = True

    def start(self):
        self.test_rows = True

    def validate_dataset(self, dataset, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Verify that we have enough matching columns to satisfy the test&#34;&#34;&#34;
        status = True
        indices = self.get_indices(indices, tag_pattern, dataset.columns)
        if self.min_occurs is not None and len(indices) &lt; self.min_occurs:
            self.test_rows = False # no point testing individual rows
            status = self.report_error(
                &#34;Expected at least {} matching column(s)&#34;.format(self.min_occurs),
                scope=&#39;dataset&#39;
            )
        return status

    def validate_row(self, row, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Check the number of non-empty occurrences in a row.&#34;&#34;&#34;
        if not self.test_rows: # skip if there aren&#39;t enough columns
            return
        status = True
        indices = self.get_indices(indices, tag_pattern, row.columns)

        non_empty_count = 0
        first_empty_column = None
        last_nonempty_column = None

        # iterate through all values in matching columns
        for i in indices:
            if i &gt;= len(row.values) or hxl.datatypes.is_empty(row.values[i]):
                if first_empty_column is None:
                    first_empty_column = row.columns[i]
            else:
                non_empty_count += 1
                last_nonempty_column = row.columns[i]

        if self.min_occurs is not None and non_empty_count &lt; self.min_occurs:
            status = self.report_error(
                &#34;Expected at least {} matching non-empty value(s)&#34;.format(self.min_occurs),
                row=row,
                column=first_empty_column,
                scope=&#39;row&#39;
            )

        if self.max_occurs is not None and non_empty_count &gt; self.max_occurs:
            status = self.report_error(
                &#34;Expected at most {} matching non-empty value(s)&#34;.format(self.max_occurs),
                row=row,
                column=last_nonempty_column,
                scope=&#39;row&#39;
            )

        return status

    
class DatatypeTest(AbstractRuleTest):
    &#34;&#34;&#34;Test for a specified datatype
    HXL schema: #valid_datatype-consistent
    See also ConsistentDatatypeTest, which infers the most-common datatype.
    &#34;&#34;&#34;

    # allowed datatypes
    DATATYPES = (&#39;text&#39;, &#39;number&#39;, &#39;url&#39;, &#39;email&#39;, &#39;phone&#39;, &#39;date&#39;,)

    def __init__(self, datatype):
        &#34;&#34;&#34;Constructor
        @param datatype: a string specifying the datatype (e.g. &#34;number&#34;)
        &#34;&#34;&#34;
        super().__init__()
        # make sure we recognise the datatype
        datatype = hxl.datatypes.normalise_string(datatype)
        if datatype in DatatypeTest.DATATYPES:
            self.datatype = datatype
        else:
            raise hxl.HXLException(&#34;Unsupported datatype: {}&#34;.format(datatype))

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Validate datatypes on the individual cell level&#34;&#34;&#34;
        status = True
        def report(message):
            return self.report_error(
                message,
                value=value,
                row=row,
                column=column
            )
        
        if self.datatype == &#39;number&#39;:
            if not hxl.datatypes.is_number(value):
                status = report(&#34;Expected a number&#34;)
        elif self.datatype == &#39;url&#39;:
            pieces = urllib.parse.urlparse(value)
            if not (pieces.scheme and pieces.netloc):
                status = report(&#34;Expected a URL&#34;)
        elif self.datatype == &#39;email&#39;:
            if not re.match(r&#39;^[^@]+@[^@]+$&#39;, value):
                status = report(&#34;Expected an email address&#34;)
        elif self.datatype == &#39;phone&#39;:
            if not re.match(r&#39;^\+?[0-9xX()\s-]{5,}$&#39;, value):
                status= report(&#34;Expected a phone number&#34;)
        elif self.datatype == &#39;date&#39;:
            if not hxl.datatypes.is_date(value):
                status = report(&#34;Expected a date&#34;)
        return status


class RangeTest(AbstractRuleTest):
    &#34;&#34;&#34;Test for a range of numbers or strings
    HXL schema: #valid_value+min and #valid_value+max
    This class will try to determine whether to use date sorting, numeric sorting, or lexical sorting
    to determine what is within a range. Ranges are always case-insensitive
    &#34;&#34;&#34;

    def __init__(self, min_value=None, max_value=None):
        &#34;&#34;&#34;Constructor
        @param min_value: the minimum allowed value, or None for no minimum
        @param max_value: the maximum allowed value, or None for no maximum
        &#34;&#34;&#34;
        super().__init__()

        # normalise strings
        if min_value is not None:
            self.min_value = hxl.datatypes.normalise_string(min_value)
        else:
            self.min_value = None
        if max_value is not None:
            self.max_value = hxl.datatypes.normalise_string(max_value)
        else:
            self.max_value = None

        # precompile numbers and dates for efficiency
        try:
            self.min_num = hxl.datatypes.normalise_number(min_value)
        except ValueError:
            self.min_num = None

        try:
            self.max_num = hxl.datatypes.normalise_number(max_value)
        except ValueError:
            self.max_num = None

        try:
            self.min_date = hxl.datatypes.normalise_date(min_value)
        except ValueError:
            self.min_date = None

        try:
            self.max_date = hxl.datatypes.normalise_date(max_value)
        except ValueError:
            self.max_date = None

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Test that a value is &gt;= min_value and/or &lt;= max_value
        Includes special handling for numbers and dates.
        &#34;&#34;&#34;
        def report(message):
            return self.report_error(
                message,
                value=value,
                row=row,
                column=column
            )

        # try as a date
        if column.tag == &#39;#date&#39; and (self.min_date is not None or self.max_date is not None):
            try:
                date_value = hxl.datatypes.normalise_date(value)
                if self.min_date is not None and date_value &lt; self.min_date:
                    return report(&#39;Date must not be before {}&#39;.format(self.min_date))
                elif self.max_date is not None and date_value &gt; self.max_date:
                    return report(&#39;Date must not be after {}&#39;.format(self.max_date))
                else:
                    return True
            except ValueError:
                pass # OK

        # try as a number
        if self.min_num is not None or self.max_num is not None:
            try:
                num_value = hxl.datatypes.normalise_number(value)
                if self.min_num is not None and num_value &lt; self.min_num:
                    return report(&#39;Value must not be less than {}&#39;.format(self.min_num))
                elif self.max_num is not None and num_value &gt; self.max_num:
                    return report(&#39;Value must not be more than {}&#39;.format(self.max_num))
                else:
                    return True
            except ValueError:
                pass # OK

        # try as a case-/whitespace-normalised string
        norm_value = hxl.datatypes.normalise_string(value)
        if self.min_value is not None and norm_value &lt; self.min_value:
            return report(&#39;Value must not come before {}&#39;.format(self.min_value))
        elif self.max_value is not None and norm_value &gt; self.max_value:
            return report(&#39;Value must not come after {}&#39;.format(self.max_value))
        else:
            return True


class WhitespaceTest(AbstractRuleTest):
    &#34;&#34;&#34;Test for irregular whitespace in a cell 
    HXL schema: #valid_value+whitespace
    Irregular whitespace is any leading or trailing space, 
    or anything but a single space character inside a string
    &#34;&#34;&#34;

    PATTERN = r&#39;^(\s+.*|.*(\s\s|[\t\r\n]).*|.*\s+)$&#39;
    &#34;&#34;&#34;Regular expression to detect irregular whitespace&#34;&#34;&#34;

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Is there irregular whitespace?&#34;&#34;&#34;
        if hxl.datatypes.is_string(value):
            if re.match(WhitespaceTest.PATTERN, value):
                return self.report_error(
                    &#39;Found extra whitespace&#39;,
                    value=value,
                    row=row,
                    column=column,
                    suggested_value=hxl.datatypes.normalise_space(value)
                )
        return True
        

class RegexTest(AbstractRuleTest):
    &#34;&#34;&#34;Test that non-empty values match a regular expression 
    HXL schema: #valid_value+regex
    The regex is unanchored, so use &#39;^&#39; or &#39;$&#39; to anchor if needed
    Whitespace is not normalised before matching
    &#34;&#34;&#34;

    def __init__(self, regex, case_sensitive=True):
        &#34;&#34;&#34;Constructor
        @param regex: the regular expression to test against
        @param case_sensitive: if True (default), matches are case-sensitive
        &#34;&#34;&#34;
        super().__init__()
        self.regex_text = str(regex)
        if case_sensitive:
            self.regex = re.compile(regex)
        else:
            self.regex = re.compile(regex, flags=re.IGNORECASE)

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Match value (including whitespace) against the regular expression&#34;&#34;&#34;
        if self.regex.search(value):
            return True
        else:
            return self.report_error(
                &#39;Should match regular expression /{}/&#39;.format(self.regex_text),
                value=value,
                row=row,
                column=column
            )


class UniqueValueTest(AbstractRuleTest):
    &#34;&#34;&#34;Test that individual values are unique
    HXL schema: #valid_unique-key
    Every value in any column matching tag_pattern must be unique.
    Normalises case and whitespace before testing, so &#34;Aaa&#34; and &#34;  aaa&#34; 
    would count as duplicates.
    &#34;&#34;&#34;

    def start(self):
        self.values_seen = set() # create the empty value set

    def end(self):
        self.values_seen = None # free some memory
        return True

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Report an error if we see the same (normalised) value more than once&#34;&#34;&#34;
        norm_value = hxl.datatypes.normalise_string(value)
        if norm_value in self.values_seen:
            return self.report_error(
                &#34;Duplicate value&#34;,
                value=value,
                row=row,
                column=column
            )
        else:
            self.values_seen.add(norm_value)
            return True


class UniqueRowTest(AbstractRuleTest):
    &#34;&#34;&#34;Test for duplicate rows, optionally using a list of tag patterns as a key
    HXL schema: #valid_unique+key
    If there are no tag patterns provided, uses the entire row to make the key
    Note that the target tag pattern (#valid_tag) is irrelevant for this test.
    &#34;&#34;&#34;

    def __init__(self, tag_patterns=None):
        &#34;&#34;&#34;Constructor
        If no tag patterns are supplied, test the whole row.
        @param tag_patterns: list of tag patterns to test
        &#34;&#34;&#34;
        super().__init__()
        if tag_patterns is not None:
            self.tag_patterns = hxl.model.TagPattern.parse_list(tag_patterns)
        else:
            self.tag_patterns = None

    def start(self):
        self.keys_seen = set() # create the empty key set

    def end(self):
        self.keys_seen = None # free some memory
        return True

    def validate_row(self, row, indices=[], tag_pattern=None):
        key = row.key(self.tag_patterns)
        if key in self.keys_seen:
            return self.report_error(
                &#39;Duplicate row according to key values {}&#39;.format(str(key)),
                row=row,
                scope=&#39;row&#39;
            )
        else:
            self.keys_seen.add(key)
            return True


class EnumerationTest(AbstractRuleTest):
    &#34;&#34;&#34;Test against a list of enumerated values 
    HXL schema: #valid_value+list #valid_value+url #valid_value+case
    This test can also hold an extra error to report if there was a problem
    e.g. reading the values externally.
    &#34;&#34;&#34;

    def __init__(self, allowed_values, case_sensitive=False):
        &#34;&#34;&#34;Constructor
        @param allowed_values: sequence of allowed values
        @param case_sensitive: if True, make comparisons case-sensitive
        &#34;&#34;&#34;
        super().__init__()
        self.case_sensitive = case_sensitive
        self.setup_tables(allowed_values)

    def setup_tables(self, allowed_values):
        self.suggested_value_cache = dict()
        self.cooked_value_set = set()

        if self.case_sensitive:
            for raw_value in allowed_values:
                raw_value = hxl.datatypes.normalise_space(raw_value)
                self.cooked_value_set.add(raw_value)
        else:
            self.raw_value_map = dict()
            for raw_value in allowed_values:
                raw_value = hxl.datatypes.normalise_space(raw_value)
                cooked_value = hxl.datatypes.normalise_string(raw_value)
                self.cooked_value_set.add(cooked_value)
                self.raw_value_map[cooked_value] = raw_value

    def validate_cell(self, value, row, column):
        if self.case_sensitive:
            cooked_value = hxl.datatypes.normalise_space(value)
        else:
            cooked_value = hxl.datatypes.normalise_string(value)

        if cooked_value in self.cooked_value_set:
            return True
        else:
            suggested_value = self.get_suggested_value(cooked_value)
            return self.report_error(
                &#34;Value not allowed&#34;,
                value=value,
                row=row,
                column=column,
                suggested_value=suggested_value
            )

    def get_suggested_value(self, value):
        # try the cache first
        suggested_value = self.suggested_value_cache.get(value, False) # False to allow for None values
        if suggested_value is False:
            suggested_value = find_closest_match(value, self.cooked_value_set)
            if suggested_value is not None and not self.case_sensitive:
                # we need the original character case if case-insensitive
                suggested_value = self.raw_value_map[suggested_value]
            self.suggested_value_cache[value] = suggested_value
        return suggested_value

    
class CorrelationTest(AbstractRuleTest):
    &#34;&#34;&#34;Test for correlations with other values
    #valid_correlation
    Supply a list of tag patterns, and report any outliers that don&#39;t
    correlate with those columns.
    TODO: this might be more efficient with pre-scanning
    &#34;&#34;&#34;

    def __init__(self, tag_patterns):
        &#34;&#34;&#34;Constructor
        @param tag_patterns: a list of tag patterns for the correlation
        &#34;&#34;&#34;
        super().__init__()
        self.tag_patterns = hxl.model.TagPattern.parse_list(tag_patterns)

    def start(self):
        &#34;&#34;&#34;Build an empty correlation map&#34;&#34;&#34;
        self.correlation_map = dict()
        self.correlation_indices = None

    def end(self):
        &#34;&#34;&#34;All the error reporting happens here.
        We don&#39;t know the most-common correlations for each key until the end.
        Use the most-common value for each correlation key as the suggested
        value for the others.
        &#34;&#34;&#34;
        status = True
        for tagspec, correlations in self.correlation_map.items():
            for key, value_maps in correlations.items():
                if len(value_maps) &gt; 1:
                    status = False
                    value_maps = sorted(
                        value_maps.items(),
                        key=lambda e: len(e[1]),
                        reverse=True
                    )
                    suggested_value = value_maps[0][0]
                    for value_map in value_maps[1:]:
                        value = value_map[0]
                        for location in value_map[1]:
                            self.report_error(
                                &#34;Unexpected value&#34;,
                                value=value,
                                row=location[0],
                                column=location[1],
                                suggested_value=suggested_value
                            )
        self.correlation_map = None
        return status

    def validate_row(self, row, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Row validation always succeeds
        We use this method to capture the correlation keys,
        so that we can report on them in the end() method.
        &#34;&#34;&#34;

        # will cache, so that we don&#39;t repeat the calculation
        indices = self.get_indices(indices, tag_pattern, row.columns)

        # calculate the correlation-column indices only once as well
        if self.correlation_indices is None:
            self.correlation_indices = hxl.model.get_column_indices(self.tag_patterns, row.columns)

        # Make the correlation key
        key = row.key(indices=self.correlation_indices)

        # Record the locations
        # key -&gt; value -&gt; location
        for i in indices:
            tagspec = row.columns[i].get_display_tag(sort_attributes=True)
            if i &lt; len(row.values) and not hxl.datatypes.is_empty(row.values[i]):
                value = row.values[i]
                column = row.columns[i]
                self.correlation_map.setdefault(tagspec, {}).setdefault(key, {}).setdefault(value, []).append((row, column,))

        # always succeed
        return True

    
class ConsistentDatatypesTest(AbstractRuleTest):
    &#34;&#34;&#34;Check for consistent datatypes in a column.
    HXL: #valid_datatype+consistent
    Will report all but the most-common datatype as errors.
    Special knowledge of the #date hashtag
    &#34;&#34;&#34;

    def needs_scan(self):
        &#34;&#34;&#34;We want to prescan the dataset&#34;&#34;&#34;
        return True

    def start(self):
        self.datatype_map = dict()

    def scan_cell(self, value, row, column):
        datatype = self.guess_type(value, column)
        tagspec = column.get_display_tag(sort_attributes=True) # FIXME

        # keep track of how often the type appeared
        if not tagspec in self.datatype_map:
            self.datatype_map[tagspec] = {}
        if not datatype in self.datatype_map[tagspec]:
            self.datatype_map[tagspec][datatype] = 0
        self.datatype_map[tagspec][datatype] += 1

    def end_scan(self):
        &#34;&#34;&#34;Reduce the datatype_map to the most-common type for each tagspec&#34;&#34;&#34;
        for tagspec, datatypes in self.datatype_map.items():
            max_type = None
            max_count = None
            for datatype, count in datatypes.items():
                if max_count is None or count &gt; max_count:
                    max_count = count
                    max_type = datatype
            self.datatype_map[tagspec] = max_type

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Keep track of each different datatype
        Error reporting happens in the end() method, once we know which
        type is most common.
        @returns: always True
        &#34;&#34;&#34;
        actual_datatype = self.guess_type(value, column)
        tagspec = column.get_display_tag(sort_attributes=True) # FIXME
        expected_datatype = self.datatype_map.get(tagspec)

        if actual_datatype == expected_datatype:
            return True
        else:
            message = &#34;Inconsistent data types: expected {} but found {}&#34;.format(expected_datatype, actual_datatype)
            return self.report_error(
                message,
                value=value,
                row=row,
                column=column
            )

    def guess_type(self, value, column):
        &#34;&#34;&#34;Guess the type of a value&#34;&#34;&#34;
        if column.tag == &#39;#date&#39; and hxl.datatypes.is_date(value):
            return &#39;date&#39;
        elif hxl.datatypes.is_number(value):
            return &#39;number&#39;
        else:
            return &#39;text&#39;


class SpellingTest(AbstractRuleTest):
    &#34;&#34;&#34;Detect spelling outliers in a column
    HXL schema: #valid_value+spelling
    Will treat numbers and dates as strings, so use this only in columns where
    you expect text, and frequently-repeated values (e.g. #status, #org+name, #sector+name).

    Will skip validation if the coefficient of variation &gt; 1.0

    Collects all of the spelling variants first, then checks the rare ones in the end() method, and
    reports any ones that have near matches among the common ones.
    &#34;&#34;&#34;

    ERROR_CUTOFF=0.05 # 5%
    &#34;&#34;&#34;Cutoff for reporting a possible error, as percentage of mean frequency for each spelling&#34;&#34;&#34;

    def __init__(self, case_sensitive=False):
        &#34;&#34;&#34;Constructor
        @param case_sensitive: if True, differences in case are considered errors (default False)
        &#34;&#34;&#34;
        super().__init__()
        self.case_sensitive = case_sensitive

    def start(self):
        &#34;&#34;&#34;Set up for a validation run&#34;&#34;&#34;
        # spelling -&gt; locations

        self.spelling_map = dict()
        &#34;&#34;&#34;Store spellings and locations by tagspec&#34;&#34;&#34;
        
        self.total_occurrences = dict()
        &#34;&#34;&#34;Count the total spelling occurrences, for mean and standard deviation, by tagspec&#34;&#34;&#34;

    def end(self):
        &#34;&#34;&#34;Report possible spelling errors.
        Collect all spellings that appear less than 1/3 of the mean frequency.

        For each of these, check whether there&#39;s a close match among
        the more-common spellings, and if so, then report (once for
        each location) with the suggested correction.
        &#34;&#34;&#34;

        # start by assuming all is well
        status = True

        for tagspec, spellings in self.spelling_map.items():

            # cache corrections so that we don&#39;t keep looking up the same ones
            correction_cache = {}

            # if there aren&#39;t any spellings, then we&#39;re done
            if len(spellings) == 0:
                break

            # get the average (mean) occurrences for each spelling
            mean_frequency = self.total_occurrences[tagspec] / len(spellings)

            # calculate the coefficiant of variance (dimensionless)
            standard_deviation = math.sqrt(
                sum(map(lambda n: (len(n)-mean_frequency)**2, spellings.values())) / len(spellings)
            )
            variance_coefficient = standard_deviation / mean_frequency

            # there&#39;s no point spelling checking unless the variance coefficient is low enough to be meaningful
            if variance_coefficient &gt; 1.0:
                break

            # first pass: collect and clear good spellings
            good_spellings = list()
            for spelling, locations in spellings.items():
                if len(locations) &gt; mean_frequency * SpellingTest.ERROR_CUTOFF:
                    good_spellings.append(spelling)
                    spellings[spelling] = None # no potential errors

            # second pass: report any remaining dubious spellings that have close matches among good spellings
            for spelling, locations in spellings.items():
                if locations is None: # this spelling was OK
                    continue
                # is there a near match among good spellings?
                if spelling in correction_cache:
                    correction = correction_cache[&#39;spelling&#39;]
                else:
                    correction = find_closest_match(spelling, good_spellings)
                    correction_cache[spelling] = correction
                if correction is not None:
                    # if it&#39;s rare and there&#39;s a near match, report an error
                    status = False
                    for location in locations:
                        self.report_error(
                            &#39;Possible spelling error&#39;,
                            value=location[2],
                            row=location[0],
                            column=location[1],
                            suggested_value=correction,
                            scope=&#39;cell&#39;
                        )
                
        return status # false if we&#39;ve found a possible correction

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Record all the spellings found, for later sorting&#34;&#34;&#34;

        tagspec = column.get_display_tag(sort_attributes=True) # FIXME

        if self.case_sensitive:
            cooked_value = hxl.datatypes.normalise_space(value)
        else:
            cooked_value = hxl.datatypes.normalise_string(value)
        self.total_occurrences[tagspec] = self.total_occurrences.setdefault(tagspec, 0) + 1
        self.spelling_map.setdefault(tagspec, {}).setdefault(cooked_value, []).append((row, column, value,))
        return True

    
class NumericOutlierTest(AbstractRuleTest):
    &#34;&#34;&#34;Detect outliers among matching values
    Will skip any tagset with a coefficient of variation &gt; 1.0
    &#34;&#34;&#34;

    def needs_scan(self):
        return True

    def start(self):
        self.standard_deviations = dict()
        self.mean_values = dict()
        self.variation_coefficients = dict()
        self.values = dict()

    def scan_cell(self, value, row, column):
        tagspec = column.get_display_tag(sort_attributes=True) # FIXME
        try:
            num = hxl.datatypes.normalise_number(value)
            if not tagspec in self.values:
                self.values[tagspec] = list()
            self.values[tagspec].append(num)
        except:
            # not a number, so ignore
            pass

    def end_scan(self):
        for tagspec in self.values:

            values = self.values[tagspec]

            # if the list is long enough, remove the min and max values
            if len(values) &gt;= 10: # 10 is our cutoff for removing lowest and highest values
                values = sorted(values)[1:-1]

            # now calculate the standard deviation of the remaining values
            self.mean_values[tagspec] = sum(values) / len(values)
            self.standard_deviations[tagspec] = math.sqrt(
                sum(map(lambda n: (n-self.mean_values[tagspec])*(n-self.mean_values[tagspec]), values)) / len(values)
            )

            # calculate the coefficient of variance, which we&#39;ll use as a cutoff
            if self.mean_values[tagspec]:
                self.variation_coefficients[tagspec] = self.standard_deviations[tagspec] / self.mean_values[tagspec]
            else:
                self.variation_coefficients[tagspec] = 0

        # free some memory
        del self.values

    def validate_cell(self, value, row, column):
        tagspec = column.get_display_tag(sort_attributes=True) # FIXME

        # don&#39;t bother if the data is highly variable
        if self.variation_coefficients.get(tagspec, 0.0) &gt; 1.0:
            return True

        # try numeric validation
        try:
            num = hxl.datatypes.normalise_number(value)
            distance = abs(num - self.mean_values[tagspec])
            if distance &gt; self.standard_deviations[tagspec] * 3:
                self.report_error(
                    &#34;Possible numeric outlier&#34;,
                    value=value,
                    row=row,
                    column=column
                )
                return False
        except:
            # not a number, so ignore
            pass
        return True
    

#
# A single rule (containing one or more tests) within a schema
#

class SchemaRule(object):
    &#34;&#34;&#34;A single rule within a schema.
    A rule contains one or more tests, together with some common metadata
    (a tag pattern, severity level, and description). If any test fails, then
    the whole rule fails.

    Workflow (triggered by Schema.validate:

    - needs_scan()
    - start()
    - scan_row() for each row (if needs_scan() returned True)
    - scan_cell() for each maching non-empty cell (if needs_scan() returned True)
    - end_scan() (if needs_scan() returned True)
    - validate_dataset()
    - validate_row() for each row
    - validate_cell() for each matching non-empty cell in each row
    - end()
    &#34;&#34;&#34;

    SEVERITY = (&#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,)

    def __init__(self, tag_pattern, severity=&#34;error&#34;, description=None, callback=None):
        &#34;&#34;&#34;Constructor
        @param tag_pattern: the tag pattern to match for the rule
        @param severity: one of &#39;info&#39;, &#39;warning&#39;, or &#39;error&#39; (default)
        @param description: an optional error message to override the default from the tests
        @param callback: an optional callback function to handle error reports
        &#34;&#34;&#34;
        self.tag_pattern = hxl.TagPattern.parse(tag_pattern)
        self.description = description
        self.callback = callback

        # make sure the severity level is valid
        severity = hxl.datatypes.normalise_string(severity)
        if severity in SchemaRule.SEVERITY:
            self.severity = severity
        else:
            raise hxl.HXLException(&#34;Unsupported rule severity level: {}&#34;.format(severity))

        # Additional internal variables
        self.tests = []
        &#34;&#34;&#34;List of AbstractRuleTest objects to apply as part of this rule&#34;&#34;&#34;

        self.external_errors = []
        &#34;&#34;&#34;Errors external to the dataset itself (e.g. missing taxonomies)&#34;&#34;&#34;

        self.saved_indices = None
        &#34;&#34;&#34;List of saved column indices matching tag_pattern&#34;&#34;&#34;

    def needs_scan(self):
        &#34;&#34;&#34;Check if any test in this rule requires a pre-scan of the dataset.
        @returns: True if at least one test&#39;s needs_scan() method returns True
        &#34;&#34;&#34;
        for test in self.tests:
            if test.needs_scan():
                return True
        return False

    def start(self):
        &#34;&#34;&#34;Initialisation method
        Call after all values have been set, but before use
        &#34;&#34;&#34;

        self.saved_indices = None

        def test_callback(e):
            &#34;&#34;&#34;Relay error reports from tests, with rule-level context added&#34;&#34;&#34;
            e.rule = self
            if self.callback:
                self.callback(e)

        # (re)initialise all the tests
        for test in self.tests:
            test.callback = test_callback # call back to here
            test.start()

    def end(self):
        &#34;&#34;&#34;Call at end of parse to get post-parse errors&#34;&#34;&#34;
        status = True

        # finish all the tests
        for test in self.tests:
            if not test.end():
                status = False

        self.saved_indices = None
        return status

    def scan_row(self, row):
        &#34;&#34;&#34;Pre-scan a row and its individual cells.
        This method does not report errors or return a status.
        Will be invoked only if needs_scan() returned True
        Calls both scan_row() and scan_cell() for each test.
        @param row the Row to scan
        &#34;&#34;&#34;
        if self.saved_indices is None:
            self.saved_indices = hxl.model.get_column_indices([self.tag_pattern], row.columns)

        # scan each row, then each matching cell in the row
        for test in self.tests:
            if not test.needs_scan(): # don&#39;t invoke unless the test asked for it
                continue
            test.scan_row(row, self.saved_indices)
            for i in self.saved_indices: # validate individual cells
                if i &lt; len(row.values) and not hxl.datatypes.is_empty(row.values[i]):
                    test.scan_cell(row.values[i], row, row.columns[i])

    def end_scan(self):
        &#34;&#34;&#34;Invoke end_scan() for all tests that need it&#34;&#34;&#34;
        for test in self.tests:
            if test.needs_scan():
                test.end_scan()
                    
    def validate_dataset(self, dataset, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Test whether the columns are present to satisfy this rule.&#34;&#34;&#34;
        
        status = True
        if self.saved_indices is None:
            self.saved_indices = hxl.model.get_column_indices([self.tag_pattern], dataset.columns)

        # Report any external errors
        for error in self.external_errors:
            if self.callback:
                self.callback(error)

        # run each of the tests
        for test in self.tests:
            if not test.validate_dataset(dataset, indices=self.saved_indices):
                status = False

        return status

    def validate_row(self, row):
        &#34;&#34;&#34;
        Apply the rule to an entire Row
        @param row the Row to validate
        @return True if all matching values in the row are valid
        &#34;&#34;&#34;

        # individual rules may change to False
        status = True
        if self.saved_indices is None:
            self.saved_indices = hxl.model.get_column_indices([self.tag_pattern], row.columns)

        # run each test on the complete row, then on individual cells
        for test in self.tests:
            if not test.validate_row(row, self.saved_indices):
                status = False
            for i in self.saved_indices: # validate individual cells
                if i &lt; len(row.values) and not hxl.datatypes.is_empty(row.values[i]):
                    if not test.validate_cell(row.values[i], row, row.columns[i]):
                        status = False

        return status

    def __str__(self):
        &#34;&#34;&#34;String representation of a rule (for debugging)&#34;&#34;&#34;
        return &#34;&lt;HXL schema rule: &#34; + str(self.tag_pattern) + &#34;&gt;&#34;
                

class Schema(object):
    &#34;&#34;&#34;Schema against which to validate a HXL document.
    Consists of a sequence of L{SchemaRule} objects to apply to the data.

    The validate() method triggers the following:

    - start()
    - validate_dataset()
    - validate_row() for each row
    - validate_cell() for each matching non-empty cell in each row
    - end()

    Add new rules with

        schema.rules.append(rule)
    &#34;&#34;&#34;

    def __init__(self, callback=None):
        &#34;&#34;&#34;Constructor
        @param callback: a callback function to receive HXLValidationException objects as error reports
        &#34;&#34;&#34;
        self.rules = []
        &#34;&#34;&#34;Rules making up this schema&#34;&#34;&#34;
        
        self.callback = callback
        &#34;&#34;&#34;Callback function to receive error reports&#34;&#34;&#34;

    def validate(self, source):
        &#34;&#34;&#34;Execute the main validation workflow.
        @param source: the hxl.model.Dataset to validate
        &#34;&#34;&#34;
        status = True # all is well at the beginning
        needs_scan = False # assume we don&#39;t need a pre-scan

        # do we need a cached, in-memory dataset?
        for rule in self.rules:
            if rule.needs_scan():
                needs_scan = True
                if not source.is_cached:
                    source = source.cache()
                break

        # initial setup
        self.start()

        # pre-scan if needed
        if needs_scan:
            for row in source:
                self.scan_row(row)
            self.end_scan()

        # dataset-level validations
        if not self.validate_dataset(source):
            status = False

        # row-level validations
        # (will also include cell-level validations)
        for row in source:
            if not self.validate_row(row):
                status = False

        # finalisation
        if not self.end():
            status = False
            
        return status

    def start(self):
        &#34;&#34;&#34;Initialise the validation run&#34;&#34;&#34;

        def rule_callback(e):
            &#34;&#34;&#34;Relay rule callbacks&#34;&#34;&#34;
            if self.callback:
                self.callback(e)
                
        for rule in self.rules:
            rule.callback = rule_callback
            rule.start()

    def end(self):
        &#34;&#34;&#34;Terminate the validation run&#34;&#34;&#34;
        status = True
        for rule in self.rules:
            if not rule.end():
                status = False
        return status

    def scan_row(self, row):
        &#34;&#34;&#34;Pre-scan a row, only for rules that require it.&#34;&#34;&#34;
        for rule in self.rules:
            if rule.needs_scan():
                rule.scan_row(row)

    def end_scan(self):
        &#34;&#34;&#34;End pre-scan, for rules that require it.&#34;&#34;&#34;
        for rule in self.rules:
            if rule.needs_scan():
                rule.end_scan()

    def validate_dataset(self, dataset):
        &#34;&#34;&#34;Validate just at the dataset level
        @param dataset: the hxl.model.Dataset object to validate
        &#34;&#34;&#34;
        status = True
        for rule in self.rules:
            if not rule.validate_dataset(dataset):
                status = False
        return status

    def validate_row(self, row):
        &#34;&#34;&#34;Validate at the row and cell levels.
        Each rule will handle cell-level validation on its own,
        because it knows what columns to look at.
        @param row: the row to validate
        &#34;&#34;&#34;
        status = True
        for rule in self.rules:
            if not rule.validate_row(row):
                status = False
        return status

    def __str__(self):
        &#34;&#34;&#34;String representation of a schema (for debugging)&#34;&#34;&#34;
        s = &#34;&lt;HXL schema\n&#34;
        for rule in self.rules:
            s += &#34;  &#34; + str(rule) + &#34;\n&#34;
        s += &#34;&gt;&#34;
        return s

    @staticmethod
    def parse(source=None, callback=None):
        &#34;&#34;&#34; Load a HXL schema from the provided input stream, or load default schema.
        @param source: HXL data source for the scheme (e.g. a HXLReader or filter); defaults to the built-in schema
        @param callback: a callback function for reporting errors (receives a HXLValidationException)
        &#34;&#34;&#34;

        # Catch special cases

        if source is None:
            # Use the built-in default schema and recurse
            path = os.path.join(os.path.dirname(__file__), &#39;hxl-default-schema.json&#39;);
            with hxl.data(path, hxl.InputOptions(allow_local=True)) as source:
                return Schema.parse(source, callback)

        if isinstance(source, Schema):
            # Already a schema; set the callback and return it
            source.callback = callback
            return source

        if not isinstance(source, hxl.model.Dataset):
            # Not already a dataset, so wrap it and recurse
            with hxl.data(source) as source:
                return Schema.parse(source, callback)

        # Main parsing

        schema = Schema(callback=callback)

        def parse_type(type):
            if type:
                type = type.lower()
                type = re.sub(r&#39;[^a-z_-]&#39;, &#39;&#39;, type) # normalise
            if type in SchemaRule.DATATYPES:
                return type
            else:
                return None

        def to_int(s):
            if s:
                return int(s)
            else:
                return None

        def to_float(s):
            if s:
                return float(s)
            else:
                return None

        def to_boolean(s):
            if not s or s.lower() in [&#39;0&#39;, &#39;n&#39;, &#39;no&#39;, &#39;f&#39;, &#39;false&#39;]:
                return False
            elif s.lower() in [&#39;y&#39;, &#39;yes&#39;, &#39;t&#39;, &#39;true&#39;]:
                return True
            else:
                raise hxl.HXLException(&#39;Unrecognised true/false value: {}&#39;.format(s))


        for row in source:
            tags = row.get(&#39;#valid_tag&#39;)
            if tags:
                tag_patterns = hxl.model.TagPattern.parse_list(tags)
                for tag_pattern in tag_patterns:
                    rule = SchemaRule(tag_pattern)
                    rule.severity = row.get(&#39;#valid_severity&#39;) or &#39;error&#39;
                    rule.description = row.get(&#39;#description&#39;)

                    # for later use
                    case_sensitive = to_boolean(row.get(&#39;#valid_value+case&#39;))

                    if to_boolean(row.get(&#39;#valid_required-min-max&#39;)):
                        rule.tests.append(RequiredTest(min_occurs=1, max_occurs=None))

                    min_occurs = to_int(row.get(&#39;#valid_required+min&#39;))
                    max_occurs = to_int(row.get(&#39;#valid_required+max&#39;))
                    if min_occurs is not None or max_occurs is not None:
                        rule.tests.append(RequiredTest(min_occurs=min_occurs, max_occurs=max_occurs))

                    datatype = row.get(&#39;#valid_datatype-consistent&#39;)
                    if datatype is not None:
                        rule.tests.append(DatatypeTest(datatype))

                    min_value = row.get(&#39;#valid_value+min&#39;)
                    max_value = row.get(&#39;#valid_value+max&#39;)
                    if min_value is not None or max_value is not None:
                        rule.tests.append(RangeTest(min_value=min_value, max_value=max_value))

                    if to_boolean(row.get(&#39;#valid_value+whitespace&#39;)):
                        rule.tests.append(WhitespaceTest())

                    regex = row.get(&#39;#valid_value+regex&#39;)
                    if regex is not None:
                        rule.tests.append(RegexTest(regex, case_sensitive))

                    if to_boolean(row.get(&#39;#valid_value+spelling&#39;)):
                        rule.tests.append(SpellingTest(case_sensitive=case_sensitive))

                    if to_boolean(row.get(&#39;#valid_unique-key&#39;)):
                        rule.tests.append(UniqueValueTest())

                    key = row.get(&#39;#valid_unique+key&#39;)
                    if hxl.datatypes.is_truthy(key):
                        # could be problematic if there&#39;s even a hashtag like #true or #yes
                        rule.tests.append(UniqueRowTest())
                    elif not hxl.datatypes.is_empty(key):
                        rule.tests.append(UniqueRowTest(key))

                    correlations = row.get(&#39;#valid_correlation&#39;)
                    if not hxl.datatypes.is_empty(correlations):
                        rule.tests.append(CorrelationTest(correlations))

                    if to_boolean(row.get(&#39;#valid_datatype+consistent&#39;)):
                        rule.tests.append(ConsistentDatatypesTest())

                    if to_boolean(row.get(&#39;#valid_value+outliers&#39;)):
                        rule.tests.append(NumericOutlierTest())

                    l = row.get(&#39;#valid_value+list&#39;)
                    if not hxl.datatypes.is_empty(l):
                        allowed_values = re.split(r&#39;\s*\|\s*&#39;, l)
                        if len(allowed_values) &gt; 0:
                            rule.tests.append(EnumerationTest(allowed_values, case_sensitive))

                    url = row.get(&#39;#valid_value+url&#39;)
                    if not hxl.datatypes.is_empty(url):
                        # default the target tag to the #valid_tag
                        target_tag = row.get(&#39;#valid_value+target_tag&#39;, default=tag_pattern)
                        try:
                            # read the values from an external dataset
                            source = hxl.data(url)
                            allowed_values = source.get_value_set(row.get(&#39;#valid_value+target_tag&#39;))
                            if len(allowed_values) &gt; 0:
                                rule.tests.append(EnumerationTest(allowed_values, case_sensitive))
                        except BaseException as error:
                            # don&#39;t add the test to the rule
                            # do add an error about loading the values
                            rule.external_errors.append(HXLValidationException(
                                &#39;Error loading allowed values from {}: {}&#39;.format(url, error.args[0]),
                                scope=&#39;dataset&#39;,
                                rule=rule,
                                is_external=True
                            ))


                    schema.rules.append(rule)

        return schema

#
# Internal helper functions
#

def find_closest_match(s, allowed_values):
    &#34;&#34;&#34;Find the closest match for a value from a list.
    This is not super efficient right now; look at
    https://en.wikipedia.org/wiki/Edit_distance for better algorithms.
    Uses a cutoff of len(s)/3 for candidate matches, and if two matches have the same 
    edit distance, prefers the one with the longer common prefix.
    @param s: the misspelled string to check
    @param allowed_values: a list of allowed values
    @return: the best match, or None if there was no candidate
    &#34;&#34;&#34;
    best_match = None
    max_distance = len(s) / 3
    for value in allowed_values:
        distance = get_edit_distance(s, value)
        if (best_match is not None and distance &gt; best_match[1]) or (distance &gt; max_distance):
            continue
        prefix_len = get_common_prefix_len(s, value)
        if (best_match is None) or (distance &lt; best_match[1]) or (distance == best_match[1] and prefix_len &gt; best_match[2]):
            best_match = (value, distance, prefix_len,)
    if best_match is None:
        return None
    else:
        return best_match[0]

def get_common_prefix_len(s1, s2):
    &#34;&#34;&#34;Return the longest common prefix of two strings
    Adopted from example in https://stackoverflow.com/questions/9114402/regexp-finding-longest-common-prefix-of-two-strings
    @param s1: the first string to compare
    @param s2: the second string to compare
    @returns: the length of the longest common prefix of the two strings
    &#34;&#34;&#34;
    i = 0
    for i, (x, y) in enumerate(zip(s1, s2)):
        if x != y:
            break
    return i

def get_edit_distance(s1, s2):
    &#34;&#34;&#34;Calculate the Levenshtein distance between two normalised strings
    Adopted from example in https://stackoverflow.com/questions/2460177/edit-distance-in-python
    See https://en.wikipedia.org/wiki/Edit_distance
    @param s1: the first string to compare
    @param s2: the second string to compare
    @returns: an integer giving the edit distance
    &#34;&#34;&#34;
    if len(s1) &gt; len(s2):
        s1, s2 = s2, s1
    distances = range(len(s1) + 1)
    for i2, c2 in enumerate(s2):
        distances_ = [i2+1]
        for i1, c1 in enumerate(s1):
            if c1 == c2:
                distances_.append(distances[i1])
            else:
                distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))
        distances = distances_
    return distances[-1]


#
# Exported functions
#
def schema(source=None, callback=None):
    &#34;&#34;&#34;Convenience function for making a schema
    Imported into __init__, and usually called as hxl.schema(source, callback).
    The callback, if provided, will receive a HXLValidationException object for each error
    @param source: something that can be used as a HXL data source
    @param callback: the validation callback function to use
    &#34;&#34;&#34;
    return Schema.parse(source, callback)


def validate(data, schema=None):
    &#34;&#34;&#34;Convenience function for validating HXL data.
    The is_valid parameter in the report will be a True/False value for the result.

    If you want to do anything tricky, you can pass pre-cooked hxl.data() parameters in, e.g.

    result = hxl.validate(hxl.data(&#39;foo.csv&#39;, allow_local=True), hxl.data(&#39;schema.csv&#39;, allow_local=True))

    @param data: the data to validate (a URL or anything else accepted by hxl.data)
    @param schema: the schema to validate against (anything accepted by L{hxl.data}), or None (default) to use the built-in schema.
    @returns: a JSON validation report as documented at https://github.com/HXLStandard/hxl-proxy/wiki/Validation-reports
    &#34;&#34;&#34;

    issue_map = dict()
    external_issue_map = dict()

    def add_issue(issue):
        hash = make_rule_hash(issue.rule)
        if issue.is_external:
            external_issue_map.setdefault(hash, []).append(issue)
        else:
            issue_map.setdefault(hash, []).append(issue)

    status = hxl.schema(schema, callback=add_issue).validate(hxl.data(data))

    schema_url = None
    data_url = None
    if hxl.datatypes.is_string(schema):
        schema_url = schema
    if hxl.datatypes.is_string(data):
        data_url = data

    return make_json_report(status, issue_map, external_issue_map, schema_url=schema_url, data_url=data_url)


#
# Local functions
#

def make_json_report(status, issue_map, external_issue_map, schema_url=None, data_url=None):
    &#34;&#34;&#34;Generate a JSON error report from a dict of errors
    @param status: the validation status (boolean)
    @param issue_map: a dict of lists of HXLValidationException objects grouped by rule hash
    @param external_issue_map: a dict of lists of HXLValidationException objects grouped by rule hash
    @param data_url: the original URL of the data, if available
    @param schema_url: the original URL of the schema, if available
    &#34;&#34;&#34;

    json_report = {
        &#34;validator&#34;: &#34;libhxl-python&#34;,
        &#34;timestamp&#34;: datetime.datetime.now().isoformat(),
        &#34;is_valid&#34;: status,
        &#34;stats&#34;: {
            &#34;info&#34;: 0,
            &#34;warning&#34;: 0,
            &#34;error&#34;: 0,
            &#34;external&#34;: 0,
            &#34;total&#34;: 0,
        },
        &#34;issues&#34;: [],
        &#34;external_issues&#34;: [],
    }

    if schema_url is not None:
        json_report[&#39;schema_url&#39;] = schema_url
        
    if data_url is not None:
        json_report[&#39;data_url&#39;] = data_url

    # add the issue objects
    for rule_id, locations in issue_map.items():
        json_issue = make_json_issue(rule_id, locations)
        json_report[&#39;stats&#39;][&#39;total&#39;] += len(json_issue[&#39;locations&#39;])
        json_report[&#39;stats&#39;][locations[0].rule.severity] += len(json_issue[&#39;locations&#39;])
        json_report[&#39;issues&#39;].append(json_issue)

    # add the external issue objects
    for rule_id, locations in external_issue_map.items():
        json_issue = make_json_issue(rule_id, locations, is_external=True)
        json_report[&#39;stats&#39;][&#39;total&#39;] += 1
        json_report[&#39;stats&#39;][&#39;external&#39;] += 1
        json_report[&#39;external_issues&#39;].append(json_issue)

    return json_report

def make_json_issue(rule_id, locations, is_external=False):
    &#34;&#34;&#34;Create an issue (with list of locations) for a JSON validation report
    @param rule_id: the hash for the rule (used to group locations)
    @param locations: a list of HXLValidation
    &#34;&#34;&#34;

    # grab first location as a model
    model = locations[0]

    # get a custom description first, then the generic message as a fallback
    description = model.rule.description
    if not description:
        description = model.message

    # make the issue
    json_issue = {
        &#34;rule_id&#34;: rule_id,
        &#34;tag_pattern&#34;: str(model.rule.tag_pattern),
        &#34;description&#34;: description,
        &#34;severity&#34;: model.rule.severity,
        &#34;scope&#34;: model.scope,
    }

    # get all unique locations
    if is_external:
        json_issue[&#34;description&#34;] = model.message
    else:
        location_keys = set()
        json_locations = []
        for location in locations:
            row_number = location.row.row_number if location.row else None
            column_number = location.column.column_number if location.column else None
            location_key = (row_number, column_number, location.value, location.suggested_value,)
            if not location_key in location_keys:
                json_locations.append(make_json_location(location))
                location_keys.add(location_key)
        json_issue[&#34;location_count&#34;] = len(locations)
        json_issue[&#34;locations&#34;] = json_locations

    return json_issue

def make_json_location(location):
    &#34;&#34;&#34;Create a single location for a JSON validation report&#34;&#34;&#34;
    json_location = {}

    # is there a row object?
    if location.row is not None:
        if location.row.row_number is not None:
            json_location[&#39;row&#39;] = location.row.row_number
        if location.row.source_row_number is not None:
            json_location[&#39;source_row&#39;] = location.row.source_row_number

    # is there a column object?
    if location.column is not None:
        if location.column.column_number is not None:
            json_location[&#39;col&#39;] = location.column.column_number
        if location.column.display_tag is not None:
            json_location[&#39;hashtag&#39;] = location.column.display_tag

    # is there an error value?
    if location.value is not None:
        json_location[&#39;location_value&#39;] = location.value

    # is there a suggested value?
    if location.suggested_value is not None:
        json_location[&#39;suggested_value&#39;] = location.suggested_value

    return json_location


def make_rule_hash(rule):
    &#34;&#34;&#34;Make a good-enough hash for a rule.&#34;&#34;&#34;
    s = &#34;\r&#34;.join([str(rule.severity), str(rule.description), str(rule.tag_pattern)])
    return base64.urlsafe_b64encode(hashlib.md5(s.encode(&#39;utf-8&#39;)).digest())[:8].decode(&#39;ascii&#39;)

# end</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hxl.validation.find_closest_match"><code class="name flex">
<span>def <span class="ident">find_closest_match</span></span>(<span>s, allowed_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the closest match for a value from a list.
This is not super efficient right now; look at
<a href="https://en.wikipedia.org/wiki/Edit_distance">https://en.wikipedia.org/wiki/Edit_distance</a> for better algorithms.
Uses a cutoff of len(s)/3 for candidate matches, and if two matches have the same
edit distance, prefers the one with the longer common prefix.
@param s: the misspelled string to check
@param allowed_values: a list of allowed values
@return: the best match, or None if there was no candidate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_closest_match(s, allowed_values):
    &#34;&#34;&#34;Find the closest match for a value from a list.
    This is not super efficient right now; look at
    https://en.wikipedia.org/wiki/Edit_distance for better algorithms.
    Uses a cutoff of len(s)/3 for candidate matches, and if two matches have the same 
    edit distance, prefers the one with the longer common prefix.
    @param s: the misspelled string to check
    @param allowed_values: a list of allowed values
    @return: the best match, or None if there was no candidate
    &#34;&#34;&#34;
    best_match = None
    max_distance = len(s) / 3
    for value in allowed_values:
        distance = get_edit_distance(s, value)
        if (best_match is not None and distance &gt; best_match[1]) or (distance &gt; max_distance):
            continue
        prefix_len = get_common_prefix_len(s, value)
        if (best_match is None) or (distance &lt; best_match[1]) or (distance == best_match[1] and prefix_len &gt; best_match[2]):
            best_match = (value, distance, prefix_len,)
    if best_match is None:
        return None
    else:
        return best_match[0]</code></pre>
</details>
</dd>
<dt id="hxl.validation.get_common_prefix_len"><code class="name flex">
<span>def <span class="ident">get_common_prefix_len</span></span>(<span>s1, s2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the longest common prefix of two strings
Adopted from example in <a href="https://stackoverflow.com/questions/9114402/regexp-finding-longest-common-prefix-of-two-strings">https://stackoverflow.com/questions/9114402/regexp-finding-longest-common-prefix-of-two-strings</a>
@param s1: the first string to compare
@param s2: the second string to compare
@returns: the length of the longest common prefix of the two strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_common_prefix_len(s1, s2):
    &#34;&#34;&#34;Return the longest common prefix of two strings
    Adopted from example in https://stackoverflow.com/questions/9114402/regexp-finding-longest-common-prefix-of-two-strings
    @param s1: the first string to compare
    @param s2: the second string to compare
    @returns: the length of the longest common prefix of the two strings
    &#34;&#34;&#34;
    i = 0
    for i, (x, y) in enumerate(zip(s1, s2)):
        if x != y:
            break
    return i</code></pre>
</details>
</dd>
<dt id="hxl.validation.get_edit_distance"><code class="name flex">
<span>def <span class="ident">get_edit_distance</span></span>(<span>s1, s2)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the Levenshtein distance between two normalised strings
Adopted from example in <a href="https://stackoverflow.com/questions/2460177/edit-distance-in-python">https://stackoverflow.com/questions/2460177/edit-distance-in-python</a>
See <a href="https://en.wikipedia.org/wiki/Edit_distance">https://en.wikipedia.org/wiki/Edit_distance</a>
@param s1: the first string to compare
@param s2: the second string to compare
@returns: an integer giving the edit distance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edit_distance(s1, s2):
    &#34;&#34;&#34;Calculate the Levenshtein distance between two normalised strings
    Adopted from example in https://stackoverflow.com/questions/2460177/edit-distance-in-python
    See https://en.wikipedia.org/wiki/Edit_distance
    @param s1: the first string to compare
    @param s2: the second string to compare
    @returns: an integer giving the edit distance
    &#34;&#34;&#34;
    if len(s1) &gt; len(s2):
        s1, s2 = s2, s1
    distances = range(len(s1) + 1)
    for i2, c2 in enumerate(s2):
        distances_ = [i2+1]
        for i1, c1 in enumerate(s1):
            if c1 == c2:
                distances_.append(distances[i1])
            else:
                distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))
        distances = distances_
    return distances[-1]</code></pre>
</details>
</dd>
<dt id="hxl.validation.make_json_issue"><code class="name flex">
<span>def <span class="ident">make_json_issue</span></span>(<span>rule_id, locations, is_external=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an issue (with list of locations) for a JSON validation report
@param rule_id: the hash for the rule (used to group locations)
@param locations: a list of HXLValidation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_json_issue(rule_id, locations, is_external=False):
    &#34;&#34;&#34;Create an issue (with list of locations) for a JSON validation report
    @param rule_id: the hash for the rule (used to group locations)
    @param locations: a list of HXLValidation
    &#34;&#34;&#34;

    # grab first location as a model
    model = locations[0]

    # get a custom description first, then the generic message as a fallback
    description = model.rule.description
    if not description:
        description = model.message

    # make the issue
    json_issue = {
        &#34;rule_id&#34;: rule_id,
        &#34;tag_pattern&#34;: str(model.rule.tag_pattern),
        &#34;description&#34;: description,
        &#34;severity&#34;: model.rule.severity,
        &#34;scope&#34;: model.scope,
    }

    # get all unique locations
    if is_external:
        json_issue[&#34;description&#34;] = model.message
    else:
        location_keys = set()
        json_locations = []
        for location in locations:
            row_number = location.row.row_number if location.row else None
            column_number = location.column.column_number if location.column else None
            location_key = (row_number, column_number, location.value, location.suggested_value,)
            if not location_key in location_keys:
                json_locations.append(make_json_location(location))
                location_keys.add(location_key)
        json_issue[&#34;location_count&#34;] = len(locations)
        json_issue[&#34;locations&#34;] = json_locations

    return json_issue</code></pre>
</details>
</dd>
<dt id="hxl.validation.make_json_location"><code class="name flex">
<span>def <span class="ident">make_json_location</span></span>(<span>location)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a single location for a JSON validation report</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_json_location(location):
    &#34;&#34;&#34;Create a single location for a JSON validation report&#34;&#34;&#34;
    json_location = {}

    # is there a row object?
    if location.row is not None:
        if location.row.row_number is not None:
            json_location[&#39;row&#39;] = location.row.row_number
        if location.row.source_row_number is not None:
            json_location[&#39;source_row&#39;] = location.row.source_row_number

    # is there a column object?
    if location.column is not None:
        if location.column.column_number is not None:
            json_location[&#39;col&#39;] = location.column.column_number
        if location.column.display_tag is not None:
            json_location[&#39;hashtag&#39;] = location.column.display_tag

    # is there an error value?
    if location.value is not None:
        json_location[&#39;location_value&#39;] = location.value

    # is there a suggested value?
    if location.suggested_value is not None:
        json_location[&#39;suggested_value&#39;] = location.suggested_value

    return json_location</code></pre>
</details>
</dd>
<dt id="hxl.validation.make_json_report"><code class="name flex">
<span>def <span class="ident">make_json_report</span></span>(<span>status, issue_map, external_issue_map, schema_url=None, data_url=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a JSON error report from a dict of errors
@param status: the validation status (boolean)
@param issue_map: a dict of lists of HXLValidationException objects grouped by rule hash
@param external_issue_map: a dict of lists of HXLValidationException objects grouped by rule hash
@param data_url: the original URL of the data, if available
@param schema_url: the original URL of the schema, if available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_json_report(status, issue_map, external_issue_map, schema_url=None, data_url=None):
    &#34;&#34;&#34;Generate a JSON error report from a dict of errors
    @param status: the validation status (boolean)
    @param issue_map: a dict of lists of HXLValidationException objects grouped by rule hash
    @param external_issue_map: a dict of lists of HXLValidationException objects grouped by rule hash
    @param data_url: the original URL of the data, if available
    @param schema_url: the original URL of the schema, if available
    &#34;&#34;&#34;

    json_report = {
        &#34;validator&#34;: &#34;libhxl-python&#34;,
        &#34;timestamp&#34;: datetime.datetime.now().isoformat(),
        &#34;is_valid&#34;: status,
        &#34;stats&#34;: {
            &#34;info&#34;: 0,
            &#34;warning&#34;: 0,
            &#34;error&#34;: 0,
            &#34;external&#34;: 0,
            &#34;total&#34;: 0,
        },
        &#34;issues&#34;: [],
        &#34;external_issues&#34;: [],
    }

    if schema_url is not None:
        json_report[&#39;schema_url&#39;] = schema_url
        
    if data_url is not None:
        json_report[&#39;data_url&#39;] = data_url

    # add the issue objects
    for rule_id, locations in issue_map.items():
        json_issue = make_json_issue(rule_id, locations)
        json_report[&#39;stats&#39;][&#39;total&#39;] += len(json_issue[&#39;locations&#39;])
        json_report[&#39;stats&#39;][locations[0].rule.severity] += len(json_issue[&#39;locations&#39;])
        json_report[&#39;issues&#39;].append(json_issue)

    # add the external issue objects
    for rule_id, locations in external_issue_map.items():
        json_issue = make_json_issue(rule_id, locations, is_external=True)
        json_report[&#39;stats&#39;][&#39;total&#39;] += 1
        json_report[&#39;stats&#39;][&#39;external&#39;] += 1
        json_report[&#39;external_issues&#39;].append(json_issue)

    return json_report</code></pre>
</details>
</dd>
<dt id="hxl.validation.make_rule_hash"><code class="name flex">
<span>def <span class="ident">make_rule_hash</span></span>(<span>rule)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a good-enough hash for a rule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_rule_hash(rule):
    &#34;&#34;&#34;Make a good-enough hash for a rule.&#34;&#34;&#34;
    s = &#34;\r&#34;.join([str(rule.severity), str(rule.description), str(rule.tag_pattern)])
    return base64.urlsafe_b64encode(hashlib.md5(s.encode(&#39;utf-8&#39;)).digest())[:8].decode(&#39;ascii&#39;)</code></pre>
</details>
</dd>
<dt id="hxl.validation.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>source=None, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function for making a schema
Imported into <strong>init</strong>, and usually called as hxl.schema(source, callback).
The callback, if provided, will receive a HXLValidationException object for each error
@param source: something that can be used as a HXL data source
@param callback: the validation callback function to use</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def schema(source=None, callback=None):
    &#34;&#34;&#34;Convenience function for making a schema
    Imported into __init__, and usually called as hxl.schema(source, callback).
    The callback, if provided, will receive a HXLValidationException object for each error
    @param source: something that can be used as a HXL data source
    @param callback: the validation callback function to use
    &#34;&#34;&#34;
    return Schema.parse(source, callback)</code></pre>
</details>
</dd>
<dt id="hxl.validation.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>data, schema=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function for validating HXL data.
The is_valid parameter in the report will be a True/False value for the result.</p>
<p>If you want to do anything tricky, you can pass pre-cooked hxl.data() parameters in, e.g.</p>
<p>result = hxl.validate(hxl.data('foo.csv', allow_local=True), hxl.data('schema.csv', allow_local=True))</p>
<p>@param data: the data to validate (a URL or anything else accepted by hxl.data)
@param schema: the schema to validate against (anything accepted by L{hxl.data}), or None (default) to use the built-in schema.
@returns: a JSON validation report as documented at <a href="https://github.com/HXLStandard/hxl-proxy/wiki/Validation-reports">https://github.com/HXLStandard/hxl-proxy/wiki/Validation-reports</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(data, schema=None):
    &#34;&#34;&#34;Convenience function for validating HXL data.
    The is_valid parameter in the report will be a True/False value for the result.

    If you want to do anything tricky, you can pass pre-cooked hxl.data() parameters in, e.g.

    result = hxl.validate(hxl.data(&#39;foo.csv&#39;, allow_local=True), hxl.data(&#39;schema.csv&#39;, allow_local=True))

    @param data: the data to validate (a URL or anything else accepted by hxl.data)
    @param schema: the schema to validate against (anything accepted by L{hxl.data}), or None (default) to use the built-in schema.
    @returns: a JSON validation report as documented at https://github.com/HXLStandard/hxl-proxy/wiki/Validation-reports
    &#34;&#34;&#34;

    issue_map = dict()
    external_issue_map = dict()

    def add_issue(issue):
        hash = make_rule_hash(issue.rule)
        if issue.is_external:
            external_issue_map.setdefault(hash, []).append(issue)
        else:
            issue_map.setdefault(hash, []).append(issue)

    status = hxl.schema(schema, callback=add_issue).validate(hxl.data(data))

    schema_url = None
    data_url = None
    if hxl.datatypes.is_string(schema):
        schema_url = schema
    if hxl.datatypes.is_string(data):
        data_url = data

    return make_json_report(status, issue_map, external_issue_map, schema_url=schema_url, data_url=data_url)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hxl.validation.AbstractRuleTest"><code class="flex name class">
<span>class <span class="ident">AbstractRuleTest</span></span>
<span>(</span><span>callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for a single test inside a validation rule.</p>
<p>Workflow (triggered by SchemaRule):</p>
<ul>
<li>needs_scan()</li>
<li>start()</li>
<li>scan_row() for each row (only if needs_scan() returned True)</li>
<li>scan_cell() for each non-empty matching cell (only if needs_scan() returned True)</li>
<li>end_scan() (only if needs_scan() returned True)</li>
<li>validate_dataset()</li>
<li>validate_row() for each row</li>
<li>validate_cell() for each matching non-empty cell in each row</li>
<li>end()</li>
</ul>
<p>Set up a schema test.
@param callback: a callback function to receive error reports</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractRuleTest(object):
    &#34;&#34;&#34;Base class for a single test inside a validation rule.

    Workflow (triggered by SchemaRule):

    - needs_scan()
    - start()
    - scan_row() for each row (only if needs_scan() returned True)
    - scan_cell() for each non-empty matching cell (only if needs_scan() returned True)
    - end_scan() (only if needs_scan() returned True)
    - validate_dataset()
    - validate_row() for each row
    - validate_cell() for each matching non-empty cell in each row
    - end()
    &#34;&#34;&#34;

    def __init__(self, callback=None):
        &#34;&#34;&#34;Set up a schema test.
        @param callback: a callback function to receive error reports
        &#34;&#34;&#34;
        self.callback = callback

    def needs_scan(self):
        &#34;&#34;&#34;Report whether this test requires a cached dataset.

        A cached dataset is one that can be processed more than
        once. It requires more memory and processing time, so return
        True only if absolutely necessary.

        If this method returns True, then the validation engine will
        call scan_row() for each row in the dataset, scan_cell() for
        each non-empty matching cell, and end_scan() before invoking
        any of the validate_* methods.

        @returns: True if the test requires a cached dataset.

        &#34;&#34;&#34;
        return False

    def start(self):
        &#34;&#34;&#34;Setup code to run before validating each dataset.
        This code should not report errors, since it hasn&#39;t seen the data yet.
        &#34;&#34;&#34;
        return True

    def end(self):
        &#34;&#34;&#34;Code to run after validating each dataset.
        Will report errors via the test&#39;s callback, if available.
        @returns: True if there are no new validation errors
        &#34;&#34;&#34;
        return True

    def scan_row(self, row, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Scan a row of the dataset to collect information.

        Will be called for each row in the dataset, but only if
        needs_scan() returns True.

        This method does not report any errors; it simply collects
        information for the validate_*() methods to use later.

        @param row: the L{hxl.model.Row} object to pre-scan.
        @param indices: optional pre-compiled indices for the rule to
        look at (in lieu of tag_pattern)
        @param tag_pattern: optional tag pattern for the rule to use.

        &#34;&#34;&#34;
        return

    def scan_cell(self, value, row, column):
        &#34;&#34;&#34;Pre-scan a single cell to collect information.
        Will be called for each maching non-empty cell in each row,
        but only if needs_scan() returns True.

        This method does not report any errors; it simply collects
        information for the validate_*() methods to use later.

        @param value: the non-empty value to validate
        @param row: a hxl.model.Row object for location
        @param column: a hxl.model.Column object for location
        &#34;&#34;&#34;
        return

    def end_scan(self):
        &#34;&#34;&#34;Clean-up calculations after scanning and before validation.
        Will be called only if needs_scan() returned True
        Does not report any errors
        &#34;&#34;&#34;
        return

    def validate_dataset(self, dataset, indices=None, tag_pattern=None):

        &#34;&#34;&#34;Apply test at the dataset level
        Called before validate_row() or validate_value()
        Will report errors via the test&#39;s callback, if available.
        @param dataset: a hxl.model.Dataset object to validate
        @param indices: optional pre-compiled indices for columns matching tag_pattern
        @returns: True if there are no new validation errors.
        &#34;&#34;&#34;
        return True

    def validate_row(self, row, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Apply test at the row level
        Called for each row before validate_cell() calls.
        Will report errors via the test&#39;s callback, if available.
        @param row: a hxl.model.Row object to validate
        @param indices: optional pre-compiled indices for columns matching tag_pattern
        @returns: True if there are no new validation errors.
        &#34;&#34;&#34;
        return True

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Apply test at the cell level
        Called for each matching non-empty value.
        Will also report errors via the test&#39;s callback, if available.
        @param value: the non-empty value to validate
        @param row: a hxl.model.Row object for location
        @param column: a hxl.model.Column object for location
        @returns: True if there are no new validation errors.
        &#34;&#34;&#34;
        return True

    def get_indices(self, indices, tag_pattern, columns):
        &#34;&#34;&#34;Get a set of column indices by hook or by crook, based on what we have&#34;&#34;&#34;
        if indices is not None:
            return indices
        elif tag_pattern is not None:
            tag_pattern = hxl.model.TagPattern.parse(tag_pattern)
            return hxl.model.get_column_indices([tag_pattern], columns)
        else:
            raise hxl.HXLException(&#34;Internal error: rule test requires a tag pattern or a list of indices&#34;)

    def report_error(self, message, row=None, column=None, value=None, suggested_value=None, scope=&#39;cell&#39;):
        &#34;&#34;&#34;Report an error from this test, if there is a callback function available.&#34;&#34;&#34;
        if self.callback:
            self.callback(HXLValidationException(
                message,
                value=value,
                row=row,
                column=column,
                suggested_value=suggested_value,
                scope=scope,
                is_external=False
            ))
        return False # for convenience</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hxl.validation.ConsistentDatatypesTest" href="#hxl.validation.ConsistentDatatypesTest">ConsistentDatatypesTest</a></li>
<li><a title="hxl.validation.CorrelationTest" href="#hxl.validation.CorrelationTest">CorrelationTest</a></li>
<li><a title="hxl.validation.DatatypeTest" href="#hxl.validation.DatatypeTest">DatatypeTest</a></li>
<li><a title="hxl.validation.EnumerationTest" href="#hxl.validation.EnumerationTest">EnumerationTest</a></li>
<li><a title="hxl.validation.NumericOutlierTest" href="#hxl.validation.NumericOutlierTest">NumericOutlierTest</a></li>
<li><a title="hxl.validation.RangeTest" href="#hxl.validation.RangeTest">RangeTest</a></li>
<li><a title="hxl.validation.RegexTest" href="#hxl.validation.RegexTest">RegexTest</a></li>
<li><a title="hxl.validation.RequiredTest" href="#hxl.validation.RequiredTest">RequiredTest</a></li>
<li><a title="hxl.validation.SpellingTest" href="#hxl.validation.SpellingTest">SpellingTest</a></li>
<li><a title="hxl.validation.UniqueRowTest" href="#hxl.validation.UniqueRowTest">UniqueRowTest</a></li>
<li><a title="hxl.validation.UniqueValueTest" href="#hxl.validation.UniqueValueTest">UniqueValueTest</a></li>
<li><a title="hxl.validation.WhitespaceTest" href="#hxl.validation.WhitespaceTest">WhitespaceTest</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.AbstractRuleTest.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Code to run after validating each dataset.
Will report errors via the test's callback, if available.
@returns: True if there are no new validation errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self):
    &#34;&#34;&#34;Code to run after validating each dataset.
    Will report errors via the test&#39;s callback, if available.
    @returns: True if there are no new validation errors
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="hxl.validation.AbstractRuleTest.end_scan"><code class="name flex">
<span>def <span class="ident">end_scan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean-up calculations after scanning and before validation.
Will be called only if needs_scan() returned True
Does not report any errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_scan(self):
    &#34;&#34;&#34;Clean-up calculations after scanning and before validation.
    Will be called only if needs_scan() returned True
    Does not report any errors
    &#34;&#34;&#34;
    return</code></pre>
</details>
</dd>
<dt id="hxl.validation.AbstractRuleTest.get_indices"><code class="name flex">
<span>def <span class="ident">get_indices</span></span>(<span>self, indices, tag_pattern, columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a set of column indices by hook or by crook, based on what we have</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_indices(self, indices, tag_pattern, columns):
    &#34;&#34;&#34;Get a set of column indices by hook or by crook, based on what we have&#34;&#34;&#34;
    if indices is not None:
        return indices
    elif tag_pattern is not None:
        tag_pattern = hxl.model.TagPattern.parse(tag_pattern)
        return hxl.model.get_column_indices([tag_pattern], columns)
    else:
        raise hxl.HXLException(&#34;Internal error: rule test requires a tag pattern or a list of indices&#34;)</code></pre>
</details>
</dd>
<dt id="hxl.validation.AbstractRuleTest.needs_scan"><code class="name flex">
<span>def <span class="ident">needs_scan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Report whether this test requires a cached dataset.</p>
<p>A cached dataset is one that can be processed more than
once. It requires more memory and processing time, so return
True only if absolutely necessary.</p>
<p>If this method returns True, then the validation engine will
call scan_row() for each row in the dataset, scan_cell() for
each non-empty matching cell, and end_scan() before invoking
any of the validate_* methods.</p>
<p>@returns: True if the test requires a cached dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def needs_scan(self):
    &#34;&#34;&#34;Report whether this test requires a cached dataset.

    A cached dataset is one that can be processed more than
    once. It requires more memory and processing time, so return
    True only if absolutely necessary.

    If this method returns True, then the validation engine will
    call scan_row() for each row in the dataset, scan_cell() for
    each non-empty matching cell, and end_scan() before invoking
    any of the validate_* methods.

    @returns: True if the test requires a cached dataset.

    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="hxl.validation.AbstractRuleTest.report_error"><code class="name flex">
<span>def <span class="ident">report_error</span></span>(<span>self, message, row=None, column=None, value=None, suggested_value=None, scope='cell')</span>
</code></dt>
<dd>
<div class="desc"><p>Report an error from this test, if there is a callback function available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_error(self, message, row=None, column=None, value=None, suggested_value=None, scope=&#39;cell&#39;):
    &#34;&#34;&#34;Report an error from this test, if there is a callback function available.&#34;&#34;&#34;
    if self.callback:
        self.callback(HXLValidationException(
            message,
            value=value,
            row=row,
            column=column,
            suggested_value=suggested_value,
            scope=scope,
            is_external=False
        ))
    return False # for convenience</code></pre>
</details>
</dd>
<dt id="hxl.validation.AbstractRuleTest.scan_cell"><code class="name flex">
<span>def <span class="ident">scan_cell</span></span>(<span>self, value, row, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Pre-scan a single cell to collect information.
Will be called for each maching non-empty cell in each row,
but only if needs_scan() returns True.</p>
<p>This method does not report any errors; it simply collects
information for the validate_*() methods to use later.</p>
<p>@param value: the non-empty value to validate
@param row: a hxl.model.Row object for location
@param column: a hxl.model.Column object for location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_cell(self, value, row, column):
    &#34;&#34;&#34;Pre-scan a single cell to collect information.
    Will be called for each maching non-empty cell in each row,
    but only if needs_scan() returns True.

    This method does not report any errors; it simply collects
    information for the validate_*() methods to use later.

    @param value: the non-empty value to validate
    @param row: a hxl.model.Row object for location
    @param column: a hxl.model.Column object for location
    &#34;&#34;&#34;
    return</code></pre>
</details>
</dd>
<dt id="hxl.validation.AbstractRuleTest.scan_row"><code class="name flex">
<span>def <span class="ident">scan_row</span></span>(<span>self, row, indices=None, tag_pattern=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Scan a row of the dataset to collect information.</p>
<p>Will be called for each row in the dataset, but only if
needs_scan() returns True.</p>
<p>This method does not report any errors; it simply collects
information for the validate_*() methods to use later.</p>
<p>@param row: the L{hxl.model.Row} object to pre-scan.
@param indices: optional pre-compiled indices for the rule to
look at (in lieu of tag_pattern)
@param tag_pattern: optional tag pattern for the rule to use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_row(self, row, indices=None, tag_pattern=None):
    &#34;&#34;&#34;Scan a row of the dataset to collect information.

    Will be called for each row in the dataset, but only if
    needs_scan() returns True.

    This method does not report any errors; it simply collects
    information for the validate_*() methods to use later.

    @param row: the L{hxl.model.Row} object to pre-scan.
    @param indices: optional pre-compiled indices for the rule to
    look at (in lieu of tag_pattern)
    @param tag_pattern: optional tag pattern for the rule to use.

    &#34;&#34;&#34;
    return</code></pre>
</details>
</dd>
<dt id="hxl.validation.AbstractRuleTest.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setup code to run before validating each dataset.
This code should not report errors, since it hasn't seen the data yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;Setup code to run before validating each dataset.
    This code should not report errors, since it hasn&#39;t seen the data yet.
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="hxl.validation.AbstractRuleTest.validate_cell"><code class="name flex">
<span>def <span class="ident">validate_cell</span></span>(<span>self, value, row, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply test at the cell level
Called for each matching non-empty value.
Will also report errors via the test's callback, if available.
@param value: the non-empty value to validate
@param row: a hxl.model.Row object for location
@param column: a hxl.model.Column object for location
@returns: True if there are no new validation errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_cell(self, value, row, column):
    &#34;&#34;&#34;Apply test at the cell level
    Called for each matching non-empty value.
    Will also report errors via the test&#39;s callback, if available.
    @param value: the non-empty value to validate
    @param row: a hxl.model.Row object for location
    @param column: a hxl.model.Column object for location
    @returns: True if there are no new validation errors.
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="hxl.validation.AbstractRuleTest.validate_dataset"><code class="name flex">
<span>def <span class="ident">validate_dataset</span></span>(<span>self, dataset, indices=None, tag_pattern=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply test at the dataset level
Called before validate_row() or validate_value()
Will report errors via the test's callback, if available.
@param dataset: a hxl.model.Dataset object to validate
@param indices: optional pre-compiled indices for columns matching tag_pattern
@returns: True if there are no new validation errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_dataset(self, dataset, indices=None, tag_pattern=None):

    &#34;&#34;&#34;Apply test at the dataset level
    Called before validate_row() or validate_value()
    Will report errors via the test&#39;s callback, if available.
    @param dataset: a hxl.model.Dataset object to validate
    @param indices: optional pre-compiled indices for columns matching tag_pattern
    @returns: True if there are no new validation errors.
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="hxl.validation.AbstractRuleTest.validate_row"><code class="name flex">
<span>def <span class="ident">validate_row</span></span>(<span>self, row, indices=None, tag_pattern=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply test at the row level
Called for each row before validate_cell() calls.
Will report errors via the test's callback, if available.
@param row: a hxl.model.Row object to validate
@param indices: optional pre-compiled indices for columns matching tag_pattern
@returns: True if there are no new validation errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_row(self, row, indices=None, tag_pattern=None):
    &#34;&#34;&#34;Apply test at the row level
    Called for each row before validate_cell() calls.
    Will report errors via the test&#39;s callback, if available.
    @param row: a hxl.model.Row object to validate
    @param indices: optional pre-compiled indices for columns matching tag_pattern
    @returns: True if there are no new validation errors.
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hxl.validation.ConsistentDatatypesTest"><code class="flex name class">
<span>class <span class="ident">ConsistentDatatypesTest</span></span>
<span>(</span><span>callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Check for consistent datatypes in a column.
HXL: #valid_datatype+consistent
Will report all but the most-common datatype as errors.
Special knowledge of the #date hashtag</p>
<p>Set up a schema test.
@param callback: a callback function to receive error reports</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConsistentDatatypesTest(AbstractRuleTest):
    &#34;&#34;&#34;Check for consistent datatypes in a column.
    HXL: #valid_datatype+consistent
    Will report all but the most-common datatype as errors.
    Special knowledge of the #date hashtag
    &#34;&#34;&#34;

    def needs_scan(self):
        &#34;&#34;&#34;We want to prescan the dataset&#34;&#34;&#34;
        return True

    def start(self):
        self.datatype_map = dict()

    def scan_cell(self, value, row, column):
        datatype = self.guess_type(value, column)
        tagspec = column.get_display_tag(sort_attributes=True) # FIXME

        # keep track of how often the type appeared
        if not tagspec in self.datatype_map:
            self.datatype_map[tagspec] = {}
        if not datatype in self.datatype_map[tagspec]:
            self.datatype_map[tagspec][datatype] = 0
        self.datatype_map[tagspec][datatype] += 1

    def end_scan(self):
        &#34;&#34;&#34;Reduce the datatype_map to the most-common type for each tagspec&#34;&#34;&#34;
        for tagspec, datatypes in self.datatype_map.items():
            max_type = None
            max_count = None
            for datatype, count in datatypes.items():
                if max_count is None or count &gt; max_count:
                    max_count = count
                    max_type = datatype
            self.datatype_map[tagspec] = max_type

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Keep track of each different datatype
        Error reporting happens in the end() method, once we know which
        type is most common.
        @returns: always True
        &#34;&#34;&#34;
        actual_datatype = self.guess_type(value, column)
        tagspec = column.get_display_tag(sort_attributes=True) # FIXME
        expected_datatype = self.datatype_map.get(tagspec)

        if actual_datatype == expected_datatype:
            return True
        else:
            message = &#34;Inconsistent data types: expected {} but found {}&#34;.format(expected_datatype, actual_datatype)
            return self.report_error(
                message,
                value=value,
                row=row,
                column=column
            )

    def guess_type(self, value, column):
        &#34;&#34;&#34;Guess the type of a value&#34;&#34;&#34;
        if column.tag == &#39;#date&#39; and hxl.datatypes.is_date(value):
            return &#39;date&#39;
        elif hxl.datatypes.is_number(value):
            return &#39;number&#39;
        else:
            return &#39;text&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.ConsistentDatatypesTest.end_scan"><code class="name flex">
<span>def <span class="ident">end_scan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce the datatype_map to the most-common type for each tagspec</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_scan(self):
    &#34;&#34;&#34;Reduce the datatype_map to the most-common type for each tagspec&#34;&#34;&#34;
    for tagspec, datatypes in self.datatype_map.items():
        max_type = None
        max_count = None
        for datatype, count in datatypes.items():
            if max_count is None or count &gt; max_count:
                max_count = count
                max_type = datatype
        self.datatype_map[tagspec] = max_type</code></pre>
</details>
</dd>
<dt id="hxl.validation.ConsistentDatatypesTest.guess_type"><code class="name flex">
<span>def <span class="ident">guess_type</span></span>(<span>self, value, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Guess the type of a value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def guess_type(self, value, column):
    &#34;&#34;&#34;Guess the type of a value&#34;&#34;&#34;
    if column.tag == &#39;#date&#39; and hxl.datatypes.is_date(value):
        return &#39;date&#39;
    elif hxl.datatypes.is_number(value):
        return &#39;number&#39;
    else:
        return &#39;text&#39;</code></pre>
</details>
</dd>
<dt id="hxl.validation.ConsistentDatatypesTest.needs_scan"><code class="name flex">
<span>def <span class="ident">needs_scan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>We want to prescan the dataset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def needs_scan(self):
    &#34;&#34;&#34;We want to prescan the dataset&#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="hxl.validation.ConsistentDatatypesTest.validate_cell"><code class="name flex">
<span>def <span class="ident">validate_cell</span></span>(<span>self, value, row, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep track of each different datatype
Error reporting happens in the end() method, once we know which
type is most common.
@returns: always True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_cell(self, value, row, column):
    &#34;&#34;&#34;Keep track of each different datatype
    Error reporting happens in the end() method, once we know which
    type is most common.
    @returns: always True
    &#34;&#34;&#34;
    actual_datatype = self.guess_type(value, column)
    tagspec = column.get_display_tag(sort_attributes=True) # FIXME
    expected_datatype = self.datatype_map.get(tagspec)

    if actual_datatype == expected_datatype:
        return True
    else:
        message = &#34;Inconsistent data types: expected {} but found {}&#34;.format(expected_datatype, actual_datatype)
        return self.report_error(
            message,
            value=value,
            row=row,
            column=column
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.CorrelationTest"><code class="flex name class">
<span>class <span class="ident">CorrelationTest</span></span>
<span>(</span><span>tag_patterns)</span>
</code></dt>
<dd>
<div class="desc"><p>Test for correlations with other values</p>
<h1 id="valid_correlation">valid_correlation</h1>
<p>Supply a list of tag patterns, and report any outliers that don't
correlate with those columns.
TODO: this might be more efficient with pre-scanning</p>
<p>Constructor
@param tag_patterns: a list of tag patterns for the correlation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CorrelationTest(AbstractRuleTest):
    &#34;&#34;&#34;Test for correlations with other values
    #valid_correlation
    Supply a list of tag patterns, and report any outliers that don&#39;t
    correlate with those columns.
    TODO: this might be more efficient with pre-scanning
    &#34;&#34;&#34;

    def __init__(self, tag_patterns):
        &#34;&#34;&#34;Constructor
        @param tag_patterns: a list of tag patterns for the correlation
        &#34;&#34;&#34;
        super().__init__()
        self.tag_patterns = hxl.model.TagPattern.parse_list(tag_patterns)

    def start(self):
        &#34;&#34;&#34;Build an empty correlation map&#34;&#34;&#34;
        self.correlation_map = dict()
        self.correlation_indices = None

    def end(self):
        &#34;&#34;&#34;All the error reporting happens here.
        We don&#39;t know the most-common correlations for each key until the end.
        Use the most-common value for each correlation key as the suggested
        value for the others.
        &#34;&#34;&#34;
        status = True
        for tagspec, correlations in self.correlation_map.items():
            for key, value_maps in correlations.items():
                if len(value_maps) &gt; 1:
                    status = False
                    value_maps = sorted(
                        value_maps.items(),
                        key=lambda e: len(e[1]),
                        reverse=True
                    )
                    suggested_value = value_maps[0][0]
                    for value_map in value_maps[1:]:
                        value = value_map[0]
                        for location in value_map[1]:
                            self.report_error(
                                &#34;Unexpected value&#34;,
                                value=value,
                                row=location[0],
                                column=location[1],
                                suggested_value=suggested_value
                            )
        self.correlation_map = None
        return status

    def validate_row(self, row, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Row validation always succeeds
        We use this method to capture the correlation keys,
        so that we can report on them in the end() method.
        &#34;&#34;&#34;

        # will cache, so that we don&#39;t repeat the calculation
        indices = self.get_indices(indices, tag_pattern, row.columns)

        # calculate the correlation-column indices only once as well
        if self.correlation_indices is None:
            self.correlation_indices = hxl.model.get_column_indices(self.tag_patterns, row.columns)

        # Make the correlation key
        key = row.key(indices=self.correlation_indices)

        # Record the locations
        # key -&gt; value -&gt; location
        for i in indices:
            tagspec = row.columns[i].get_display_tag(sort_attributes=True)
            if i &lt; len(row.values) and not hxl.datatypes.is_empty(row.values[i]):
                value = row.values[i]
                column = row.columns[i]
                self.correlation_map.setdefault(tagspec, {}).setdefault(key, {}).setdefault(value, []).append((row, column,))

        # always succeed
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.CorrelationTest.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>All the error reporting happens here.
We don't know the most-common correlations for each key until the end.
Use the most-common value for each correlation key as the suggested
value for the others.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self):
    &#34;&#34;&#34;All the error reporting happens here.
    We don&#39;t know the most-common correlations for each key until the end.
    Use the most-common value for each correlation key as the suggested
    value for the others.
    &#34;&#34;&#34;
    status = True
    for tagspec, correlations in self.correlation_map.items():
        for key, value_maps in correlations.items():
            if len(value_maps) &gt; 1:
                status = False
                value_maps = sorted(
                    value_maps.items(),
                    key=lambda e: len(e[1]),
                    reverse=True
                )
                suggested_value = value_maps[0][0]
                for value_map in value_maps[1:]:
                    value = value_map[0]
                    for location in value_map[1]:
                        self.report_error(
                            &#34;Unexpected value&#34;,
                            value=value,
                            row=location[0],
                            column=location[1],
                            suggested_value=suggested_value
                        )
    self.correlation_map = None
    return status</code></pre>
</details>
</dd>
<dt id="hxl.validation.CorrelationTest.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Build an empty correlation map</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;Build an empty correlation map&#34;&#34;&#34;
    self.correlation_map = dict()
    self.correlation_indices = None</code></pre>
</details>
</dd>
<dt id="hxl.validation.CorrelationTest.validate_row"><code class="name flex">
<span>def <span class="ident">validate_row</span></span>(<span>self, row, indices=None, tag_pattern=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Row validation always succeeds
We use this method to capture the correlation keys,
so that we can report on them in the end() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_row(self, row, indices=None, tag_pattern=None):
    &#34;&#34;&#34;Row validation always succeeds
    We use this method to capture the correlation keys,
    so that we can report on them in the end() method.
    &#34;&#34;&#34;

    # will cache, so that we don&#39;t repeat the calculation
    indices = self.get_indices(indices, tag_pattern, row.columns)

    # calculate the correlation-column indices only once as well
    if self.correlation_indices is None:
        self.correlation_indices = hxl.model.get_column_indices(self.tag_patterns, row.columns)

    # Make the correlation key
    key = row.key(indices=self.correlation_indices)

    # Record the locations
    # key -&gt; value -&gt; location
    for i in indices:
        tagspec = row.columns[i].get_display_tag(sort_attributes=True)
        if i &lt; len(row.values) and not hxl.datatypes.is_empty(row.values[i]):
            value = row.values[i]
            column = row.columns[i]
            self.correlation_map.setdefault(tagspec, {}).setdefault(key, {}).setdefault(value, []).append((row, column,))

    # always succeed
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_cell" href="#hxl.validation.AbstractRuleTest.validate_cell">validate_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.DatatypeTest"><code class="flex name class">
<span>class <span class="ident">DatatypeTest</span></span>
<span>(</span><span>datatype)</span>
</code></dt>
<dd>
<div class="desc"><p>Test for a specified datatype
HXL schema: #valid_datatype-consistent
See also ConsistentDatatypeTest, which infers the most-common datatype.</p>
<p>Constructor
@param datatype: a string specifying the datatype (e.g. "number")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatatypeTest(AbstractRuleTest):
    &#34;&#34;&#34;Test for a specified datatype
    HXL schema: #valid_datatype-consistent
    See also ConsistentDatatypeTest, which infers the most-common datatype.
    &#34;&#34;&#34;

    # allowed datatypes
    DATATYPES = (&#39;text&#39;, &#39;number&#39;, &#39;url&#39;, &#39;email&#39;, &#39;phone&#39;, &#39;date&#39;,)

    def __init__(self, datatype):
        &#34;&#34;&#34;Constructor
        @param datatype: a string specifying the datatype (e.g. &#34;number&#34;)
        &#34;&#34;&#34;
        super().__init__()
        # make sure we recognise the datatype
        datatype = hxl.datatypes.normalise_string(datatype)
        if datatype in DatatypeTest.DATATYPES:
            self.datatype = datatype
        else:
            raise hxl.HXLException(&#34;Unsupported datatype: {}&#34;.format(datatype))

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Validate datatypes on the individual cell level&#34;&#34;&#34;
        status = True
        def report(message):
            return self.report_error(
                message,
                value=value,
                row=row,
                column=column
            )
        
        if self.datatype == &#39;number&#39;:
            if not hxl.datatypes.is_number(value):
                status = report(&#34;Expected a number&#34;)
        elif self.datatype == &#39;url&#39;:
            pieces = urllib.parse.urlparse(value)
            if not (pieces.scheme and pieces.netloc):
                status = report(&#34;Expected a URL&#34;)
        elif self.datatype == &#39;email&#39;:
            if not re.match(r&#39;^[^@]+@[^@]+$&#39;, value):
                status = report(&#34;Expected an email address&#34;)
        elif self.datatype == &#39;phone&#39;:
            if not re.match(r&#39;^\+?[0-9xX()\s-]{5,}$&#39;, value):
                status= report(&#34;Expected a phone number&#34;)
        elif self.datatype == &#39;date&#39;:
            if not hxl.datatypes.is_date(value):
                status = report(&#34;Expected a date&#34;)
        return status</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hxl.validation.DatatypeTest.DATATYPES"><code class="name">var <span class="ident">DATATYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.DatatypeTest.validate_cell"><code class="name flex">
<span>def <span class="ident">validate_cell</span></span>(<span>self, value, row, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate datatypes on the individual cell level</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_cell(self, value, row, column):
    &#34;&#34;&#34;Validate datatypes on the individual cell level&#34;&#34;&#34;
    status = True
    def report(message):
        return self.report_error(
            message,
            value=value,
            row=row,
            column=column
        )
    
    if self.datatype == &#39;number&#39;:
        if not hxl.datatypes.is_number(value):
            status = report(&#34;Expected a number&#34;)
    elif self.datatype == &#39;url&#39;:
        pieces = urllib.parse.urlparse(value)
        if not (pieces.scheme and pieces.netloc):
            status = report(&#34;Expected a URL&#34;)
    elif self.datatype == &#39;email&#39;:
        if not re.match(r&#39;^[^@]+@[^@]+$&#39;, value):
            status = report(&#34;Expected an email address&#34;)
    elif self.datatype == &#39;phone&#39;:
        if not re.match(r&#39;^\+?[0-9xX()\s-]{5,}$&#39;, value):
            status= report(&#34;Expected a phone number&#34;)
    elif self.datatype == &#39;date&#39;:
        if not hxl.datatypes.is_date(value):
            status = report(&#34;Expected a date&#34;)
    return status</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.EnumerationTest"><code class="flex name class">
<span>class <span class="ident">EnumerationTest</span></span>
<span>(</span><span>allowed_values, case_sensitive=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Test against a list of enumerated values
HXL schema: #valid_value+list #valid_value+url #valid_value+case
This test can also hold an extra error to report if there was a problem
e.g. reading the values externally.</p>
<p>Constructor
@param allowed_values: sequence of allowed values
@param case_sensitive: if True, make comparisons case-sensitive</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumerationTest(AbstractRuleTest):
    &#34;&#34;&#34;Test against a list of enumerated values 
    HXL schema: #valid_value+list #valid_value+url #valid_value+case
    This test can also hold an extra error to report if there was a problem
    e.g. reading the values externally.
    &#34;&#34;&#34;

    def __init__(self, allowed_values, case_sensitive=False):
        &#34;&#34;&#34;Constructor
        @param allowed_values: sequence of allowed values
        @param case_sensitive: if True, make comparisons case-sensitive
        &#34;&#34;&#34;
        super().__init__()
        self.case_sensitive = case_sensitive
        self.setup_tables(allowed_values)

    def setup_tables(self, allowed_values):
        self.suggested_value_cache = dict()
        self.cooked_value_set = set()

        if self.case_sensitive:
            for raw_value in allowed_values:
                raw_value = hxl.datatypes.normalise_space(raw_value)
                self.cooked_value_set.add(raw_value)
        else:
            self.raw_value_map = dict()
            for raw_value in allowed_values:
                raw_value = hxl.datatypes.normalise_space(raw_value)
                cooked_value = hxl.datatypes.normalise_string(raw_value)
                self.cooked_value_set.add(cooked_value)
                self.raw_value_map[cooked_value] = raw_value

    def validate_cell(self, value, row, column):
        if self.case_sensitive:
            cooked_value = hxl.datatypes.normalise_space(value)
        else:
            cooked_value = hxl.datatypes.normalise_string(value)

        if cooked_value in self.cooked_value_set:
            return True
        else:
            suggested_value = self.get_suggested_value(cooked_value)
            return self.report_error(
                &#34;Value not allowed&#34;,
                value=value,
                row=row,
                column=column,
                suggested_value=suggested_value
            )

    def get_suggested_value(self, value):
        # try the cache first
        suggested_value = self.suggested_value_cache.get(value, False) # False to allow for None values
        if suggested_value is False:
            suggested_value = find_closest_match(value, self.cooked_value_set)
            if suggested_value is not None and not self.case_sensitive:
                # we need the original character case if case-insensitive
                suggested_value = self.raw_value_map[suggested_value]
            self.suggested_value_cache[value] = suggested_value
        return suggested_value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.EnumerationTest.get_suggested_value"><code class="name flex">
<span>def <span class="ident">get_suggested_value</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_suggested_value(self, value):
    # try the cache first
    suggested_value = self.suggested_value_cache.get(value, False) # False to allow for None values
    if suggested_value is False:
        suggested_value = find_closest_match(value, self.cooked_value_set)
        if suggested_value is not None and not self.case_sensitive:
            # we need the original character case if case-insensitive
            suggested_value = self.raw_value_map[suggested_value]
        self.suggested_value_cache[value] = suggested_value
    return suggested_value</code></pre>
</details>
</dd>
<dt id="hxl.validation.EnumerationTest.setup_tables"><code class="name flex">
<span>def <span class="ident">setup_tables</span></span>(<span>self, allowed_values)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_tables(self, allowed_values):
    self.suggested_value_cache = dict()
    self.cooked_value_set = set()

    if self.case_sensitive:
        for raw_value in allowed_values:
            raw_value = hxl.datatypes.normalise_space(raw_value)
            self.cooked_value_set.add(raw_value)
    else:
        self.raw_value_map = dict()
        for raw_value in allowed_values:
            raw_value = hxl.datatypes.normalise_space(raw_value)
            cooked_value = hxl.datatypes.normalise_string(raw_value)
            self.cooked_value_set.add(cooked_value)
            self.raw_value_map[cooked_value] = raw_value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_cell" href="#hxl.validation.AbstractRuleTest.validate_cell">validate_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.HXLValidationException"><code class="flex name class">
<span>class <span class="ident">HXLValidationException</span></span>
<span>(</span><span>message, rule=None, value=None, row=None, column=None, suggested_value=None, scope='cell', is_external=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Data structure to hold a HXL validation error.</p>
<p>Normally, this exception isn't thrown, but is passed as a
parameter to callbacks via Schema, SchemaRule, and classes
extending AbstractRuleTest.</p>
<p>Construct a new validation error report.
@param message: the text message for the error
@param rule: the rule associated with the error (it may have a more-general descriptive message)
@param value: the value that triggered the error, if available
@param row: the hxl.model.Row object associated with the error, if any
@param column: the hxl.model.Column object associated with the error, if any
@param suggested_value: the suggested replacement value, if known
@param scope: the error scope (dataset, column, row, or cell)
@param is_external: if True, the error is external to the data itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HXLValidationException(hxl.HXLException):
    &#34;&#34;&#34;Data structure to hold a HXL validation error.

    Normally, this exception isn&#39;t thrown, but is passed as a
    parameter to callbacks via Schema, SchemaRule, and classes
    extending AbstractRuleTest.
    &#34;&#34;&#34;

    SCOPES = (&#39;dataset&#39;, &#39;column&#39;, &#39;row&#39;, &#39;cell&#39;,)
    &#34;&#34;&#34;Allowed values for the error scope&#34;&#34;&#34;

    def __init__(self, message, rule=None, value=None, row=None, column=None, suggested_value=None, scope=&#39;cell&#39;, is_external=False):
        &#34;&#34;&#34;Construct a new validation error report.
        @param message: the text message for the error
        @param rule: the rule associated with the error (it may have a more-general descriptive message)
        @param value: the value that triggered the error, if available
        @param row: the hxl.model.Row object associated with the error, if any
        @param column: the hxl.model.Column object associated with the error, if any
        @param suggested_value: the suggested replacement value, if known
        @param scope: the error scope (dataset, column, row, or cell)
        @param is_external: if True, the error is external to the data itself
        &#34;&#34;&#34;
        super().__init__(message)
        
        self.rule = rule
        self.value = value
        self.row = row
        self.column = column
        self.suggested_value = suggested_value
        self.is_external = is_external

        scope = hxl.datatypes.normalise_string(scope)
        if scope in HXLValidationException.SCOPES:
            self.scope = scope
        else:
            raise hxl.HXLException(&#34;Unrecognised validation-error scope: {}&#34;.format(scope))

    def __str__(self):
        &#34;&#34;&#34;Get a string rendition of this error.&#34;&#34;&#34;
        s = &#39;&lt;HXLValidationException &#39;
        if self.message:
            s += self.message + &#39; &#39;
        if self.rule:
            if self.rule.tag_pattern:
                if self.value:
                    s += &#39;{}={} &#39;.format(str(self.rule.tag_pattern), str(self.value))
                else:
                    s += &#39;{} &#39;.format(str(self.rule.tag_pattern))
            if self.message:
                s += &#39;- {}&#39;.format(self.message)
        return s</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.HXLException" href="index.html#hxl.HXLException">HXLException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hxl.validation.HXLValidationException.SCOPES"><code class="name">var <span class="ident">SCOPES</span></code></dt>
<dd>
<div class="desc"><p>Allowed values for the error scope</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.HXLException" href="index.html#hxl.HXLException">HXLException</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.HXLException.data" href="index.html#hxl.HXLException.data">data</a></code></li>
<li><code><a title="hxl.HXLException.message" href="index.html#hxl.HXLException.message">message</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.NumericOutlierTest"><code class="flex name class">
<span>class <span class="ident">NumericOutlierTest</span></span>
<span>(</span><span>callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Detect outliers among matching values
Will skip any tagset with a coefficient of variation &gt; 1.0</p>
<p>Set up a schema test.
@param callback: a callback function to receive error reports</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumericOutlierTest(AbstractRuleTest):
    &#34;&#34;&#34;Detect outliers among matching values
    Will skip any tagset with a coefficient of variation &gt; 1.0
    &#34;&#34;&#34;

    def needs_scan(self):
        return True

    def start(self):
        self.standard_deviations = dict()
        self.mean_values = dict()
        self.variation_coefficients = dict()
        self.values = dict()

    def scan_cell(self, value, row, column):
        tagspec = column.get_display_tag(sort_attributes=True) # FIXME
        try:
            num = hxl.datatypes.normalise_number(value)
            if not tagspec in self.values:
                self.values[tagspec] = list()
            self.values[tagspec].append(num)
        except:
            # not a number, so ignore
            pass

    def end_scan(self):
        for tagspec in self.values:

            values = self.values[tagspec]

            # if the list is long enough, remove the min and max values
            if len(values) &gt;= 10: # 10 is our cutoff for removing lowest and highest values
                values = sorted(values)[1:-1]

            # now calculate the standard deviation of the remaining values
            self.mean_values[tagspec] = sum(values) / len(values)
            self.standard_deviations[tagspec] = math.sqrt(
                sum(map(lambda n: (n-self.mean_values[tagspec])*(n-self.mean_values[tagspec]), values)) / len(values)
            )

            # calculate the coefficient of variance, which we&#39;ll use as a cutoff
            if self.mean_values[tagspec]:
                self.variation_coefficients[tagspec] = self.standard_deviations[tagspec] / self.mean_values[tagspec]
            else:
                self.variation_coefficients[tagspec] = 0

        # free some memory
        del self.values

    def validate_cell(self, value, row, column):
        tagspec = column.get_display_tag(sort_attributes=True) # FIXME

        # don&#39;t bother if the data is highly variable
        if self.variation_coefficients.get(tagspec, 0.0) &gt; 1.0:
            return True

        # try numeric validation
        try:
            num = hxl.datatypes.normalise_number(value)
            distance = abs(num - self.mean_values[tagspec])
            if distance &gt; self.standard_deviations[tagspec] * 3:
                self.report_error(
                    &#34;Possible numeric outlier&#34;,
                    value=value,
                    row=row,
                    column=column
                )
                return False
        except:
            # not a number, so ignore
            pass
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_cell" href="#hxl.validation.AbstractRuleTest.validate_cell">validate_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.RangeTest"><code class="flex name class">
<span>class <span class="ident">RangeTest</span></span>
<span>(</span><span>min_value=None, max_value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Test for a range of numbers or strings
HXL schema: #valid_value+min and #valid_value+max
This class will try to determine whether to use date sorting, numeric sorting, or lexical sorting
to determine what is within a range. Ranges are always case-insensitive</p>
<p>Constructor
@param min_value: the minimum allowed value, or None for no minimum
@param max_value: the maximum allowed value, or None for no maximum</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RangeTest(AbstractRuleTest):
    &#34;&#34;&#34;Test for a range of numbers or strings
    HXL schema: #valid_value+min and #valid_value+max
    This class will try to determine whether to use date sorting, numeric sorting, or lexical sorting
    to determine what is within a range. Ranges are always case-insensitive
    &#34;&#34;&#34;

    def __init__(self, min_value=None, max_value=None):
        &#34;&#34;&#34;Constructor
        @param min_value: the minimum allowed value, or None for no minimum
        @param max_value: the maximum allowed value, or None for no maximum
        &#34;&#34;&#34;
        super().__init__()

        # normalise strings
        if min_value is not None:
            self.min_value = hxl.datatypes.normalise_string(min_value)
        else:
            self.min_value = None
        if max_value is not None:
            self.max_value = hxl.datatypes.normalise_string(max_value)
        else:
            self.max_value = None

        # precompile numbers and dates for efficiency
        try:
            self.min_num = hxl.datatypes.normalise_number(min_value)
        except ValueError:
            self.min_num = None

        try:
            self.max_num = hxl.datatypes.normalise_number(max_value)
        except ValueError:
            self.max_num = None

        try:
            self.min_date = hxl.datatypes.normalise_date(min_value)
        except ValueError:
            self.min_date = None

        try:
            self.max_date = hxl.datatypes.normalise_date(max_value)
        except ValueError:
            self.max_date = None

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Test that a value is &gt;= min_value and/or &lt;= max_value
        Includes special handling for numbers and dates.
        &#34;&#34;&#34;
        def report(message):
            return self.report_error(
                message,
                value=value,
                row=row,
                column=column
            )

        # try as a date
        if column.tag == &#39;#date&#39; and (self.min_date is not None or self.max_date is not None):
            try:
                date_value = hxl.datatypes.normalise_date(value)
                if self.min_date is not None and date_value &lt; self.min_date:
                    return report(&#39;Date must not be before {}&#39;.format(self.min_date))
                elif self.max_date is not None and date_value &gt; self.max_date:
                    return report(&#39;Date must not be after {}&#39;.format(self.max_date))
                else:
                    return True
            except ValueError:
                pass # OK

        # try as a number
        if self.min_num is not None or self.max_num is not None:
            try:
                num_value = hxl.datatypes.normalise_number(value)
                if self.min_num is not None and num_value &lt; self.min_num:
                    return report(&#39;Value must not be less than {}&#39;.format(self.min_num))
                elif self.max_num is not None and num_value &gt; self.max_num:
                    return report(&#39;Value must not be more than {}&#39;.format(self.max_num))
                else:
                    return True
            except ValueError:
                pass # OK

        # try as a case-/whitespace-normalised string
        norm_value = hxl.datatypes.normalise_string(value)
        if self.min_value is not None and norm_value &lt; self.min_value:
            return report(&#39;Value must not come before {}&#39;.format(self.min_value))
        elif self.max_value is not None and norm_value &gt; self.max_value:
            return report(&#39;Value must not come after {}&#39;.format(self.max_value))
        else:
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.RangeTest.validate_cell"><code class="name flex">
<span>def <span class="ident">validate_cell</span></span>(<span>self, value, row, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that a value is &gt;= min_value and/or &lt;= max_value
Includes special handling for numbers and dates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_cell(self, value, row, column):
    &#34;&#34;&#34;Test that a value is &gt;= min_value and/or &lt;= max_value
    Includes special handling for numbers and dates.
    &#34;&#34;&#34;
    def report(message):
        return self.report_error(
            message,
            value=value,
            row=row,
            column=column
        )

    # try as a date
    if column.tag == &#39;#date&#39; and (self.min_date is not None or self.max_date is not None):
        try:
            date_value = hxl.datatypes.normalise_date(value)
            if self.min_date is not None and date_value &lt; self.min_date:
                return report(&#39;Date must not be before {}&#39;.format(self.min_date))
            elif self.max_date is not None and date_value &gt; self.max_date:
                return report(&#39;Date must not be after {}&#39;.format(self.max_date))
            else:
                return True
        except ValueError:
            pass # OK

    # try as a number
    if self.min_num is not None or self.max_num is not None:
        try:
            num_value = hxl.datatypes.normalise_number(value)
            if self.min_num is not None and num_value &lt; self.min_num:
                return report(&#39;Value must not be less than {}&#39;.format(self.min_num))
            elif self.max_num is not None and num_value &gt; self.max_num:
                return report(&#39;Value must not be more than {}&#39;.format(self.max_num))
            else:
                return True
        except ValueError:
            pass # OK

    # try as a case-/whitespace-normalised string
    norm_value = hxl.datatypes.normalise_string(value)
    if self.min_value is not None and norm_value &lt; self.min_value:
        return report(&#39;Value must not come before {}&#39;.format(self.min_value))
    elif self.max_value is not None and norm_value &gt; self.max_value:
        return report(&#39;Value must not come after {}&#39;.format(self.max_value))
    else:
        return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.RegexTest"><code class="flex name class">
<span>class <span class="ident">RegexTest</span></span>
<span>(</span><span>regex, case_sensitive=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that non-empty values match a regular expression
HXL schema: #valid_value+regex
The regex is unanchored, so use '^' or '$' to anchor if needed
Whitespace is not normalised before matching</p>
<p>Constructor
@param regex: the regular expression to test against
@param case_sensitive: if True (default), matches are case-sensitive</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegexTest(AbstractRuleTest):
    &#34;&#34;&#34;Test that non-empty values match a regular expression 
    HXL schema: #valid_value+regex
    The regex is unanchored, so use &#39;^&#39; or &#39;$&#39; to anchor if needed
    Whitespace is not normalised before matching
    &#34;&#34;&#34;

    def __init__(self, regex, case_sensitive=True):
        &#34;&#34;&#34;Constructor
        @param regex: the regular expression to test against
        @param case_sensitive: if True (default), matches are case-sensitive
        &#34;&#34;&#34;
        super().__init__()
        self.regex_text = str(regex)
        if case_sensitive:
            self.regex = re.compile(regex)
        else:
            self.regex = re.compile(regex, flags=re.IGNORECASE)

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Match value (including whitespace) against the regular expression&#34;&#34;&#34;
        if self.regex.search(value):
            return True
        else:
            return self.report_error(
                &#39;Should match regular expression /{}/&#39;.format(self.regex_text),
                value=value,
                row=row,
                column=column
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.RegexTest.validate_cell"><code class="name flex">
<span>def <span class="ident">validate_cell</span></span>(<span>self, value, row, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Match value (including whitespace) against the regular expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_cell(self, value, row, column):
    &#34;&#34;&#34;Match value (including whitespace) against the regular expression&#34;&#34;&#34;
    if self.regex.search(value):
        return True
    else:
        return self.report_error(
            &#39;Should match regular expression /{}/&#39;.format(self.regex_text),
            value=value,
            row=row,
            column=column
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.RequiredTest"><code class="flex name class">
<span>class <span class="ident">RequiredTest</span></span>
<span>(</span><span>min_occurs=None, max_occurs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Test min/max occurrence
HXL schema: #valid_required
If the columns don't exist at all, report only a single error.
Otherwise, report an error for each row where the test fails.</p>
<p>Constructor
@param min: minimum occurrence required (or None)
@param max: maximum occurrence allowed (or None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RequiredTest(AbstractRuleTest):
    &#34;&#34;&#34;Test min/max occurrence
    HXL schema: #valid_required
    If the columns don&#39;t exist at all, report only a single error.
    Otherwise, report an error for each row where the test fails.
    &#34;&#34;&#34;

    def __init__(self, min_occurs=None, max_occurs=None):
        &#34;&#34;&#34;Constructor
        @param min: minimum occurrence required (or None)
        @param max: maximum occurrence allowed (or None)
        &#34;&#34;&#34;
        super().__init__()
        self.min_occurs = min_occurs
        self.max_occurs = max_occurs
        self.test_rows = True

    def start(self):
        self.test_rows = True

    def validate_dataset(self, dataset, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Verify that we have enough matching columns to satisfy the test&#34;&#34;&#34;
        status = True
        indices = self.get_indices(indices, tag_pattern, dataset.columns)
        if self.min_occurs is not None and len(indices) &lt; self.min_occurs:
            self.test_rows = False # no point testing individual rows
            status = self.report_error(
                &#34;Expected at least {} matching column(s)&#34;.format(self.min_occurs),
                scope=&#39;dataset&#39;
            )
        return status

    def validate_row(self, row, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Check the number of non-empty occurrences in a row.&#34;&#34;&#34;
        if not self.test_rows: # skip if there aren&#39;t enough columns
            return
        status = True
        indices = self.get_indices(indices, tag_pattern, row.columns)

        non_empty_count = 0
        first_empty_column = None
        last_nonempty_column = None

        # iterate through all values in matching columns
        for i in indices:
            if i &gt;= len(row.values) or hxl.datatypes.is_empty(row.values[i]):
                if first_empty_column is None:
                    first_empty_column = row.columns[i]
            else:
                non_empty_count += 1
                last_nonempty_column = row.columns[i]

        if self.min_occurs is not None and non_empty_count &lt; self.min_occurs:
            status = self.report_error(
                &#34;Expected at least {} matching non-empty value(s)&#34;.format(self.min_occurs),
                row=row,
                column=first_empty_column,
                scope=&#39;row&#39;
            )

        if self.max_occurs is not None and non_empty_count &gt; self.max_occurs:
            status = self.report_error(
                &#34;Expected at most {} matching non-empty value(s)&#34;.format(self.max_occurs),
                row=row,
                column=last_nonempty_column,
                scope=&#39;row&#39;
            )

        return status</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.RequiredTest.validate_dataset"><code class="name flex">
<span>def <span class="ident">validate_dataset</span></span>(<span>self, dataset, indices=None, tag_pattern=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify that we have enough matching columns to satisfy the test</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_dataset(self, dataset, indices=None, tag_pattern=None):
    &#34;&#34;&#34;Verify that we have enough matching columns to satisfy the test&#34;&#34;&#34;
    status = True
    indices = self.get_indices(indices, tag_pattern, dataset.columns)
    if self.min_occurs is not None and len(indices) &lt; self.min_occurs:
        self.test_rows = False # no point testing individual rows
        status = self.report_error(
            &#34;Expected at least {} matching column(s)&#34;.format(self.min_occurs),
            scope=&#39;dataset&#39;
        )
    return status</code></pre>
</details>
</dd>
<dt id="hxl.validation.RequiredTest.validate_row"><code class="name flex">
<span>def <span class="ident">validate_row</span></span>(<span>self, row, indices=None, tag_pattern=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Check the number of non-empty occurrences in a row.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_row(self, row, indices=None, tag_pattern=None):
    &#34;&#34;&#34;Check the number of non-empty occurrences in a row.&#34;&#34;&#34;
    if not self.test_rows: # skip if there aren&#39;t enough columns
        return
    status = True
    indices = self.get_indices(indices, tag_pattern, row.columns)

    non_empty_count = 0
    first_empty_column = None
    last_nonempty_column = None

    # iterate through all values in matching columns
    for i in indices:
        if i &gt;= len(row.values) or hxl.datatypes.is_empty(row.values[i]):
            if first_empty_column is None:
                first_empty_column = row.columns[i]
        else:
            non_empty_count += 1
            last_nonempty_column = row.columns[i]

    if self.min_occurs is not None and non_empty_count &lt; self.min_occurs:
        status = self.report_error(
            &#34;Expected at least {} matching non-empty value(s)&#34;.format(self.min_occurs),
            row=row,
            column=first_empty_column,
            scope=&#39;row&#39;
        )

    if self.max_occurs is not None and non_empty_count &gt; self.max_occurs:
        status = self.report_error(
            &#34;Expected at most {} matching non-empty value(s)&#34;.format(self.max_occurs),
            row=row,
            column=last_nonempty_column,
            scope=&#39;row&#39;
        )

    return status</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_cell" href="#hxl.validation.AbstractRuleTest.validate_cell">validate_cell</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.Schema"><code class="flex name class">
<span>class <span class="ident">Schema</span></span>
<span>(</span><span>callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Schema against which to validate a HXL document.
Consists of a sequence of L{SchemaRule} objects to apply to the data.</p>
<p>The validate() method triggers the following:</p>
<ul>
<li>start()</li>
<li>validate_dataset()</li>
<li>validate_row() for each row</li>
<li>validate_cell() for each matching non-empty cell in each row</li>
<li>end()</li>
</ul>
<p>Add new rules with</p>
<pre><code>schema.rules.append(rule)
</code></pre>
<p>Constructor
@param callback: a callback function to receive HXLValidationException objects as error reports</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Schema(object):
    &#34;&#34;&#34;Schema against which to validate a HXL document.
    Consists of a sequence of L{SchemaRule} objects to apply to the data.

    The validate() method triggers the following:

    - start()
    - validate_dataset()
    - validate_row() for each row
    - validate_cell() for each matching non-empty cell in each row
    - end()

    Add new rules with

        schema.rules.append(rule)
    &#34;&#34;&#34;

    def __init__(self, callback=None):
        &#34;&#34;&#34;Constructor
        @param callback: a callback function to receive HXLValidationException objects as error reports
        &#34;&#34;&#34;
        self.rules = []
        &#34;&#34;&#34;Rules making up this schema&#34;&#34;&#34;
        
        self.callback = callback
        &#34;&#34;&#34;Callback function to receive error reports&#34;&#34;&#34;

    def validate(self, source):
        &#34;&#34;&#34;Execute the main validation workflow.
        @param source: the hxl.model.Dataset to validate
        &#34;&#34;&#34;
        status = True # all is well at the beginning
        needs_scan = False # assume we don&#39;t need a pre-scan

        # do we need a cached, in-memory dataset?
        for rule in self.rules:
            if rule.needs_scan():
                needs_scan = True
                if not source.is_cached:
                    source = source.cache()
                break

        # initial setup
        self.start()

        # pre-scan if needed
        if needs_scan:
            for row in source:
                self.scan_row(row)
            self.end_scan()

        # dataset-level validations
        if not self.validate_dataset(source):
            status = False

        # row-level validations
        # (will also include cell-level validations)
        for row in source:
            if not self.validate_row(row):
                status = False

        # finalisation
        if not self.end():
            status = False
            
        return status

    def start(self):
        &#34;&#34;&#34;Initialise the validation run&#34;&#34;&#34;

        def rule_callback(e):
            &#34;&#34;&#34;Relay rule callbacks&#34;&#34;&#34;
            if self.callback:
                self.callback(e)
                
        for rule in self.rules:
            rule.callback = rule_callback
            rule.start()

    def end(self):
        &#34;&#34;&#34;Terminate the validation run&#34;&#34;&#34;
        status = True
        for rule in self.rules:
            if not rule.end():
                status = False
        return status

    def scan_row(self, row):
        &#34;&#34;&#34;Pre-scan a row, only for rules that require it.&#34;&#34;&#34;
        for rule in self.rules:
            if rule.needs_scan():
                rule.scan_row(row)

    def end_scan(self):
        &#34;&#34;&#34;End pre-scan, for rules that require it.&#34;&#34;&#34;
        for rule in self.rules:
            if rule.needs_scan():
                rule.end_scan()

    def validate_dataset(self, dataset):
        &#34;&#34;&#34;Validate just at the dataset level
        @param dataset: the hxl.model.Dataset object to validate
        &#34;&#34;&#34;
        status = True
        for rule in self.rules:
            if not rule.validate_dataset(dataset):
                status = False
        return status

    def validate_row(self, row):
        &#34;&#34;&#34;Validate at the row and cell levels.
        Each rule will handle cell-level validation on its own,
        because it knows what columns to look at.
        @param row: the row to validate
        &#34;&#34;&#34;
        status = True
        for rule in self.rules:
            if not rule.validate_row(row):
                status = False
        return status

    def __str__(self):
        &#34;&#34;&#34;String representation of a schema (for debugging)&#34;&#34;&#34;
        s = &#34;&lt;HXL schema\n&#34;
        for rule in self.rules:
            s += &#34;  &#34; + str(rule) + &#34;\n&#34;
        s += &#34;&gt;&#34;
        return s

    @staticmethod
    def parse(source=None, callback=None):
        &#34;&#34;&#34; Load a HXL schema from the provided input stream, or load default schema.
        @param source: HXL data source for the scheme (e.g. a HXLReader or filter); defaults to the built-in schema
        @param callback: a callback function for reporting errors (receives a HXLValidationException)
        &#34;&#34;&#34;

        # Catch special cases

        if source is None:
            # Use the built-in default schema and recurse
            path = os.path.join(os.path.dirname(__file__), &#39;hxl-default-schema.json&#39;);
            with hxl.data(path, hxl.InputOptions(allow_local=True)) as source:
                return Schema.parse(source, callback)

        if isinstance(source, Schema):
            # Already a schema; set the callback and return it
            source.callback = callback
            return source

        if not isinstance(source, hxl.model.Dataset):
            # Not already a dataset, so wrap it and recurse
            with hxl.data(source) as source:
                return Schema.parse(source, callback)

        # Main parsing

        schema = Schema(callback=callback)

        def parse_type(type):
            if type:
                type = type.lower()
                type = re.sub(r&#39;[^a-z_-]&#39;, &#39;&#39;, type) # normalise
            if type in SchemaRule.DATATYPES:
                return type
            else:
                return None

        def to_int(s):
            if s:
                return int(s)
            else:
                return None

        def to_float(s):
            if s:
                return float(s)
            else:
                return None

        def to_boolean(s):
            if not s or s.lower() in [&#39;0&#39;, &#39;n&#39;, &#39;no&#39;, &#39;f&#39;, &#39;false&#39;]:
                return False
            elif s.lower() in [&#39;y&#39;, &#39;yes&#39;, &#39;t&#39;, &#39;true&#39;]:
                return True
            else:
                raise hxl.HXLException(&#39;Unrecognised true/false value: {}&#39;.format(s))


        for row in source:
            tags = row.get(&#39;#valid_tag&#39;)
            if tags:
                tag_patterns = hxl.model.TagPattern.parse_list(tags)
                for tag_pattern in tag_patterns:
                    rule = SchemaRule(tag_pattern)
                    rule.severity = row.get(&#39;#valid_severity&#39;) or &#39;error&#39;
                    rule.description = row.get(&#39;#description&#39;)

                    # for later use
                    case_sensitive = to_boolean(row.get(&#39;#valid_value+case&#39;))

                    if to_boolean(row.get(&#39;#valid_required-min-max&#39;)):
                        rule.tests.append(RequiredTest(min_occurs=1, max_occurs=None))

                    min_occurs = to_int(row.get(&#39;#valid_required+min&#39;))
                    max_occurs = to_int(row.get(&#39;#valid_required+max&#39;))
                    if min_occurs is not None or max_occurs is not None:
                        rule.tests.append(RequiredTest(min_occurs=min_occurs, max_occurs=max_occurs))

                    datatype = row.get(&#39;#valid_datatype-consistent&#39;)
                    if datatype is not None:
                        rule.tests.append(DatatypeTest(datatype))

                    min_value = row.get(&#39;#valid_value+min&#39;)
                    max_value = row.get(&#39;#valid_value+max&#39;)
                    if min_value is not None or max_value is not None:
                        rule.tests.append(RangeTest(min_value=min_value, max_value=max_value))

                    if to_boolean(row.get(&#39;#valid_value+whitespace&#39;)):
                        rule.tests.append(WhitespaceTest())

                    regex = row.get(&#39;#valid_value+regex&#39;)
                    if regex is not None:
                        rule.tests.append(RegexTest(regex, case_sensitive))

                    if to_boolean(row.get(&#39;#valid_value+spelling&#39;)):
                        rule.tests.append(SpellingTest(case_sensitive=case_sensitive))

                    if to_boolean(row.get(&#39;#valid_unique-key&#39;)):
                        rule.tests.append(UniqueValueTest())

                    key = row.get(&#39;#valid_unique+key&#39;)
                    if hxl.datatypes.is_truthy(key):
                        # could be problematic if there&#39;s even a hashtag like #true or #yes
                        rule.tests.append(UniqueRowTest())
                    elif not hxl.datatypes.is_empty(key):
                        rule.tests.append(UniqueRowTest(key))

                    correlations = row.get(&#39;#valid_correlation&#39;)
                    if not hxl.datatypes.is_empty(correlations):
                        rule.tests.append(CorrelationTest(correlations))

                    if to_boolean(row.get(&#39;#valid_datatype+consistent&#39;)):
                        rule.tests.append(ConsistentDatatypesTest())

                    if to_boolean(row.get(&#39;#valid_value+outliers&#39;)):
                        rule.tests.append(NumericOutlierTest())

                    l = row.get(&#39;#valid_value+list&#39;)
                    if not hxl.datatypes.is_empty(l):
                        allowed_values = re.split(r&#39;\s*\|\s*&#39;, l)
                        if len(allowed_values) &gt; 0:
                            rule.tests.append(EnumerationTest(allowed_values, case_sensitive))

                    url = row.get(&#39;#valid_value+url&#39;)
                    if not hxl.datatypes.is_empty(url):
                        # default the target tag to the #valid_tag
                        target_tag = row.get(&#39;#valid_value+target_tag&#39;, default=tag_pattern)
                        try:
                            # read the values from an external dataset
                            source = hxl.data(url)
                            allowed_values = source.get_value_set(row.get(&#39;#valid_value+target_tag&#39;))
                            if len(allowed_values) &gt; 0:
                                rule.tests.append(EnumerationTest(allowed_values, case_sensitive))
                        except BaseException as error:
                            # don&#39;t add the test to the rule
                            # do add an error about loading the values
                            rule.external_errors.append(HXLValidationException(
                                &#39;Error loading allowed values from {}: {}&#39;.format(url, error.args[0]),
                                scope=&#39;dataset&#39;,
                                rule=rule,
                                is_external=True
                            ))


                    schema.rules.append(rule)

        return schema</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="hxl.validation.Schema.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>source=None, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a HXL schema from the provided input stream, or load default schema.
@param source: HXL data source for the scheme (e.g. a HXLReader or filter); defaults to the built-in schema
@param callback: a callback function for reporting errors (receives a HXLValidationException)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(source=None, callback=None):
    &#34;&#34;&#34; Load a HXL schema from the provided input stream, or load default schema.
    @param source: HXL data source for the scheme (e.g. a HXLReader or filter); defaults to the built-in schema
    @param callback: a callback function for reporting errors (receives a HXLValidationException)
    &#34;&#34;&#34;

    # Catch special cases

    if source is None:
        # Use the built-in default schema and recurse
        path = os.path.join(os.path.dirname(__file__), &#39;hxl-default-schema.json&#39;);
        with hxl.data(path, hxl.InputOptions(allow_local=True)) as source:
            return Schema.parse(source, callback)

    if isinstance(source, Schema):
        # Already a schema; set the callback and return it
        source.callback = callback
        return source

    if not isinstance(source, hxl.model.Dataset):
        # Not already a dataset, so wrap it and recurse
        with hxl.data(source) as source:
            return Schema.parse(source, callback)

    # Main parsing

    schema = Schema(callback=callback)

    def parse_type(type):
        if type:
            type = type.lower()
            type = re.sub(r&#39;[^a-z_-]&#39;, &#39;&#39;, type) # normalise
        if type in SchemaRule.DATATYPES:
            return type
        else:
            return None

    def to_int(s):
        if s:
            return int(s)
        else:
            return None

    def to_float(s):
        if s:
            return float(s)
        else:
            return None

    def to_boolean(s):
        if not s or s.lower() in [&#39;0&#39;, &#39;n&#39;, &#39;no&#39;, &#39;f&#39;, &#39;false&#39;]:
            return False
        elif s.lower() in [&#39;y&#39;, &#39;yes&#39;, &#39;t&#39;, &#39;true&#39;]:
            return True
        else:
            raise hxl.HXLException(&#39;Unrecognised true/false value: {}&#39;.format(s))


    for row in source:
        tags = row.get(&#39;#valid_tag&#39;)
        if tags:
            tag_patterns = hxl.model.TagPattern.parse_list(tags)
            for tag_pattern in tag_patterns:
                rule = SchemaRule(tag_pattern)
                rule.severity = row.get(&#39;#valid_severity&#39;) or &#39;error&#39;
                rule.description = row.get(&#39;#description&#39;)

                # for later use
                case_sensitive = to_boolean(row.get(&#39;#valid_value+case&#39;))

                if to_boolean(row.get(&#39;#valid_required-min-max&#39;)):
                    rule.tests.append(RequiredTest(min_occurs=1, max_occurs=None))

                min_occurs = to_int(row.get(&#39;#valid_required+min&#39;))
                max_occurs = to_int(row.get(&#39;#valid_required+max&#39;))
                if min_occurs is not None or max_occurs is not None:
                    rule.tests.append(RequiredTest(min_occurs=min_occurs, max_occurs=max_occurs))

                datatype = row.get(&#39;#valid_datatype-consistent&#39;)
                if datatype is not None:
                    rule.tests.append(DatatypeTest(datatype))

                min_value = row.get(&#39;#valid_value+min&#39;)
                max_value = row.get(&#39;#valid_value+max&#39;)
                if min_value is not None or max_value is not None:
                    rule.tests.append(RangeTest(min_value=min_value, max_value=max_value))

                if to_boolean(row.get(&#39;#valid_value+whitespace&#39;)):
                    rule.tests.append(WhitespaceTest())

                regex = row.get(&#39;#valid_value+regex&#39;)
                if regex is not None:
                    rule.tests.append(RegexTest(regex, case_sensitive))

                if to_boolean(row.get(&#39;#valid_value+spelling&#39;)):
                    rule.tests.append(SpellingTest(case_sensitive=case_sensitive))

                if to_boolean(row.get(&#39;#valid_unique-key&#39;)):
                    rule.tests.append(UniqueValueTest())

                key = row.get(&#39;#valid_unique+key&#39;)
                if hxl.datatypes.is_truthy(key):
                    # could be problematic if there&#39;s even a hashtag like #true or #yes
                    rule.tests.append(UniqueRowTest())
                elif not hxl.datatypes.is_empty(key):
                    rule.tests.append(UniqueRowTest(key))

                correlations = row.get(&#39;#valid_correlation&#39;)
                if not hxl.datatypes.is_empty(correlations):
                    rule.tests.append(CorrelationTest(correlations))

                if to_boolean(row.get(&#39;#valid_datatype+consistent&#39;)):
                    rule.tests.append(ConsistentDatatypesTest())

                if to_boolean(row.get(&#39;#valid_value+outliers&#39;)):
                    rule.tests.append(NumericOutlierTest())

                l = row.get(&#39;#valid_value+list&#39;)
                if not hxl.datatypes.is_empty(l):
                    allowed_values = re.split(r&#39;\s*\|\s*&#39;, l)
                    if len(allowed_values) &gt; 0:
                        rule.tests.append(EnumerationTest(allowed_values, case_sensitive))

                url = row.get(&#39;#valid_value+url&#39;)
                if not hxl.datatypes.is_empty(url):
                    # default the target tag to the #valid_tag
                    target_tag = row.get(&#39;#valid_value+target_tag&#39;, default=tag_pattern)
                    try:
                        # read the values from an external dataset
                        source = hxl.data(url)
                        allowed_values = source.get_value_set(row.get(&#39;#valid_value+target_tag&#39;))
                        if len(allowed_values) &gt; 0:
                            rule.tests.append(EnumerationTest(allowed_values, case_sensitive))
                    except BaseException as error:
                        # don&#39;t add the test to the rule
                        # do add an error about loading the values
                        rule.external_errors.append(HXLValidationException(
                            &#39;Error loading allowed values from {}: {}&#39;.format(url, error.args[0]),
                            scope=&#39;dataset&#39;,
                            rule=rule,
                            is_external=True
                        ))


                schema.rules.append(rule)

    return schema</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.validation.Schema.callback"><code class="name">var <span class="ident">callback</span></code></dt>
<dd>
<div class="desc"><p>Callback function to receive error reports</p></div>
</dd>
<dt id="hxl.validation.Schema.rules"><code class="name">var <span class="ident">rules</span></code></dt>
<dd>
<div class="desc"><p>Rules making up this schema</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.Schema.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terminate the validation run</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self):
    &#34;&#34;&#34;Terminate the validation run&#34;&#34;&#34;
    status = True
    for rule in self.rules:
        if not rule.end():
            status = False
    return status</code></pre>
</details>
</dd>
<dt id="hxl.validation.Schema.end_scan"><code class="name flex">
<span>def <span class="ident">end_scan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>End pre-scan, for rules that require it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_scan(self):
    &#34;&#34;&#34;End pre-scan, for rules that require it.&#34;&#34;&#34;
    for rule in self.rules:
        if rule.needs_scan():
            rule.end_scan()</code></pre>
</details>
</dd>
<dt id="hxl.validation.Schema.scan_row"><code class="name flex">
<span>def <span class="ident">scan_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Pre-scan a row, only for rules that require it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_row(self, row):
    &#34;&#34;&#34;Pre-scan a row, only for rules that require it.&#34;&#34;&#34;
    for rule in self.rules:
        if rule.needs_scan():
            rule.scan_row(row)</code></pre>
</details>
</dd>
<dt id="hxl.validation.Schema.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise the validation run</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;Initialise the validation run&#34;&#34;&#34;

    def rule_callback(e):
        &#34;&#34;&#34;Relay rule callbacks&#34;&#34;&#34;
        if self.callback:
            self.callback(e)
            
    for rule in self.rules:
        rule.callback = rule_callback
        rule.start()</code></pre>
</details>
</dd>
<dt id="hxl.validation.Schema.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self, source)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the main validation workflow.
@param source: the hxl.model.Dataset to validate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self, source):
    &#34;&#34;&#34;Execute the main validation workflow.
    @param source: the hxl.model.Dataset to validate
    &#34;&#34;&#34;
    status = True # all is well at the beginning
    needs_scan = False # assume we don&#39;t need a pre-scan

    # do we need a cached, in-memory dataset?
    for rule in self.rules:
        if rule.needs_scan():
            needs_scan = True
            if not source.is_cached:
                source = source.cache()
            break

    # initial setup
    self.start()

    # pre-scan if needed
    if needs_scan:
        for row in source:
            self.scan_row(row)
        self.end_scan()

    # dataset-level validations
    if not self.validate_dataset(source):
        status = False

    # row-level validations
    # (will also include cell-level validations)
    for row in source:
        if not self.validate_row(row):
            status = False

    # finalisation
    if not self.end():
        status = False
        
    return status</code></pre>
</details>
</dd>
<dt id="hxl.validation.Schema.validate_dataset"><code class="name flex">
<span>def <span class="ident">validate_dataset</span></span>(<span>self, dataset)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate just at the dataset level
@param dataset: the hxl.model.Dataset object to validate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_dataset(self, dataset):
    &#34;&#34;&#34;Validate just at the dataset level
    @param dataset: the hxl.model.Dataset object to validate
    &#34;&#34;&#34;
    status = True
    for rule in self.rules:
        if not rule.validate_dataset(dataset):
            status = False
    return status</code></pre>
</details>
</dd>
<dt id="hxl.validation.Schema.validate_row"><code class="name flex">
<span>def <span class="ident">validate_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate at the row and cell levels.
Each rule will handle cell-level validation on its own,
because it knows what columns to look at.
@param row: the row to validate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_row(self, row):
    &#34;&#34;&#34;Validate at the row and cell levels.
    Each rule will handle cell-level validation on its own,
    because it knows what columns to look at.
    @param row: the row to validate
    &#34;&#34;&#34;
    status = True
    for rule in self.rules:
        if not rule.validate_row(row):
            status = False
    return status</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hxl.validation.SchemaRule"><code class="flex name class">
<span>class <span class="ident">SchemaRule</span></span>
<span>(</span><span>tag_pattern, severity='error', description=None, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A single rule within a schema.
A rule contains one or more tests, together with some common metadata
(a tag pattern, severity level, and description). If any test fails, then
the whole rule fails.</p>
<p>Workflow (triggered by Schema.validate:</p>
<ul>
<li>needs_scan()</li>
<li>start()</li>
<li>scan_row() for each row (if needs_scan() returned True)</li>
<li>scan_cell() for each maching non-empty cell (if needs_scan() returned True)</li>
<li>end_scan() (if needs_scan() returned True)</li>
<li>validate_dataset()</li>
<li>validate_row() for each row</li>
<li>validate_cell() for each matching non-empty cell in each row</li>
<li>end()</li>
</ul>
<p>Constructor
@param tag_pattern: the tag pattern to match for the rule
@param severity: one of 'info', 'warning', or 'error' (default)
@param description: an optional error message to override the default from the tests
@param callback: an optional callback function to handle error reports</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SchemaRule(object):
    &#34;&#34;&#34;A single rule within a schema.
    A rule contains one or more tests, together with some common metadata
    (a tag pattern, severity level, and description). If any test fails, then
    the whole rule fails.

    Workflow (triggered by Schema.validate:

    - needs_scan()
    - start()
    - scan_row() for each row (if needs_scan() returned True)
    - scan_cell() for each maching non-empty cell (if needs_scan() returned True)
    - end_scan() (if needs_scan() returned True)
    - validate_dataset()
    - validate_row() for each row
    - validate_cell() for each matching non-empty cell in each row
    - end()
    &#34;&#34;&#34;

    SEVERITY = (&#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,)

    def __init__(self, tag_pattern, severity=&#34;error&#34;, description=None, callback=None):
        &#34;&#34;&#34;Constructor
        @param tag_pattern: the tag pattern to match for the rule
        @param severity: one of &#39;info&#39;, &#39;warning&#39;, or &#39;error&#39; (default)
        @param description: an optional error message to override the default from the tests
        @param callback: an optional callback function to handle error reports
        &#34;&#34;&#34;
        self.tag_pattern = hxl.TagPattern.parse(tag_pattern)
        self.description = description
        self.callback = callback

        # make sure the severity level is valid
        severity = hxl.datatypes.normalise_string(severity)
        if severity in SchemaRule.SEVERITY:
            self.severity = severity
        else:
            raise hxl.HXLException(&#34;Unsupported rule severity level: {}&#34;.format(severity))

        # Additional internal variables
        self.tests = []
        &#34;&#34;&#34;List of AbstractRuleTest objects to apply as part of this rule&#34;&#34;&#34;

        self.external_errors = []
        &#34;&#34;&#34;Errors external to the dataset itself (e.g. missing taxonomies)&#34;&#34;&#34;

        self.saved_indices = None
        &#34;&#34;&#34;List of saved column indices matching tag_pattern&#34;&#34;&#34;

    def needs_scan(self):
        &#34;&#34;&#34;Check if any test in this rule requires a pre-scan of the dataset.
        @returns: True if at least one test&#39;s needs_scan() method returns True
        &#34;&#34;&#34;
        for test in self.tests:
            if test.needs_scan():
                return True
        return False

    def start(self):
        &#34;&#34;&#34;Initialisation method
        Call after all values have been set, but before use
        &#34;&#34;&#34;

        self.saved_indices = None

        def test_callback(e):
            &#34;&#34;&#34;Relay error reports from tests, with rule-level context added&#34;&#34;&#34;
            e.rule = self
            if self.callback:
                self.callback(e)

        # (re)initialise all the tests
        for test in self.tests:
            test.callback = test_callback # call back to here
            test.start()

    def end(self):
        &#34;&#34;&#34;Call at end of parse to get post-parse errors&#34;&#34;&#34;
        status = True

        # finish all the tests
        for test in self.tests:
            if not test.end():
                status = False

        self.saved_indices = None
        return status

    def scan_row(self, row):
        &#34;&#34;&#34;Pre-scan a row and its individual cells.
        This method does not report errors or return a status.
        Will be invoked only if needs_scan() returned True
        Calls both scan_row() and scan_cell() for each test.
        @param row the Row to scan
        &#34;&#34;&#34;
        if self.saved_indices is None:
            self.saved_indices = hxl.model.get_column_indices([self.tag_pattern], row.columns)

        # scan each row, then each matching cell in the row
        for test in self.tests:
            if not test.needs_scan(): # don&#39;t invoke unless the test asked for it
                continue
            test.scan_row(row, self.saved_indices)
            for i in self.saved_indices: # validate individual cells
                if i &lt; len(row.values) and not hxl.datatypes.is_empty(row.values[i]):
                    test.scan_cell(row.values[i], row, row.columns[i])

    def end_scan(self):
        &#34;&#34;&#34;Invoke end_scan() for all tests that need it&#34;&#34;&#34;
        for test in self.tests:
            if test.needs_scan():
                test.end_scan()
                    
    def validate_dataset(self, dataset, indices=None, tag_pattern=None):
        &#34;&#34;&#34;Test whether the columns are present to satisfy this rule.&#34;&#34;&#34;
        
        status = True
        if self.saved_indices is None:
            self.saved_indices = hxl.model.get_column_indices([self.tag_pattern], dataset.columns)

        # Report any external errors
        for error in self.external_errors:
            if self.callback:
                self.callback(error)

        # run each of the tests
        for test in self.tests:
            if not test.validate_dataset(dataset, indices=self.saved_indices):
                status = False

        return status

    def validate_row(self, row):
        &#34;&#34;&#34;
        Apply the rule to an entire Row
        @param row the Row to validate
        @return True if all matching values in the row are valid
        &#34;&#34;&#34;

        # individual rules may change to False
        status = True
        if self.saved_indices is None:
            self.saved_indices = hxl.model.get_column_indices([self.tag_pattern], row.columns)

        # run each test on the complete row, then on individual cells
        for test in self.tests:
            if not test.validate_row(row, self.saved_indices):
                status = False
            for i in self.saved_indices: # validate individual cells
                if i &lt; len(row.values) and not hxl.datatypes.is_empty(row.values[i]):
                    if not test.validate_cell(row.values[i], row, row.columns[i]):
                        status = False

        return status

    def __str__(self):
        &#34;&#34;&#34;String representation of a rule (for debugging)&#34;&#34;&#34;
        return &#34;&lt;HXL schema rule: &#34; + str(self.tag_pattern) + &#34;&gt;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="hxl.validation.SchemaRule.SEVERITY"><code class="name">var <span class="ident">SEVERITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.validation.SchemaRule.external_errors"><code class="name">var <span class="ident">external_errors</span></code></dt>
<dd>
<div class="desc"><p>Errors external to the dataset itself (e.g. missing taxonomies)</p></div>
</dd>
<dt id="hxl.validation.SchemaRule.saved_indices"><code class="name">var <span class="ident">saved_indices</span></code></dt>
<dd>
<div class="desc"><p>List of saved column indices matching tag_pattern</p></div>
</dd>
<dt id="hxl.validation.SchemaRule.tests"><code class="name">var <span class="ident">tests</span></code></dt>
<dd>
<div class="desc"><p>List of AbstractRuleTest objects to apply as part of this rule</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.SchemaRule.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Call at end of parse to get post-parse errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self):
    &#34;&#34;&#34;Call at end of parse to get post-parse errors&#34;&#34;&#34;
    status = True

    # finish all the tests
    for test in self.tests:
        if not test.end():
            status = False

    self.saved_indices = None
    return status</code></pre>
</details>
</dd>
<dt id="hxl.validation.SchemaRule.end_scan"><code class="name flex">
<span>def <span class="ident">end_scan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invoke end_scan() for all tests that need it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_scan(self):
    &#34;&#34;&#34;Invoke end_scan() for all tests that need it&#34;&#34;&#34;
    for test in self.tests:
        if test.needs_scan():
            test.end_scan()</code></pre>
</details>
</dd>
<dt id="hxl.validation.SchemaRule.needs_scan"><code class="name flex">
<span>def <span class="ident">needs_scan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if any test in this rule requires a pre-scan of the dataset.
@returns: True if at least one test's needs_scan() method returns True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def needs_scan(self):
    &#34;&#34;&#34;Check if any test in this rule requires a pre-scan of the dataset.
    @returns: True if at least one test&#39;s needs_scan() method returns True
    &#34;&#34;&#34;
    for test in self.tests:
        if test.needs_scan():
            return True
    return False</code></pre>
</details>
</dd>
<dt id="hxl.validation.SchemaRule.scan_row"><code class="name flex">
<span>def <span class="ident">scan_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Pre-scan a row and its individual cells.
This method does not report errors or return a status.
Will be invoked only if needs_scan() returned True
Calls both scan_row() and scan_cell() for each test.
@param row the Row to scan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_row(self, row):
    &#34;&#34;&#34;Pre-scan a row and its individual cells.
    This method does not report errors or return a status.
    Will be invoked only if needs_scan() returned True
    Calls both scan_row() and scan_cell() for each test.
    @param row the Row to scan
    &#34;&#34;&#34;
    if self.saved_indices is None:
        self.saved_indices = hxl.model.get_column_indices([self.tag_pattern], row.columns)

    # scan each row, then each matching cell in the row
    for test in self.tests:
        if not test.needs_scan(): # don&#39;t invoke unless the test asked for it
            continue
        test.scan_row(row, self.saved_indices)
        for i in self.saved_indices: # validate individual cells
            if i &lt; len(row.values) and not hxl.datatypes.is_empty(row.values[i]):
                test.scan_cell(row.values[i], row, row.columns[i])</code></pre>
</details>
</dd>
<dt id="hxl.validation.SchemaRule.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialisation method
Call after all values have been set, but before use</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;Initialisation method
    Call after all values have been set, but before use
    &#34;&#34;&#34;

    self.saved_indices = None

    def test_callback(e):
        &#34;&#34;&#34;Relay error reports from tests, with rule-level context added&#34;&#34;&#34;
        e.rule = self
        if self.callback:
            self.callback(e)

    # (re)initialise all the tests
    for test in self.tests:
        test.callback = test_callback # call back to here
        test.start()</code></pre>
</details>
</dd>
<dt id="hxl.validation.SchemaRule.validate_dataset"><code class="name flex">
<span>def <span class="ident">validate_dataset</span></span>(<span>self, dataset, indices=None, tag_pattern=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Test whether the columns are present to satisfy this rule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_dataset(self, dataset, indices=None, tag_pattern=None):
    &#34;&#34;&#34;Test whether the columns are present to satisfy this rule.&#34;&#34;&#34;
    
    status = True
    if self.saved_indices is None:
        self.saved_indices = hxl.model.get_column_indices([self.tag_pattern], dataset.columns)

    # Report any external errors
    for error in self.external_errors:
        if self.callback:
            self.callback(error)

    # run each of the tests
    for test in self.tests:
        if not test.validate_dataset(dataset, indices=self.saved_indices):
            status = False

    return status</code></pre>
</details>
</dd>
<dt id="hxl.validation.SchemaRule.validate_row"><code class="name flex">
<span>def <span class="ident">validate_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the rule to an entire Row
@param row the Row to validate
@return True if all matching values in the row are valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_row(self, row):
    &#34;&#34;&#34;
    Apply the rule to an entire Row
    @param row the Row to validate
    @return True if all matching values in the row are valid
    &#34;&#34;&#34;

    # individual rules may change to False
    status = True
    if self.saved_indices is None:
        self.saved_indices = hxl.model.get_column_indices([self.tag_pattern], row.columns)

    # run each test on the complete row, then on individual cells
    for test in self.tests:
        if not test.validate_row(row, self.saved_indices):
            status = False
        for i in self.saved_indices: # validate individual cells
            if i &lt; len(row.values) and not hxl.datatypes.is_empty(row.values[i]):
                if not test.validate_cell(row.values[i], row, row.columns[i]):
                    status = False

    return status</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hxl.validation.SpellingTest"><code class="flex name class">
<span>class <span class="ident">SpellingTest</span></span>
<span>(</span><span>case_sensitive=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Detect spelling outliers in a column
HXL schema: #valid_value+spelling
Will treat numbers and dates as strings, so use this only in columns where
you expect text, and frequently-repeated values (e.g. #status, #org+name, #sector+name).</p>
<p>Will skip validation if the coefficient of variation &gt; 1.0</p>
<p>Collects all of the spelling variants first, then checks the rare ones in the end() method, and
reports any ones that have near matches among the common ones.</p>
<p>Constructor
@param case_sensitive: if True, differences in case are considered errors (default False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpellingTest(AbstractRuleTest):
    &#34;&#34;&#34;Detect spelling outliers in a column
    HXL schema: #valid_value+spelling
    Will treat numbers and dates as strings, so use this only in columns where
    you expect text, and frequently-repeated values (e.g. #status, #org+name, #sector+name).

    Will skip validation if the coefficient of variation &gt; 1.0

    Collects all of the spelling variants first, then checks the rare ones in the end() method, and
    reports any ones that have near matches among the common ones.
    &#34;&#34;&#34;

    ERROR_CUTOFF=0.05 # 5%
    &#34;&#34;&#34;Cutoff for reporting a possible error, as percentage of mean frequency for each spelling&#34;&#34;&#34;

    def __init__(self, case_sensitive=False):
        &#34;&#34;&#34;Constructor
        @param case_sensitive: if True, differences in case are considered errors (default False)
        &#34;&#34;&#34;
        super().__init__()
        self.case_sensitive = case_sensitive

    def start(self):
        &#34;&#34;&#34;Set up for a validation run&#34;&#34;&#34;
        # spelling -&gt; locations

        self.spelling_map = dict()
        &#34;&#34;&#34;Store spellings and locations by tagspec&#34;&#34;&#34;
        
        self.total_occurrences = dict()
        &#34;&#34;&#34;Count the total spelling occurrences, for mean and standard deviation, by tagspec&#34;&#34;&#34;

    def end(self):
        &#34;&#34;&#34;Report possible spelling errors.
        Collect all spellings that appear less than 1/3 of the mean frequency.

        For each of these, check whether there&#39;s a close match among
        the more-common spellings, and if so, then report (once for
        each location) with the suggested correction.
        &#34;&#34;&#34;

        # start by assuming all is well
        status = True

        for tagspec, spellings in self.spelling_map.items():

            # cache corrections so that we don&#39;t keep looking up the same ones
            correction_cache = {}

            # if there aren&#39;t any spellings, then we&#39;re done
            if len(spellings) == 0:
                break

            # get the average (mean) occurrences for each spelling
            mean_frequency = self.total_occurrences[tagspec] / len(spellings)

            # calculate the coefficiant of variance (dimensionless)
            standard_deviation = math.sqrt(
                sum(map(lambda n: (len(n)-mean_frequency)**2, spellings.values())) / len(spellings)
            )
            variance_coefficient = standard_deviation / mean_frequency

            # there&#39;s no point spelling checking unless the variance coefficient is low enough to be meaningful
            if variance_coefficient &gt; 1.0:
                break

            # first pass: collect and clear good spellings
            good_spellings = list()
            for spelling, locations in spellings.items():
                if len(locations) &gt; mean_frequency * SpellingTest.ERROR_CUTOFF:
                    good_spellings.append(spelling)
                    spellings[spelling] = None # no potential errors

            # second pass: report any remaining dubious spellings that have close matches among good spellings
            for spelling, locations in spellings.items():
                if locations is None: # this spelling was OK
                    continue
                # is there a near match among good spellings?
                if spelling in correction_cache:
                    correction = correction_cache[&#39;spelling&#39;]
                else:
                    correction = find_closest_match(spelling, good_spellings)
                    correction_cache[spelling] = correction
                if correction is not None:
                    # if it&#39;s rare and there&#39;s a near match, report an error
                    status = False
                    for location in locations:
                        self.report_error(
                            &#39;Possible spelling error&#39;,
                            value=location[2],
                            row=location[0],
                            column=location[1],
                            suggested_value=correction,
                            scope=&#39;cell&#39;
                        )
                
        return status # false if we&#39;ve found a possible correction

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Record all the spellings found, for later sorting&#34;&#34;&#34;

        tagspec = column.get_display_tag(sort_attributes=True) # FIXME

        if self.case_sensitive:
            cooked_value = hxl.datatypes.normalise_space(value)
        else:
            cooked_value = hxl.datatypes.normalise_string(value)
        self.total_occurrences[tagspec] = self.total_occurrences.setdefault(tagspec, 0) + 1
        self.spelling_map.setdefault(tagspec, {}).setdefault(cooked_value, []).append((row, column, value,))
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hxl.validation.SpellingTest.ERROR_CUTOFF"><code class="name">var <span class="ident">ERROR_CUTOFF</span></code></dt>
<dd>
<div class="desc"><p>Cutoff for reporting a possible error, as percentage of mean frequency for each spelling</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.SpellingTest.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Report possible spelling errors.
Collect all spellings that appear less than 1/3 of the mean frequency.</p>
<p>For each of these, check whether there's a close match among
the more-common spellings, and if so, then report (once for
each location) with the suggested correction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self):
    &#34;&#34;&#34;Report possible spelling errors.
    Collect all spellings that appear less than 1/3 of the mean frequency.

    For each of these, check whether there&#39;s a close match among
    the more-common spellings, and if so, then report (once for
    each location) with the suggested correction.
    &#34;&#34;&#34;

    # start by assuming all is well
    status = True

    for tagspec, spellings in self.spelling_map.items():

        # cache corrections so that we don&#39;t keep looking up the same ones
        correction_cache = {}

        # if there aren&#39;t any spellings, then we&#39;re done
        if len(spellings) == 0:
            break

        # get the average (mean) occurrences for each spelling
        mean_frequency = self.total_occurrences[tagspec] / len(spellings)

        # calculate the coefficiant of variance (dimensionless)
        standard_deviation = math.sqrt(
            sum(map(lambda n: (len(n)-mean_frequency)**2, spellings.values())) / len(spellings)
        )
        variance_coefficient = standard_deviation / mean_frequency

        # there&#39;s no point spelling checking unless the variance coefficient is low enough to be meaningful
        if variance_coefficient &gt; 1.0:
            break

        # first pass: collect and clear good spellings
        good_spellings = list()
        for spelling, locations in spellings.items():
            if len(locations) &gt; mean_frequency * SpellingTest.ERROR_CUTOFF:
                good_spellings.append(spelling)
                spellings[spelling] = None # no potential errors

        # second pass: report any remaining dubious spellings that have close matches among good spellings
        for spelling, locations in spellings.items():
            if locations is None: # this spelling was OK
                continue
            # is there a near match among good spellings?
            if spelling in correction_cache:
                correction = correction_cache[&#39;spelling&#39;]
            else:
                correction = find_closest_match(spelling, good_spellings)
                correction_cache[spelling] = correction
            if correction is not None:
                # if it&#39;s rare and there&#39;s a near match, report an error
                status = False
                for location in locations:
                    self.report_error(
                        &#39;Possible spelling error&#39;,
                        value=location[2],
                        row=location[0],
                        column=location[1],
                        suggested_value=correction,
                        scope=&#39;cell&#39;
                    )
            
    return status # false if we&#39;ve found a possible correction</code></pre>
</details>
</dd>
<dt id="hxl.validation.SpellingTest.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up for a validation run</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;Set up for a validation run&#34;&#34;&#34;
    # spelling -&gt; locations

    self.spelling_map = dict()
    &#34;&#34;&#34;Store spellings and locations by tagspec&#34;&#34;&#34;
    
    self.total_occurrences = dict()
    &#34;&#34;&#34;Count the total spelling occurrences, for mean and standard deviation, by tagspec&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="hxl.validation.SpellingTest.validate_cell"><code class="name flex">
<span>def <span class="ident">validate_cell</span></span>(<span>self, value, row, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Record all the spellings found, for later sorting</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_cell(self, value, row, column):
    &#34;&#34;&#34;Record all the spellings found, for later sorting&#34;&#34;&#34;

    tagspec = column.get_display_tag(sort_attributes=True) # FIXME

    if self.case_sensitive:
        cooked_value = hxl.datatypes.normalise_space(value)
    else:
        cooked_value = hxl.datatypes.normalise_string(value)
    self.total_occurrences[tagspec] = self.total_occurrences.setdefault(tagspec, 0) + 1
    self.spelling_map.setdefault(tagspec, {}).setdefault(cooked_value, []).append((row, column, value,))
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.UniqueRowTest"><code class="flex name class">
<span>class <span class="ident">UniqueRowTest</span></span>
<span>(</span><span>tag_patterns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Test for duplicate rows, optionally using a list of tag patterns as a key
HXL schema: #valid_unique+key
If there are no tag patterns provided, uses the entire row to make the key
Note that the target tag pattern (#valid_tag) is irrelevant for this test.</p>
<p>Constructor
If no tag patterns are supplied, test the whole row.
@param tag_patterns: list of tag patterns to test</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UniqueRowTest(AbstractRuleTest):
    &#34;&#34;&#34;Test for duplicate rows, optionally using a list of tag patterns as a key
    HXL schema: #valid_unique+key
    If there are no tag patterns provided, uses the entire row to make the key
    Note that the target tag pattern (#valid_tag) is irrelevant for this test.
    &#34;&#34;&#34;

    def __init__(self, tag_patterns=None):
        &#34;&#34;&#34;Constructor
        If no tag patterns are supplied, test the whole row.
        @param tag_patterns: list of tag patterns to test
        &#34;&#34;&#34;
        super().__init__()
        if tag_patterns is not None:
            self.tag_patterns = hxl.model.TagPattern.parse_list(tag_patterns)
        else:
            self.tag_patterns = None

    def start(self):
        self.keys_seen = set() # create the empty key set

    def end(self):
        self.keys_seen = None # free some memory
        return True

    def validate_row(self, row, indices=[], tag_pattern=None):
        key = row.key(self.tag_patterns)
        if key in self.keys_seen:
            return self.report_error(
                &#39;Duplicate row according to key values {}&#39;.format(str(key)),
                row=row,
                scope=&#39;row&#39;
            )
        else:
            self.keys_seen.add(key)
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_cell" href="#hxl.validation.AbstractRuleTest.validate_cell">validate_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.UniqueValueTest"><code class="flex name class">
<span>class <span class="ident">UniqueValueTest</span></span>
<span>(</span><span>callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that individual values are unique
HXL schema: #valid_unique-key
Every value in any column matching tag_pattern must be unique.
Normalises case and whitespace before testing, so "Aaa" and "
aaa"
would count as duplicates.</p>
<p>Set up a schema test.
@param callback: a callback function to receive error reports</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UniqueValueTest(AbstractRuleTest):
    &#34;&#34;&#34;Test that individual values are unique
    HXL schema: #valid_unique-key
    Every value in any column matching tag_pattern must be unique.
    Normalises case and whitespace before testing, so &#34;Aaa&#34; and &#34;  aaa&#34; 
    would count as duplicates.
    &#34;&#34;&#34;

    def start(self):
        self.values_seen = set() # create the empty value set

    def end(self):
        self.values_seen = None # free some memory
        return True

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Report an error if we see the same (normalised) value more than once&#34;&#34;&#34;
        norm_value = hxl.datatypes.normalise_string(value)
        if norm_value in self.values_seen:
            return self.report_error(
                &#34;Duplicate value&#34;,
                value=value,
                row=row,
                column=column
            )
        else:
            self.values_seen.add(norm_value)
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.UniqueValueTest.validate_cell"><code class="name flex">
<span>def <span class="ident">validate_cell</span></span>(<span>self, value, row, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Report an error if we see the same (normalised) value more than once</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_cell(self, value, row, column):
    &#34;&#34;&#34;Report an error if we see the same (normalised) value more than once&#34;&#34;&#34;
    norm_value = hxl.datatypes.normalise_string(value)
    if norm_value in self.values_seen:
        return self.report_error(
            &#34;Duplicate value&#34;,
            value=value,
            row=row,
            column=column
        )
    else:
        self.values_seen.add(norm_value)
        return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.validation.WhitespaceTest"><code class="flex name class">
<span>class <span class="ident">WhitespaceTest</span></span>
<span>(</span><span>callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Test for irregular whitespace in a cell
HXL schema: #valid_value+whitespace
Irregular whitespace is any leading or trailing space,
or anything but a single space character inside a string</p>
<p>Set up a schema test.
@param callback: a callback function to receive error reports</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WhitespaceTest(AbstractRuleTest):
    &#34;&#34;&#34;Test for irregular whitespace in a cell 
    HXL schema: #valid_value+whitespace
    Irregular whitespace is any leading or trailing space, 
    or anything but a single space character inside a string
    &#34;&#34;&#34;

    PATTERN = r&#39;^(\s+.*|.*(\s\s|[\t\r\n]).*|.*\s+)$&#39;
    &#34;&#34;&#34;Regular expression to detect irregular whitespace&#34;&#34;&#34;

    def validate_cell(self, value, row, column):
        &#34;&#34;&#34;Is there irregular whitespace?&#34;&#34;&#34;
        if hxl.datatypes.is_string(value):
            if re.match(WhitespaceTest.PATTERN, value):
                return self.report_error(
                    &#39;Found extra whitespace&#39;,
                    value=value,
                    row=row,
                    column=column,
                    suggested_value=hxl.datatypes.normalise_space(value)
                )
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hxl.validation.WhitespaceTest.PATTERN"><code class="name">var <span class="ident">PATTERN</span></code></dt>
<dd>
<div class="desc"><p>Regular expression to detect irregular whitespace</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.validation.WhitespaceTest.validate_cell"><code class="name flex">
<span>def <span class="ident">validate_cell</span></span>(<span>self, value, row, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Is there irregular whitespace?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_cell(self, value, row, column):
    &#34;&#34;&#34;Is there irregular whitespace?&#34;&#34;&#34;
    if hxl.datatypes.is_string(value):
        if re.match(WhitespaceTest.PATTERN, value):
            return self.report_error(
                &#39;Found extra whitespace&#39;,
                value=value,
                row=row,
                column=column,
                suggested_value=hxl.datatypes.normalise_space(value)
            )
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hxl" href="index.html">hxl</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hxl.validation.find_closest_match" href="#hxl.validation.find_closest_match">find_closest_match</a></code></li>
<li><code><a title="hxl.validation.get_common_prefix_len" href="#hxl.validation.get_common_prefix_len">get_common_prefix_len</a></code></li>
<li><code><a title="hxl.validation.get_edit_distance" href="#hxl.validation.get_edit_distance">get_edit_distance</a></code></li>
<li><code><a title="hxl.validation.make_json_issue" href="#hxl.validation.make_json_issue">make_json_issue</a></code></li>
<li><code><a title="hxl.validation.make_json_location" href="#hxl.validation.make_json_location">make_json_location</a></code></li>
<li><code><a title="hxl.validation.make_json_report" href="#hxl.validation.make_json_report">make_json_report</a></code></li>
<li><code><a title="hxl.validation.make_rule_hash" href="#hxl.validation.make_rule_hash">make_rule_hash</a></code></li>
<li><code><a title="hxl.validation.schema" href="#hxl.validation.schema">schema</a></code></li>
<li><code><a title="hxl.validation.validate" href="#hxl.validation.validate">validate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hxl.validation.AbstractRuleTest" href="#hxl.validation.AbstractRuleTest">AbstractRuleTest</a></code></h4>
<ul class="two-column">
<li><code><a title="hxl.validation.AbstractRuleTest.end" href="#hxl.validation.AbstractRuleTest.end">end</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.end_scan" href="#hxl.validation.AbstractRuleTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.get_indices" href="#hxl.validation.AbstractRuleTest.get_indices">get_indices</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.needs_scan" href="#hxl.validation.AbstractRuleTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.report_error" href="#hxl.validation.AbstractRuleTest.report_error">report_error</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_cell" href="#hxl.validation.AbstractRuleTest.scan_cell">scan_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.scan_row" href="#hxl.validation.AbstractRuleTest.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.start" href="#hxl.validation.AbstractRuleTest.start">start</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_cell" href="#hxl.validation.AbstractRuleTest.validate_cell">validate_cell</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_dataset" href="#hxl.validation.AbstractRuleTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.AbstractRuleTest.validate_row" href="#hxl.validation.AbstractRuleTest.validate_row">validate_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.ConsistentDatatypesTest" href="#hxl.validation.ConsistentDatatypesTest">ConsistentDatatypesTest</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.ConsistentDatatypesTest.end_scan" href="#hxl.validation.ConsistentDatatypesTest.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.ConsistentDatatypesTest.guess_type" href="#hxl.validation.ConsistentDatatypesTest.guess_type">guess_type</a></code></li>
<li><code><a title="hxl.validation.ConsistentDatatypesTest.needs_scan" href="#hxl.validation.ConsistentDatatypesTest.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.ConsistentDatatypesTest.validate_cell" href="#hxl.validation.ConsistentDatatypesTest.validate_cell">validate_cell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.CorrelationTest" href="#hxl.validation.CorrelationTest">CorrelationTest</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.CorrelationTest.end" href="#hxl.validation.CorrelationTest.end">end</a></code></li>
<li><code><a title="hxl.validation.CorrelationTest.start" href="#hxl.validation.CorrelationTest.start">start</a></code></li>
<li><code><a title="hxl.validation.CorrelationTest.validate_row" href="#hxl.validation.CorrelationTest.validate_row">validate_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.DatatypeTest" href="#hxl.validation.DatatypeTest">DatatypeTest</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.DatatypeTest.DATATYPES" href="#hxl.validation.DatatypeTest.DATATYPES">DATATYPES</a></code></li>
<li><code><a title="hxl.validation.DatatypeTest.validate_cell" href="#hxl.validation.DatatypeTest.validate_cell">validate_cell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.EnumerationTest" href="#hxl.validation.EnumerationTest">EnumerationTest</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.EnumerationTest.get_suggested_value" href="#hxl.validation.EnumerationTest.get_suggested_value">get_suggested_value</a></code></li>
<li><code><a title="hxl.validation.EnumerationTest.setup_tables" href="#hxl.validation.EnumerationTest.setup_tables">setup_tables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.HXLValidationException" href="#hxl.validation.HXLValidationException">HXLValidationException</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.HXLValidationException.SCOPES" href="#hxl.validation.HXLValidationException.SCOPES">SCOPES</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.NumericOutlierTest" href="#hxl.validation.NumericOutlierTest">NumericOutlierTest</a></code></h4>
</li>
<li>
<h4><code><a title="hxl.validation.RangeTest" href="#hxl.validation.RangeTest">RangeTest</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.RangeTest.validate_cell" href="#hxl.validation.RangeTest.validate_cell">validate_cell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.RegexTest" href="#hxl.validation.RegexTest">RegexTest</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.RegexTest.validate_cell" href="#hxl.validation.RegexTest.validate_cell">validate_cell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.RequiredTest" href="#hxl.validation.RequiredTest">RequiredTest</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.RequiredTest.validate_dataset" href="#hxl.validation.RequiredTest.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.RequiredTest.validate_row" href="#hxl.validation.RequiredTest.validate_row">validate_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.Schema" href="#hxl.validation.Schema">Schema</a></code></h4>
<ul class="two-column">
<li><code><a title="hxl.validation.Schema.callback" href="#hxl.validation.Schema.callback">callback</a></code></li>
<li><code><a title="hxl.validation.Schema.end" href="#hxl.validation.Schema.end">end</a></code></li>
<li><code><a title="hxl.validation.Schema.end_scan" href="#hxl.validation.Schema.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.Schema.parse" href="#hxl.validation.Schema.parse">parse</a></code></li>
<li><code><a title="hxl.validation.Schema.rules" href="#hxl.validation.Schema.rules">rules</a></code></li>
<li><code><a title="hxl.validation.Schema.scan_row" href="#hxl.validation.Schema.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.Schema.start" href="#hxl.validation.Schema.start">start</a></code></li>
<li><code><a title="hxl.validation.Schema.validate" href="#hxl.validation.Schema.validate">validate</a></code></li>
<li><code><a title="hxl.validation.Schema.validate_dataset" href="#hxl.validation.Schema.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.Schema.validate_row" href="#hxl.validation.Schema.validate_row">validate_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.SchemaRule" href="#hxl.validation.SchemaRule">SchemaRule</a></code></h4>
<ul class="two-column">
<li><code><a title="hxl.validation.SchemaRule.SEVERITY" href="#hxl.validation.SchemaRule.SEVERITY">SEVERITY</a></code></li>
<li><code><a title="hxl.validation.SchemaRule.end" href="#hxl.validation.SchemaRule.end">end</a></code></li>
<li><code><a title="hxl.validation.SchemaRule.end_scan" href="#hxl.validation.SchemaRule.end_scan">end_scan</a></code></li>
<li><code><a title="hxl.validation.SchemaRule.external_errors" href="#hxl.validation.SchemaRule.external_errors">external_errors</a></code></li>
<li><code><a title="hxl.validation.SchemaRule.needs_scan" href="#hxl.validation.SchemaRule.needs_scan">needs_scan</a></code></li>
<li><code><a title="hxl.validation.SchemaRule.saved_indices" href="#hxl.validation.SchemaRule.saved_indices">saved_indices</a></code></li>
<li><code><a title="hxl.validation.SchemaRule.scan_row" href="#hxl.validation.SchemaRule.scan_row">scan_row</a></code></li>
<li><code><a title="hxl.validation.SchemaRule.start" href="#hxl.validation.SchemaRule.start">start</a></code></li>
<li><code><a title="hxl.validation.SchemaRule.tests" href="#hxl.validation.SchemaRule.tests">tests</a></code></li>
<li><code><a title="hxl.validation.SchemaRule.validate_dataset" href="#hxl.validation.SchemaRule.validate_dataset">validate_dataset</a></code></li>
<li><code><a title="hxl.validation.SchemaRule.validate_row" href="#hxl.validation.SchemaRule.validate_row">validate_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.SpellingTest" href="#hxl.validation.SpellingTest">SpellingTest</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.SpellingTest.ERROR_CUTOFF" href="#hxl.validation.SpellingTest.ERROR_CUTOFF">ERROR_CUTOFF</a></code></li>
<li><code><a title="hxl.validation.SpellingTest.end" href="#hxl.validation.SpellingTest.end">end</a></code></li>
<li><code><a title="hxl.validation.SpellingTest.start" href="#hxl.validation.SpellingTest.start">start</a></code></li>
<li><code><a title="hxl.validation.SpellingTest.validate_cell" href="#hxl.validation.SpellingTest.validate_cell">validate_cell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.UniqueRowTest" href="#hxl.validation.UniqueRowTest">UniqueRowTest</a></code></h4>
</li>
<li>
<h4><code><a title="hxl.validation.UniqueValueTest" href="#hxl.validation.UniqueValueTest">UniqueValueTest</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.UniqueValueTest.validate_cell" href="#hxl.validation.UniqueValueTest.validate_cell">validate_cell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.validation.WhitespaceTest" href="#hxl.validation.WhitespaceTest">WhitespaceTest</a></code></h4>
<ul class="">
<li><code><a title="hxl.validation.WhitespaceTest.PATTERN" href="#hxl.validation.WhitespaceTest.PATTERN">PATTERN</a></code></li>
<li><code><a title="hxl.validation.WhitespaceTest.validate_cell" href="#hxl.validation.WhitespaceTest.validate_cell">validate_cell</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>