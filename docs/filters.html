<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hxl.filters API documentation</title>
<meta name="description" content="Data filter classes for the Humanitarian Exchange Language (HXL) v1.0 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hxl.filters</code></h1>
</header>
<section id="section-intro">
<p>Data filter classes for the Humanitarian Exchange Language (HXL) v1.0</p>
<p>Filters are virtual L{datasets<hxl.model.Dataset>} that read from
I{other} datasets and modify them on the fly. Most of the filter
classes here have corresponding convenience methods in the
L{hxl.model.Dataset} class, such as L{sort()<hxl.model.Dataset.sort>}
for L{SortFilter}::</p>
<p># Filter as a class
source = SortFilter(hxl.data('http://example.org/data.csv'))</p>
<p># Filter as a method
source = hxl.data('http://example.org/data.csv).sort()</p>
<p>Most filters do not keep a copy of the data internally, so it is
efficient to chain many filters together::</p>
<p>source = hxl.data(url).with_rows('org=UNICEF').with_rows('sector=Education')</p>
<p>Some filters, however, do have to keep a cached version of the data
internally, such as L{SortFilter}, L{CountFilter}, and
L{CacheFilter}. If you are working with very large datasets, you
should be aware of this limitation (for example, it is better to sort
I{after} filtering out a lot of rows, so that there will be less held
in memory).</p>
<p>If you are creating your own filters, you should normally subclass
them from L{AbstractStreamingFilter} (if they don't have to keep data
internally) or L{AbstractCachingFilter}, but you can also subclass the
lower-level L{AbstractBaseFilter} directly for especially-complex cases.</p>
<p>@author: David Megginson
@organization: UNOCHA
@license: Public Domain
@date: Started October 2014
@see: U{hxlstandard.org}</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Data filter classes for the Humanitarian Exchange Language (HXL) v1.0

Filters are virtual L{datasets&lt;hxl.model.Dataset&gt;} that read from
I{other} datasets and modify them on the fly. Most of the filter
classes here have corresponding convenience methods in the
L{hxl.model.Dataset} class, such as L{sort()&lt;hxl.model.Dataset.sort&gt;}
for L{SortFilter}::

  # Filter as a class
  source = SortFilter(hxl.data(&#39;http://example.org/data.csv&#39;))

  # Filter as a method
  source = hxl.data(&#39;http://example.org/data.csv).sort()

Most filters do not keep a copy of the data internally, so it is
efficient to chain many filters together::

  source = hxl.data(url).with_rows(&#39;org=UNICEF&#39;).with_rows(&#39;sector=Education&#39;)

Some filters, however, do have to keep a cached version of the data
internally, such as L{SortFilter}, L{CountFilter}, and
L{CacheFilter}. If you are working with very large datasets, you
should be aware of this limitation (for example, it is better to sort
I{after} filtering out a lot of rows, so that there will be less held
in memory).

If you are creating your own filters, you should normally subclass
them from L{AbstractStreamingFilter} (if they don&#39;t have to keep data
internally) or L{AbstractCachingFilter}, but you can also subclass the
lower-level L{AbstractBaseFilter} directly for especially-complex cases.

@author: David Megginson
@organization: UNOCHA
@license: Public Domain
@date: Started October 2014
@see: U{hxlstandard.org}

&#34;&#34;&#34;

import hxl, hxl.formulas.eval as feval
import abc, copy, dateutil.parser, itertools, json, jsonpath_ng.ext, logging, re, six, sys


logger = logging.getLogger(__name__)


class HXLFilterException(hxl.HXLException):
    &#34;&#34;&#34;Base class for HXL filter exceptions.

    This subclass of L{hxl.HXLException} exists only to make it
    easier to distinguish filter-based exceptions in C{except:} clauses.
    &#34;&#34;&#34;


class AbstractBaseFilter(hxl.model.Dataset):
    &#34;&#34;&#34;Abstract base class for composable filters.

    This is the base class for all filters. A B{filter} is like a
    L{hxl.model.Dataset}, except that it uses another dataset as its source, and
    performs some kind of transformation on it before producing its
    output.

    This class stores the upstream source, and provides a
    L{filter_columns} method that child classes can implement. The
    L{columns} method will call filter_columns() precisely once for
    each instantiation, giving the child a chance to provide a
    different set of columns than those in the source.

    If you&#39;re writing your own filter classes, you should normally
    subclass L{AbstractStreamingFilter} or L{AbstractCachingFilter},
    both of which are child classes of this one; however, there may be
    some special applications where you need to subclass
    I{AbstractBaseFilter} directly (see L{AppendFilter} for an
    example).

    Subclassing works like this::
    
      class MyFilter(hxl.filters.AbstractBaseFilter):

          def __init__(self, source):
              super(AbstractBaseFilter, self).__init__(source)

          def filter_columns(self):
              return [Column.parse(&#39;#org&#39;), Column.parse(&#39;#adm1&#39;)]

    The output will be identical to the source, except that the
    columns will now be &#39;#org&#39; and &#39;#adm1&#39;.

    @see: L{AbstractStreamingFilter}
    @see: L{AbstractCachingFilter}

    &#34;&#34;&#34;

    __metaclass__ = abc.ABCMeta

    def __init__(self, source):
        &#34;&#34;&#34;Construct a new abstract filter.
        @param source: the source dataset
        &#34;&#34;&#34;

        super().__init__()

        self.source = source
        &#34;&#34;&#34;HXL data source for the filter&#34;&#34;&#34;

        self._filtered_column_cache = None
        &#34;&#34;&#34;Cache of columns as filtered by the child class.&#34;&#34;&#34;

    @property
    def is_cached(self):
        &#34;&#34;&#34;Test if the input is cached (can be replayed).
        Subclasses that cache should override this.
        @returns: C{True} only if the source is cached.
        &#34;&#34;&#34;
        return self.source.is_cached

    @property
    def columns(self):
        &#34;&#34;&#34;Return the filter&#39;s (possibly-modified) columns.

        By default, return the columns defined by the source HXL
        data. Child classes override the L{filter_columns} method to
        return something different.

        @returns: a list of L{hxl.model.Column} objects
        &#34;&#34;&#34;
        if self._filtered_column_cache is None:
            self._filtered_column_cache = self.filter_columns()
        return self._filtered_column_cache

    def filter_columns(self):
        &#34;&#34;&#34;Return a new list of columns for the filtered dataset.

        By default, return the source HXL data&#39;s columns. Child
        classes override this method to return a different set of
        columns

        @returns: a list of L{hxl.model.Column} objects
        @see: L{AbstractStreamingFilter.filter_row}
        @see: L{AbstractCachingFilter.filter_rows}
        &#34;&#34;&#34;
        return self.source.columns

    def _setup_queries(self, query_specs):
        &#34;&#34;&#34;Parse a list of query specs, and calculate aggregates when needed.
        Side-effect: may replace self.source with a caching filter.
        @param query_specs: a list of row-query string specs
        @returns: a list of hxl.model.RowQuery objects, ready for use
        &#34;&#34;&#34;
        queries = hxl.model.RowQuery.parse_list(query_specs)

        # Some queries need to run through the dataset first to calculate an aggregate value
        for query in queries:
            if query.needs_aggregate:
                if not self.source.is_cached:
                    self.source = self.source.cache()
                query.calc_aggregate(self.source)

        return queries

    def _get_indices(self, patterns):
        &#34;&#34;&#34;Get indices of columns to fill.
        If there&#39;s no column pattern, then fill all columns.
        @param patterns: list of tag patterns for matching columns (if empty, all columns match)
        @returns: a set of indices for filling.
        &#34;&#34;&#34;
        indices = set()
        for i, column in enumerate(self.source.columns):
            if len(patterns) == 0 or hxl.model.TagPattern.match_list(column, patterns):
                indices.add(i)
        return indices

    @staticmethod
    def _load (source, spec):
        &#34;&#34;&#34;Create an instance of the filter from a dict.
        Child classes must override this method.
        @param spec: the JSON-like spec to read
        @returns: a new filter object
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No static _load method implemented.&#34;)

    
class AbstractStreamingFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Abstract base class for streaming filters.

    A streaming filter processes one row at a time.  It can skip rows,
    but it never reorders them.  As a result, a streaming filter is
    I{much} more efficient than a L{caching
    filter&lt;AbstractCachingFilter&gt;}, since it needs to hold only one
    row in memory at a time.

    It is not possible to replay the data from a streaming filter
    (e.g. to run a second processing pass), unless it has a caching
    filter higher up the filter chain; if you are reading directly
    from disk or a URL, the data is gone once it has passed through
    the filter once.

    If you are implementing your own filter class, you should subclass
    I{AbstractStreamingFilter} whenever possible. Child classes may
    implement the L{AbstractBaseFilter.filter_columns} method to
    change the columns and tags, and/or this class&#39;s L{filter_row}
    method to change, add, or suppress individual rows, like this:

      class MyFilter(hxl.filters.AbstractStreamingFilter):

          def __init__(self, source):
              super(AbstractStreamingFilter, self).__init__(source)

          def filter_row(self, row):
              if row.get(&#39;org+name&#39;) == &#34;Unknown&#34;:
                  return None # remove from output
              else:
                  return row

    This simple filter will produce a copy of the source data, but
    omitting rows where the org name is &#34;Unknown&#34;.

    @see: L{AbstractCachingFilter}

    &#34;&#34;&#34;

    __metaclass__ = abc.ABCMeta

    def __init__(self, source):
        &#34;&#34;&#34;Construct a new streaming filter.
        @param source: the source dataset
        &#34;&#34;&#34;
        super().__init__(source)

    @abc.abstractmethod
    def filter_row(self, row):
        &#34;&#34;&#34;Filter a single row of data.

        By default, this method returns the row&#39;s values,
        unchanged. Subclasses can use it to replace, add or suppress
        rows on the fly, without having to keep a copy of the entire
        dataset in memory.

        @param row: the original L{hxl.model.Row} object.  
        @returns: A list of string values (I{not} a Row object) or
        C{None} to skip the row.
        @see: L{AbstractBaseFilter.filter_columns}

        &#34;&#34;&#34;
        return row.values

    def __iter__(self):
        return AbstractStreamingFilter._Iterator(self)

    class _Iterator:
        &#34;&#34;&#34;Internal iterator class to return the filtered rows.
        Note that the filtering happens here, not in the main class.
        &#34;&#34;&#34;

        def __init__(self, outer):
            &#34;&#34;&#34;Create an iterator for a streaming filter
            @param outer: a reference to the parent object (an L{AbstractStreamingFilter}).
            &#34;&#34;&#34;
            self.outer = outer # ref to outer object
            self.source_iter = iter(self.outer.source) # iterator for the source data
            self.row_number = -1

        def __iter__(self):
            return self

        def __next__(self):
            &#34;&#34;&#34;Return the next filtered row of data.  

            Uses the L{AbstractStreamingFilter.filter_row} method. The
            returned row is always a new object, so that if the client
            changes it, it won&#39;t change the version visible upstream
            in the filter chain.

            @returns: a L{hxl.model.Row} object

            &#34;&#34;&#34;
            # call this here, in case it caches any useful information
            columns = self.outer.columns
            while True:
                # a StopIterationException will terminate the loop
                row = next(self.source_iter)
                # get a new list of filtered values
                values = self.outer.filter_row(row)
                if values is not None:
                    # keep looping if filter_row(row) returned None
                    self.row_number += 1
                    # create a new Row object
                    return hxl.model.Row(columns, values, self.row_number)


class AbstractCachingFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Abstract base class for caching filters.

    A caching filter processes the entire dataset together in
    memory. This approach is less efficient than a L{streaming
    filter&lt;AbstractStreamingFilter&gt;}, but it&#39;s necessary when a filter
    needs to reorder rows, or to change some rows that depend on
    others. Examples of caching filters include L{SortFilter},
    L{CountFilter}, and L{CacheFilter}.

    Another important property of a caching filter is that it&#39;s
    possible to replay it. As a result, caching filters are especially
    useful for data that a client application needs to process more
    than once, and the L{CacheFilter} class exists for precisely that
    purpose. The filter will transform the data only once, then save a
    copy of it for future use.

    Child classes may implement the
    L{AbstractBaseFilter.filter_columns} method to change the columns
    and tags, and/or this class&#39;s L{filter_rows} method to change the
    data all at once, like this::

      class MyFilter(hxl.filters.AbstractCachingFilter):

          def __init__(self, source):
              super(AbstractStreamingFilter, self).__init__(source)

          def filter_rows(self, row):
              raw_data = self.source.values
              # return a list of lists, one for each row
              return raw_data.sort()

    This simple filter will produce a copy of the source data sorted
    using Python&#39;s default sorting method.

    @see: L{AbstractStreamingFilter}

    &#34;&#34;&#34;

    __metaclass__ = abc.ABCMeta

    def __init__(self, source):
        &#34;&#34;&#34;Construct a new caching filter.
        @param source: the source dataset
        &#34;&#34;&#34;
        super().__init__(source)

        self._saved_rows = None
        &#34;&#34;&#34;Cache of the output rows, for replaying.&#34;&#34;&#34;

    @property
    def is_cached(self):
        &#34;&#34;&#34;Test if the input is cached.
        @returns: always C{True} for caching filters
        &#34;&#34;&#34;
        return True

    def filter_rows(self):
        &#34;&#34;&#34;Filter all of the data together.
        
        This method returns raw lists and strings, not objects from
        the L{hxl.model} module; for example, it could return the
        following for a three-row dataset::

          [[&#39;UNICEF&#39;, &#39;20&#39;], [&#39;UNHCR&#39;, &#39;15&#39;], [&#39;OXFAM&#39;, &#39;25&#39;]]

        The I{AbstractCachingFilter} class will construct the
        appropriate objects around the data.
        
        @returns: a list of lists of strings, one list for each row.
        @see: L{AbstractBaseFilter.filter_columns}
        &#34;&#34;&#34;
        return self.source.values

    def __iter__(self):
        return AbstractCachingFilter._Iterator(self)

    class _Iterator:
        &#34;&#34;&#34;Internal iterator class to return the filtered rows.&#34;&#34;&#34;

        def __init__(self, outer):
            &#34;&#34;&#34;Create an iterator for a caching filter
            @param outer: a reference to the parent object (an L{AbstractStreamingFilter}).
            &#34;&#34;&#34;
            self.outer = outer
            self.values_iter = None
            self.row_number = -1

        def __iter__(self):
            return self

        def __next__(self):
            &#34;&#34;&#34;Return the next filtered row.

            If we haven&#39;t called L{AbstractCachingFilter.filter_rows}
            yet, call it now, and save the result in the parent&#39;s I{_saved_rows} property.

            @returns: a L{hxl.model.Row} object
            &#34;&#34;&#34;

            if self.values_iter is None:
                if self.outer._saved_rows is None:
                    # filter rows only once, when requested
                    self.outer._saved_rows = self.outer.filter_rows()
                self.values_iter = iter(self.outer._saved_rows)
            self.row_number += 1
            return hxl.model.Row(self.outer.columns, next(self.values_iter), self.row_number)
        

#
# Utility classes
#
class Aggregator(object):
    &#34;&#34;&#34;Class for aggregating a single value vertically through a dataset
.
    This is the class that accumulates a line count, sum, min, max, or average value
    across all rows of a dataset. Add any new aggregator types here.
    &#34;&#34;&#34;

    def __init__(self, type=&#39;count&#39;, pattern=None, column=None):
        &#34;&#34;&#34;Constructor
        See the L{parse} and L{parse_list} static methods for creating an aggregator from a string spec.
        @param type: the aggregator type to create, as a string
        @param pattern: the tag pattern for disaggregation (may be C{None} for just counting lines)
        @param column: the hashtag and attributes for the output column with aggregated values
        @exception HXLFilterException: if C{pattern} is C{None} and C{type} isn&#39;t C{&#34;count&#34;}
        &#34;&#34;&#34;
        super().__init__()
        self.type = type.lower()
        if pattern:
            self.pattern = hxl.model.TagPattern.parse(pattern)
        elif type == &#39;count&#39;:
            self.pattern = None
        else:
            raise HXLFilterException(&#39;Pattern missing for {} aggregator&#39;.format(type))
        if not column:
            column = &#39;{type}#meta+{type}&#39;.format(type=self.type)
        self.column = hxl.model.Column.parse_spec(column)

        self.total = 0
        &#34;&#34;&#34;Total number of rows used.&#34;&#34;&#34;

        self.value = None
        &#34;&#34;&#34;Resulting aggregation value.&#34;&#34;&#34;

        self.normalised = None
        &#34;&#34;&#34;Normalised value to use for internal comparison&#34;&#34;&#34;

        self.values = set()
        &#34;&#34;&#34;Unique values seen (for concat)&#34;&#34;&#34;

    def evaluate_row(self, row):
        &#34;&#34;&#34;Evaluate a single row of HXL data against this aggregator.
        @param row: the input row to read
        @exception HXLFilterException: for an unrecognised aggregator type
        &#34;&#34;&#34;

        #
        # Shortcut: just counting rows
        #
        if self.type == &#39;count&#39;:
            if self.value is None:
                self.value = 0
            self.value += 1
            return

        #
        # Aggregating values
        #
        value = row.get(self.pattern)

        # Skip empty values
        if hxl.datatypes.is_empty(value):
            return

        # Numbers only for sum and average
        datatype = hxl.datatypes.typeof(value, self.pattern)
        if self.type in [&#39;sum&#39;, &#39;average&#39;] and datatype != &#39;number&#39;:
            logger.error(&#34;Cannot use %s as a numeric value for aggregation; skipping.&#34;, value)
            return

        normalised = hxl.datatypes.normalise(value, self.pattern)
        self.total += 1

        # aggregate as appropriate
        # note that we track a separate normalised value for strings and dates
        if self.type == &#39;sum&#39;:
            if self.value is None:
                self.value = 0
            self.value += normalised
        elif self.type == &#39;average&#39;:
            if self.value is None:
                self.value = 0
            self.value = ((self.value * (self.total - 1)) + normalised) / self.total
        elif self.type == &#39;min&#39;:
            def gt(a, b):
                try:
                    return a &gt; b
                except TypeError:
                    return str(a) &gt; str(b)
            if self.normalised is None or gt(self.normalised, normalised):
                self.value = value
                self.normalised = normalised
        elif self.type == &#39;max&#39;:
            def lt(a, b):
                try:
                    return a &lt; b
                except TypeError:
                    return str(a) &lt; str(b)
            if self.normalised is None or lt(self.normalised, normalised):
                self.value = value
                self.normalised = normalised
        elif self.type == &#39;concat&#39;:
            if not hxl.datatypes.is_empty(value):
                value = hxl.datatypes.normalise_space(value)
                if value not in self.values:
                    # regenerate the list if it&#39;s a new value
                    self.values.add(value)
                    self.value = &#34;|&#34;.join(sorted(self.values))
        else:
            raise HXLFilterException(&#34;Bad aggregator type for count filter: {}&#34;.format(type))

    TAG_PATTERN = r&#39;#?{token}(?:\s*[+-]{token})*&#39;.format(token=hxl.datatypes.TOKEN_PATTERN)
    &#34;&#34;&#34;Regular expression for a tag pattern&#34;&#34;&#34;
    
    COL_PATTERN = r&#39;#{token}(?:\s*\+{token})*&#39;.format(token=hxl.datatypes.TOKEN_PATTERN)
    &#34;&#34;&#34;Regular expression for an output column pattern&#34;&#34;&#34;

    AGGREGATOR_PATTERN = r&#39;^\s*({token})\(({tag})?\)(?:\s*as\s+([^#]*)({col}))?$&#39;.format(
        token = hxl.datatypes.TOKEN_PATTERN,
        tag = TAG_PATTERN,
        col = COL_PATTERN
    )
    &#34;&#34;&#34; Regular expression for an aggregation pattern
    Matches 1=aggregator, 2=tag pattern, 3=column header, 4=column tag
    &#34;&#34;&#34;

    @staticmethod
    def parse(spec):
        &#34;&#34;&#34;Parse a string specification and create an aggregator.
        Example: C{sum(#affected) as #affected+total}
        @param spec: the string specification
        @returns: an aggregator
        @exception HXLFilterException: if unable to parse, or an unrecognised aggregator type
        &#34;&#34;&#34;
        if isinstance(spec, Aggregator):
            # in case it&#39;s already parsed
            return spec
        match = re.match(Aggregator.AGGREGATOR_PATTERN, spec)
        if not match:
            raise HXLFilterException(&#34;Malformed aggregator: {}&#34;.format(spec))
        return Aggregator(
            type=match.group(1),
            pattern=hxl.model.TagPattern.parse(match.group(2)) if match.group(2) else None,
            column=hxl.model.Column.parse(match.group(4), header=match.group(3), use_exception=True) if match.group(4) else None,
        )

    @staticmethod
    def parse_list(specs):
        &#34;&#34;&#34;Parse a list of string specifications for aggregators
        Applies L{parse} to each item in the list
        @param specs: a list of string specifications for aggregators
        @returns: a list of L{Aggregator} objects
        @exception HXLFilterException: if unable to parse, or an unrecognised aggregator type
        &#34;&#34;&#34;
        result = []
        if isinstance(specs, six.string_types):
            specs = [specs]
        for spec in specs:
            result.append(Aggregator.parse(spec))
        return result


#
# Filter classes
#

class AddColumnsFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Composable filter class to add constant values to every row of a HXL dataset.

    This is a L{streaming filter&lt;AbstractStreamingFilter&gt;} to add
    constant values, such as a country code, to every row of data.  It
    supports the L{hxl.model.Dataset.add_columns} method and the
    L{hxladd&lt;hxl.scripts.hxladd&gt;} command-line utility.

    This example will add a column with the label &#34;Country name&#34;, the
    HXL hashtag &#34;#country&#34;, and the value &#34;Malaysia&#34; to every row in
    the dataset::

        filter = AddColumnsFilter(source, &#34;Country name#country=Malaysia&#34;)

    This filter also supports substitution patterns in the fixed
    values, surrounded by double braces. For example, the pattern

        X-{{#country+code}}

    will include the value &#34;X-&#34; followed by the value of the column
    #country+code in each new cell in the new column.

    @see: L{ColumnFilter}, L{RenameFilter}

    &#34;&#34;&#34;

    def __init__(self, source, specs, before=False):
        &#34;&#34;&#34;Construct a new AddColumnsFilter.

        The I{source} parameter may be either a string or a list of
        strings (for multiple columns). Each string must have the
        following format (I{&lt;header text&gt;} is optional):

        I{&lt;header text&gt;}B{#}I{&lt;tag and attributes&gt;}B{=}I{&lt;constant value&gt;}

        Example::

            Country name#country=Malasia

        By default, this filter will add new columns to the end of
        existing ones, but you can use optional I{before} parameter to
        add them to the front.

        @param source: a HXL data source

        @param specs: a string or list of strings containing new
        column specifications, as described above (or a list of tuples
        as described in L{parse_spec})
        @param before: true to add new columns before existing ones (default C{False})

        &#34;&#34;&#34;
        super().__init__(source)
        if isinstance(specs, six.string_types):
            # make a one-item list if the param is a string
            specs = [specs]
        self.specs = [AddColumnsFilter.parse_spec(spec) for spec in specs]
        self.before = before
        &#34;&#34;&#34;If True, add new columns before existing ones&#34;&#34;&#34;
        self.const_values = None
        &#34;&#34;&#34;Constant values to add to the new columns&#34;&#34;&#34;

    def filter_columns(self):
        &#34;&#34;&#34;Internal: return the new columns list
        @returns: a list of L{hxl.model.Column} objects
        &#34;&#34;&#34;
        new_columns = [spec[0] for spec in self.specs]
        if self.before:
            new_columns = new_columns + self.source.columns
        else:
            new_columns = self.source.columns + new_columns
        self.const_values = [spec[1] for spec in self.specs]
        return new_columns

    def filter_row(self, row):
        &#34;&#34;&#34;Internal: return each row with the new fixed value(s) attached.
        Will execute pattern substitutions inside double braces for the fixed values.
        @returns: a list of values, including the fixed values for new columns
        &#34;&#34;&#34;
        values = copy.copy(row.values)
        if self.before:
            return self._subst(row, self.const_values) + values
        else:
            return values + self._subst(row, self.const_values)

    _SUBST_PATTERN = r&#39;{{(.+?)}}&#39; # non-greedy expression
    &#34;&#34;&#34;Regular expression to parse a substitution pattern in the fixed contents for the new cell&#34;&#34;&#34;

    def _subst(self, row, const_values):
        &#34;&#34;&#34;Execute pattern substitutions for fixed values for the new columns.
        Substitutions are tag patterns inside double braces. Example: &#34;X-{{#country+code}}&#34;
        @param row: the row to search for matches to any patterns.
        @param const_values: the constant values to scan for patterns
        @returns: the constant values (only) with substitutions executed
        &#34;&#34;&#34;
        def do_sub(match_object):
            # FIXME don&#39;t want to reparse the formula for every row
            # Need to pre-parse and pre-chunk the replacement string
            result = feval.eval(row, match_object.group(1))
            return str(result)
        values = []
        for value in const_values:
            values.append(re.sub(AddColumnsFilter._SUBST_PATTERN, do_sub, value))
        return values

    SPEC_PATTERN = r&#39;^\s*(?:([^#]*?)#)?({token}(?:\s*\+{token})*)=(.*)\s*$&#39;.format(token=hxl.datatypes.TOKEN_PATTERN)
    &#34;&#34;&#34;Pattern for a string specification for a new column&#34;&#34;&#34;

    @staticmethod
    def parse_spec(spec):
        &#34;&#34;&#34;Parse a new-column specification.

        The format is I{&lt;header text&gt;}B{#}I{&lt;tag and
        attributes&gt;}B{=}I{&lt;fixed value&gt;}. Example::

          Country name#country=Malaysia

        @param spec: the string spec to parse, in the format above.
        @returns: a tuple containing a L{hxl.model.Column} object and the fixed value.
        &#34;&#34;&#34;

        if not isinstance(spec, six.string_types):
            return spec
        result = re.match(AddColumnsFilter.SPEC_PATTERN, spec)
        if result:
            header = result.group(1)
            tag = &#39;#&#39; + result.group(2)
            value = result.group(3)
            return (hxl.model.Column.parse(tag, header=header), value)
        else:
            raise HXLFilterException(&#34;Badly formatted new-column spec: &#34; + spec)

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;New instance from a JSON-style dictionary.
        @param source: the upstream data source
        @param spec: the JSON-style specification
        &#34;&#34;&#34;
        return AddColumnsFilter(
            source=source,
            specs=req_arg(spec, &#39;specs&#39;),
            before=opt_arg(spec, &#39;before&#39;, False)
        )


class AppendFilter(AbstractBaseFilter):

    &#34;&#34;&#34;Composable filter class to concatenate two datasets.

    Usage::
    
        filter = AppendFilter(hxl.data(url), hxl.data(url2))

    This filter concatenates a second dataset to the end of the first
    one. It supports the L{hxl.model.Dataset.append} convenience
    method, and the L{hxl.scripts.hxlappend} command-line script.

    The filter preserves the order of the columns in the first
    dataset. If there are any columns in the second dataset that do
    not appear in the first, then the behaviour depends on the value
    of the I{add_columns} property:

      - if C{True} (default), add extra columns from the second dataset
        (and leave their values blank for the first).
      - if C{False}, ignore extra columns from the second dataset.

    Note that HXL tags must match exactly, including any tag
    attributes, for two columns to be considered as matches.

    A common use case is be to start with an empty dataset as a
    template so that the columns and headers are as desired in the
    final output, then append other datasets to that, with
    I{add_columns} set to C{False} to ignore any extra data in the
    dataset.

    To append multiple datasets, chain the filters::

        filter = HXLAppend(HXLAppend(hxl.data(url), hxl.data(url2), False), hxl.data(url3), False)

    Or, more intuitively (using the convenience methods)::

        hxl.data(url).append(url2, False).append(url3, False)

    If you have an unknown number of URLs to append, try something
    like this::

        source = hxl.data(template_url)
        for url in my_list_of_urls:
            source = AppendFilter(source, url, True)

    It&#39;s also possible to be selective about what you append, using the I{queries} parameter::

        filter = AppendFilter(source, source2, queries=&#39;org=UNICEF&#39;)

    In the second dataset, this filter will include I{only} rows where
    the value &#34;UNICEF&#34; appears under the C{#org} tag.

    This class class is a special case, neither a L{streaming
    filter&lt;AbstractStreamingFilter&gt;} nor a L{caching
    filter&lt;AbstractCachingFilter&gt;}; instead, it streams two separate
    datasets, one starting after the other, so it extends
    L{AbstractBaseFilter} directly, and implements its own custom
    iterator.

    @see: L{MergeDataFilter}, which combines two datasets horizontally
    rather than vertically.

    &#34;&#34;&#34;

    def __init__(self, source, append_sources, add_columns=True, queries=[]):
        &#34;&#34;&#34;Construct a new I{AppendFilter}
        @param source: a L{hxl.model.Dataset} object for the principal data
        @param append_sources: one or more L{hxl.model.Dataset} objects for the dataset to append (or strings containing URLs)
        @param add_columns: flag for adding extra columns in append_sources but not source (default True)
        @param queries: optional list of L{hxl.model.RowQuery} objects
        (or a single strig) to select which rows to include from the
        second dataset
        &#34;&#34;&#34;
        super(AppendFilter, self).__init__(source)

        # parameters
        if is_sourcey(append_sources):
            append_sources = [append_sources]
        self.append_sources = [hxl.data(src) for src in append_sources] # so that we can take a plain URL
        &#34;&#34;&#34;The sources to append to this source&#34;&#34;&#34;
        self.add_extra_columns = add_columns
        &#34;&#34;&#34;If true, always add new columns instead of replacing existing ones&#34;&#34;&#34;
        self.queries = self._setup_queries(queries)
        &#34;&#34;&#34;The row queries to limit where we choose append candidates&#34;&#34;&#34;

        # internal properties
        self._column_positions = []
        &#34;&#34;&#34;Cache of column positions, to avoid rescanning on every pass&#34;&#34;&#34;
        self._template_row = []
        &#34;&#34;&#34;Empty template for appending to each row (will copy and fill in as needed&#34;&#34;&#34;

    def filter_columns(self):
        &#34;&#34;&#34;Internal: generate the columns for the combined dataset
        We expect this method to run only once.
        @returns: the output list of L{hxl.model.Column} objects
        &#34;&#34;&#34;

        columns_out = copy.deepcopy(self.source.columns)

        for i, append_source in enumerate(self.append_sources):

            columns_in = list(columns_out)
            self._column_positions.append({})

            # see if there&#39;s a corresponding column in the source
            for j, column in enumerate(append_source.columns):
                for k, original_column in enumerate(columns_in):
                    if column == original_column:
                        # yes, there is one; clear it, so it&#39;s not reused
                        self._column_positions[i][j] = k
                        columns_in[k] = None
                        break
                if self._column_positions[i].get(j) is None:
                    # no -- we need to add a new column
                    if self.add_extra_columns:
                        self._column_positions[i][j] = len(columns_out)
                        columns_out.append(copy.deepcopy(column))
                    else:
                        self._column_positions[i][j] = None

        # make an empty template for each row
        self._template_row = [&#39;&#39;] * len(columns_out)

        # return the (usually cached) columns
        return columns_out


    def __iter__(self):
        self.columns # make sure this is triggered first
        return AppendFilter._Iterator(self)

    class _Iterator:
        &#34;&#34;&#34;Custom iterator to return the contents of all sources, in sequence.&#34;&#34;&#34;

        def __init__(self, outer):
            &#34;&#34;&#34;@param outer: reference to outer object&#34;&#34;&#34;
            self.outer = outer
            
            self._iterator = iter(outer.source)
            self._column_map = {i: i for i in range(len(self.outer.source.columns))}
            self._is_source = True

            self._sources = list(self.outer.append_sources)
            self._column_positions = list(self.outer._column_positions)

        def __iter__(self):
            return self

        def __next__(self):

            def make_row():
                row_in = next(self._iterator)
                while ((not self._is_source) and (not hxl.model.RowQuery.match_list(row_in, self.outer.queries))):
                    row_in = next(self._iterator)

                row_out = hxl.model.Row(
                    columns=self.outer.columns,
                    values=copy.deepcopy(self.outer._template_row)
                )

                for i, value in enumerate(row_in.values):
                    pos = self._column_map[i]
                    if pos is not None:
                        row_out.values[pos] = value

                return row_out

            while self._iterator is not None:
                try:
                    return make_row()
                except StopIteration:
                    if self._sources:
                        self._iterator = iter(self._sources[0])
                        self._column_map = self._column_positions[0]
                        self._sources = self._sources[1:]
                        self._column_positions = self._column_positions[1:]
                        self._is_source = False
                    else:
                        self._iterator = None

            raise StopIteration()

    @staticmethod
    def parse_external_source_list(input):
        append_sources = []
        with hxl.data(input) as source:
            for row in source:
                append_source = row.get(&#39;#x_source&#39;)
                if append_source:
                    append_sources.append(append_source)
        return append_sources
        
    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create an AppendFilter from a dict spec.
        @param spec: the string specification
        &#34;&#34;&#34;

        if spec.get(&#39;filter&#39;) == &#39;append_external_list&#39;:
            append_sources = AppendFilter.parse_external_source_list(
                hxl.data(req_arg(spec, &#39;source_list_url&#39;))
            )
        else:
            append_sources = req_arg(spec, &#39;append_sources&#39;)
            
        return AppendFilter(
            source=source,
            append_sources=append_sources,
            add_columns=opt_arg(spec, &#39;add_columns&#39;, True),
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )


class CacheFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Composable filter to cache HXL data in memory.

    This filter saves a copy of the HXL data in memory. It supports
    the L{hxl.model.Dataset.cache} method, and has no corresponding
    command-line script.

    Does not extend AbstractCachingFilter, because it needs to
    preserve original row numbers (when they exist).

    While L{streaming filters&lt;AbstractStreamingFilter&gt;} are more
    efficient, sometimes you need to keep a copy of your HXL data in
    memory, so that you can iterate over it more than once. Some
    filters, like L{SortFilter} and L{CountFilter}, do that as a side
    effect, but you can also choose to add a I{CacheFilter} explicitly
    to your chain.

    This filter does nothing but save a copy of your data for repeated
    use, as in the following example::

      filter = Cache(hxl.data(url))

    or::

      filter = hxl.data(url).cache()

    It is also possible to cache just I{part} of the data, as a
    preview or to avoid crashing on excessively-large datasets::

      # cache just the first 10 rows
      preview = Cache(hxl.data(url), 10)

    If there were more rows of data available, then the filter will
    set the L{overflow} property to C{True}.

    You can also use the cache filter strategically in a filter chain
    to save the results of an expensive operation (like replacing
    data) to avoid repeating it.  For example, this sequence will
    never run the replacements more than once::

      filter = hxl.data(url).replace_data_map(map_url).cache().with_rows(&#39;org=UNICEF&#39;)

    &#34;&#34;&#34;

    def __init__(self, source, max_rows=None):
        &#34;&#34;&#34;Constructor
        @param source: the upstream data source
        @param max_rows: if &gt;0, maximum number of rows to cache
        &#34;&#34;&#34;
        super().__init__(source)

        self.max_rows = max_rows
        &#34;&#34;&#34;Maximum number of rows to keep in the cache (-1 means no limit)&#34;&#34;&#34;

        self.overflow = False
        &#34;&#34;&#34;Flag for whether there were more rows than L{max_rows} available.&#34;&#34;&#34;

        self.cached_rows = None

    @property
    def is_cached(self):
        return True

    def filter_columns(self):
        &#34;&#34;&#34;@returns: a deep copy of the source columns&#34;&#34;&#34;
        return copy.deepcopy(self.source.columns)

    def __iter__(self):

        # if we haven&#39;t read the source yet, cache some rows
        if self.cached_rows is None:
            self.cached_rows = []
            for row_number, row in enumerate(self.source):
                # is there a limit?
                if self.max_rows is not None and row_number &gt;= self.max_rows:
                    self.overflow = True
                    break
                else:
                    self.cached_rows.append(row)

        # return the iterator over the cached rows (repeatable)
        return iter(self.cached_rows)

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a new CacheFilter from a dict spec.&#34;&#34;&#34;
        return CacheFilter(
            source=source,
            max_rows=opt_arg(spec, &#39;max_rows&#39;, None)
        )


class CleanDataFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Data-cleaning filter.

    This filter can perform a set of automated cleaning tasks,
    including character-case conversion, whitespace normalisation, and
    date and number normalisation. It supports the
    L{hxl.model.Dataset.clean_data} method and the
    L{hxl.scripts.hxlclean} command-line script.

    The clean filter is especially useful when you are working with
    data from different sources who might use different date and
    number conventions, and also for datasets with inconsistent
    whitespace and capitalisation. The following functions are
    available (and can be filtered by row and column):

      - B{whitespace}: strip leading/trailing spaces, and normalise
        all internal whitespace (including lineends) to a single
        space.
      - B{upper}: convert text to all uppercase.
      - B{lower}: convert text to all lowercase.
      - B{date}: attempt to parse and normalise dates to ISO 8601
        format (YYYY-MM-DD). This will not always succeed -- for
        example, it is impossible to guess whether &#34;9/6/15&#34; refers to
        6 September 2016 or 9 June 2016 (hence the need for ISO dates)
        -- but it will do its best.
      - B{number}: attempt to normalise numbers to standard computer
        format (remove commas or spaces between thousands, and use &#34;.&#34;
        as the decimal separator).
      - B{latlon}: attempt to normalise latitude and longitude values.
      
    For each type of cleaning, you specify one or more L{tag
    patterns&lt;hxl.model.TagPattern&gt;} to which the cleaning applies (you
    may use string representations instead of creating the objects),
    or use C{True} to apply the cleaning to the whole row. You may
    also include L{hxl.model.RowQuery} objects to apply the cleaning
    tasks only to specific rows. You can also specify a format for
    normalised dates or numbers, and choose to purge any dates,
    numbers, or latlon that can&#39;t be parsed (to guarantee clean data,
    at the cost of possible information loss).

    This example normalises all start dates from Oxfam::

      filter = CleanFilter(hxl.data(&#39;data.csv&#39;), dates=&#39;date+start&#39;, queries=&#39;org=Oxfam&#39;)

      # or

      filter = hxl.data(&#39;data.csv&#39;).clean_data(dates=&#39;date+start&#39;, queries=&#39;org=Oxfam&#39;)

    @see: L{ReplaceDataFilter}, which allows for more-specific
    replacements using string and regular-expression patterns.
    &#34;&#34;&#34;

    def __init__(
            self, source, whitespace=False, upper=[], lower=[], date=[], date_format=None,
            number=[], number_format=None, latlon=[], purge=False, queries=[]):
        &#34;&#34;&#34;Construct a new data-cleaning filter.

        The I{upper}, I{lower}, I{date}, I{number}, and I{latlon}
        arguments all accept either lists of tag
        patterns&lt;hxl.model.TagPattern or individual patterns, which
        can be strings (like C{#org+impl-code}) or full
        L{hxl.model.TagPattern} objects. The I{queries} argument
        accepts either lists of queries or individual queries, which
        can be strings (like C{org=Oxfam}) or full
        L{hxl.model.RowQuery} objects.

        @param source: a L{hxl.model.Dataset} object to filter
        @param whitespace: a tag pattern or list of tag patterns for whitespace normalisation
        @param upper: a tag pattern or list of tag patterns for conversion to uppercase
        @param lower: a tag pattern or list of tag patterns for conversion to lowercase
        @param date: a tag pattern or list of tag patterns for date normalisation
        @param date_format: a date-format string for output, as used by strftime
        @param number: a tag pattern or list of tag patterns for number normalisation
        @param number_format: a number-format string for output, as used by format.
        @param laton: a list of tag patterns for normalising latitude/longitude.
        @param purge: if True, remove any dates, numbers, or lat/lon that can&#39;t be parsed during cleaning.
        @param queries: optional list of queries to select rows to be cleaned.
        &#34;&#34;&#34;
        super(CleanDataFilter, self).__init__(source)
        self.whitespace = hxl.model.TagPattern.parse_list(whitespace)
        self.upper = hxl.model.TagPattern.parse_list(upper)
        self.lower = hxl.model.TagPattern.parse_list(lower)
        self.date = hxl.model.TagPattern.parse_list(date)
        self.date_format = date_format
        self.number = hxl.model.TagPattern.parse_list(number)
        self.number_format = number_format
        self.latlon = hxl.model.TagPattern.parse_list(latlon)
        self.purge = purge
        self.queries = self._setup_queries(queries)

        # We need to prescan for dates
        if date:
            self.source = self.source.cache();
            self.date_dayfirst = self._guess_dayfirst()

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: cleaned row data&#34;&#34;&#34;
        if hxl.model.RowQuery.match_list(row, self.queries):
            # if there are no queries, or row matches at least one
            columns = self.columns
            values = copy.copy(row.values)
            for i in range(min(len(values), len(columns))):
                values[i] = self._clean_value(values[i], columns[i])
            return values
        else:
            # otherwise, leave as-is
            return row.values

    def _guess_dayfirst(self):
        &#34;&#34;&#34;Guess whether the default should be DD-MM-YYYY or MM-DD-YYYY
        @returns: true if we should default to dayfirst format
        &#34;&#34;&#34;
        ddmm_count = 0
        mmdd_count = 0
        
        # prescan columns to speed things up
        indices = []
        for i, column in enumerate(self.source.columns):
            if hxl.TagPattern.match_list(column, self.date):
                indices.append(i)

        # if there are any matching columns, then prescan values
        if indices:
            for row in self.source:
                for i in indices:
                    value = row.values[i]
                    if value:
                        result = re.match(r&#39;^[^\d]*(\d\d?)[^\d]+(\d\d?)[^\d].*$&#39;, hxl.datatypes.normalise_string(value))
                        if result:
                            if int(result.group(1)) &gt; 12:
                                ddmm_count += 1
                            elif int(result.group(2)) &gt; 12:
                                mmdd_count += 1

        return (ddmm_count &gt;= mmdd_count)

    
    def _clean_value(self, value, column):
        &#34;&#34;&#34;Clean a single value, using the column def for guidance.
        @returns: a single cleaned value
        &#34;&#34;&#34;
        value = str(value)

        # Whitespace (-w)
        if self._match_patterns(self.whitespace, column):
            value = re.sub(r&#39;^\s+&#39;, &#39;&#39;, value)
            value = re.sub(r&#39;\s+$&#39;, &#39;&#39;, value)
            value = re.sub(r&#39;\s+&#39;, &#39; &#39;, value)

        # Uppercase (-u)
        if self._match_patterns(self.upper, column):
            value = value.upper()

        # Lowercase (-l)
        if self._match_patterns(self.lower, column):
            value = value.lower()

        # Date
        if self._match_patterns(self.date, column):
            if value:
                try:
                    value = hxl.datatypes.normalise_date(value, self.date_dayfirst)
                    if self.date_format is not None:
                        value = dateutil.parser.parse(value).strftime(self.date_format)
                except ValueError:
                    logger.warning(&#39;Cannot parse %s as a date&#39;, str(value))
                    if self.purge:
                        value = &#39;&#39;

        # Number
        if self._match_patterns(self.number, column):

            def try_number(s):
                try:
                    n = float(s)
                    if self.number_format:
                        return format(n, self.number_format)
                    elif n.is_integer():
                        return str(int(n))
                    else:
                        return str(n)
                except:
                    return None

                # fixme - get much smarter about numbers
            if value:
                n = try_number(value)
                if n is None:
                    s = re.sub(r&#39;[^\de.]+&#39;, &#39;&#39;, value)
                    n = try_number(s) # OK, try again
                if n is not None:
                    value = n
                else:
                    logger.warning(&#39;Cannot parse {} as a number&#39;, str(value))
                    if self.purge:
                        value = &#39;&#39;

        # Latlon
        if self._match_patterns(self.latlon, column):
            if &#39;lat&#39; in column.attributes:
                lat = hxl.geo.parse_lat(value)
                if lat is not None:
                    value = format(lat, &#39;0.4f&#39;)
                else:
                    logger.warning(&#39;Cannot parse %s as a latitude&#39;, str(value))
                    if self.purge:
                        value = &#39;&#39;
            elif &#39;lon&#39; in column.attributes:
                lon = hxl.geo.parse_lon(value)
                if lon is not None:
                    value = format(lon, &#39;0.4f&#39;)
                else:
                    logger.warning(&#39;Cannot parse %s as a longitude&#39;, str(value))
                    if self.purge:
                        value = &#39;&#39;
            elif &#39;coord&#39; in column. attributes:
                coord = hxl.geo.parse_coord(value)
                if coord is not None:
                    value = &#39;{:.4f},{:.4f}&#39;.format(coord[0], coord[1])
                else:
                    logger.warning(&#39;Cannot parse %s as geographical coordinates&#39;, str(value))
                    if self.purge:
                        value = &#39;&#39;
        
        return value

    def _match_patterns(self, patterns, column):
        &#34;&#34;&#34;Test if a column matches a list of patterns.
        @param patterns: a list of tag patterns to match
        @param column: the column definition to test
        @returns: C{True} if the column matches at least one pattern in the list
        &#34;&#34;&#34;
        if not patterns:
            return False
        else:
            for pattern in patterns:
                if pattern.match(column):
                    return True
            return False

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a new clean-data filter from a dict spec.
        @returns: a L{CleanDataFilter} object
        &#34;&#34;&#34;
        return CleanDataFilter(
            source=source,
            whitespace=opt_arg(spec,&#39;whitespace&#39;, []),
            upper=opt_arg(spec, &#39;upper&#39;, []),
            lower=opt_arg(spec, &#39;lower&#39;, []),
            date=opt_arg(spec, &#39;date&#39;, []),
            date_format=opt_arg(spec, &#39;date_format&#39;, None),
            number=opt_arg(spec, &#39;number&#39;, []),
            number_format=opt_arg(spec, &#39;number_format&#39;, None),
            latlon=opt_arg(spec, &#39;latlon&#39;, []),
            purge=opt_arg(spec, &#39;purge&#39;, False),
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )


class ColumnFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Composable filter class to remove columns from a HXL dataset.

    This filter supports removing columns based on either an include
    list or an exclude list of L{tag
    patterns&lt;hxl.model.TagPattern&gt;}. It supports the
    L{hxl.model.Dataset.with_columns} and
    L{hxl.model.Dataset.without_columns} convenience methods and the
    L{hxl.scripts.hxlcut} command-line script.

    Remove all columns matching the pattern &#34;#contact+email&#34; from the
    dataset::

      filter = ColumnFilter(hxl.data(url), exclude_tags=&#39;contact+email&#39;)

      # or

      filter = hxl.data(url).without_columns(&#39;contact+email&#39;)

    Remove all columns I{except} those matching the patterns &#39;#org&#39;,
    &#39;#sector&#39;, and &#39;#activity&#39;::

      filter = ColumnFilter(hxl.data(url), include_tags=[&#39;org&#39;, &#39;sector&#39;, &#39;activity&#39;])

      # or

      filter = hxl.data(url).with_columns([&#39;org&#39;, &#39;sector&#39;, &#39;activity&#39;])

    @see: L{RowFilter}

    &#34;&#34;&#34;

    def __init__(self, source, include_tags=[], exclude_tags=[], skip_untagged=False):
        &#34;&#34;&#34;Construct a column filter.
        @param source: a L{hxl.model.Dataset}
        @param include_tags: an include list of L{tag patterns&lt;hxl.model.TagPattern&gt;} objects to include
        @param exclude_tags: an exclude list of tag patterns objects to exclude
        @param skip_untagged: True if all columns without HXL hashtags should be removed
        &#34;&#34;&#34;
        super(ColumnFilter, self).__init__(source)
        self.include_tags = hxl.model.TagPattern.parse_list(include_tags)
        self.exclude_tags = hxl.model.TagPattern.parse_list(exclude_tags)
        self.skip_untagged = skip_untagged
        self.indices = [] # saved indices for columns to include

    def filter_columns(self):
        &#34;&#34;&#34;@returns: filtered list of column definitions&#34;&#34;&#34;
        columns_in = self.source.columns
        columns_out = []
        for i in range(len(columns_in)):
            if self._test_column(columns_in[i]):
                columns_out.append(copy.deepcopy(columns_in[i]))
                self.indices.append(i) # save index to avoid retesting for data
        return columns_out

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: filtered list of row values&#34;&#34;&#34;
        values = []
        for i in self.indices:
            try:
                values.append(row.values[i])
            except IndexError:
                pass # don&#39;t add anything
        return values

    def _test_column(self, column):
        &#34;&#34;&#34;Test whether a column should be included in the output.  If there
        is an include list, it must be in that list; if there is an
        exclude list, it must not be in that list.

        @param column: the L{hxl.model.Column} to test 
        @returns: True if the column should be included

        &#34;&#34;&#34;
        if self.include_tags:
            # exclude list
            for pattern in self.include_tags:
                if pattern.match(column):
                    # succeed as soon as we match an included pattern
                    return True
            # fail if there was an exclude list and we didn&#39;t match
            return False

        if self.exclude_tags or self.skip_untagged:
            # skip untagged columns?
            if self.skip_untagged and not column.tag:
                return False
            # exclude list
            for pattern in self.exclude_tags:
                if pattern.match(column):
                    # fail as soon as we match an excluded pattern
                    return False

        # not an include list, and no reason to exclude
        return True

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a filter object from a JSON-like spec.
        Note that there are two JSON filter definitions for this class: &#34;with_columns&#34; and &#34;without_columns&#34;.
        @param spec: the specification
        @returns: a L{ColumnFilter} object
        &#34;&#34;&#34;
        if spec.get(&#39;filter&#39;) == &#39;with_columns&#39;:
            return ColumnFilter(
                source=source,
                include_tags=req_arg(spec, &#39;includes&#39;)
            )
        else:
            return ColumnFilter(
                source=source,
                exclude_tags=req_arg(spec, &#39;excludes&#39;),
                skip_untagged=opt_arg(spec, &#39;skip_untagged&#39;)
            )


class CountFilter(AbstractCachingFilter):
    &#34;&#34;&#34;Composable filter class to aggregate rows in a HXL dataset (like a pivot table)

    This class supports the L{hxl.model.Dataset.count} convenience
    method and the L{hxl.scripts.hxlcount} command-line script.

    This is a L{caching filter&lt;AbstractCachingFilter&gt;} that performs
    aggregate actions such as counting, summing, and averaging across
    multiple rows of data. For example, it can reduce a dataset to a
    list of the number of times that each organisation or sector
    appears. This is the main filter for producing reports, or the
    data underlying charts and other visualisations; it is also useful
    for anonymising data by rolling it up to higher levels of
    abstraction.

    This example counts the number of rows for each organisation::

      filter = CountFilter(hxl.data(url), &#39;org&#39;)

      # or

      filter = hxl.data(url).count(&#39;org&#39;)

    You can do multiple levels of counting like this::

      filter = hxl.data(url).count([&#39;org&#39;, &#39;sector&#39;])

    You can also use the I{queries} argument to limit the counting to
    specific fields. This example will count only the rows where C{#adm1} is set to &#34;Coast&#34;::

      filter = hxl.data(url).count(&#39;org&#39;, queries=&#39;adm1=Coast&#39;)
    &#34;&#34;&#34;

    def __init__(self, source, patterns, aggregators=None, queries=[]):
        &#34;&#34;&#34;Construct a new count filter
        If the caller does not supply any aggregators, use &#34;count() as Count#meta+count&#34;
        @param source: a L{hxl.model.Dataset}
        @param patterns: a single L{tag pattern&lt;hxl.model.TagPattern&gt;} or list of tag patterns that, together, form a unique key for counting.
        @param aggregators: one or more Aggregator objects or string representations to define the output.
        @param queries: an optional list of L{row queries&lt;hxl.model.RowQuery&gt;} to filter the rows being counted.
        &#34;&#34;&#34;
        super().__init__(source)
        self.patterns = hxl.model.TagPattern.parse_list(patterns)
        if not aggregators:
            aggregators = &#39;count() as Count#meta+count&#39;
        self.aggregators = Aggregator.parse_list(aggregators)
        self.queries = self._setup_queries(queries)

    def filter_columns(self):
        &#34;&#34;&#34;@returns: the filtered columns&#34;&#34;&#34;
        columns = []

        # Add columns being counted
        for pattern in self.patterns:
            column = pattern.find_column(self.source.columns)
            if column:
                columns.append(copy.deepcopy(column))
            else:
                columns.append(hxl.Column())

        # Add generated columns
        for aggregator in self.aggregators:
            columns.append(aggregator.column)
            
        return columns

    def filter_rows(self):
        &#34;&#34;&#34;@returns: the filtered row values&#34;&#34;&#34;

        raw_data = []

        # each item is a sequence containing a tuple of key values and an _Aggregator object
        for aggregate in self._aggregate_data():
            raw_data.append(
                list(aggregate[0]) + [aggregator.value if aggregator.value is not None else &#39;&#39; for aggregator in aggregate[1]]
            )
            
        return raw_data

    def _aggregate_data(self):
        &#34;&#34;&#34;Read the entire source dataset and produce saved aggregate data.
        @returns: the aggregated values as raw data
        &#34;&#34;&#34;
        aggregators = {}

        # read the whole source dataset at once
        for row in self.source:
            # will always match if there are no queries
            if hxl.model.RowQuery.match_list(row, self.queries):
                # get the values in the order we need them
                values = [hxl.datatypes.normalise_space(row.get(pattern, default=&#39;&#39;)) for pattern in self.patterns]
                # make a dict key for the aggregator
                key = tuple(values)
                if not key in aggregators:
                    aggregators[key] = [copy.deepcopy(aggregator) for aggregator in self.aggregators]
                for aggregator in aggregators[key]:
                    aggregator.evaluate_row(row)

        # sort the aggregators by their keys
        return sorted(aggregators.items())

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a new count filter from a dict spec.
        @param spec: the JSON-like spec
        @returns: a new L{CountFilter} object
        &#34;&#34;&#34;
        return CountFilter(
            source = source,
            patterns=opt_arg(spec, &#39;patterns&#39;),
            aggregators=opt_arg(spec, &#39;aggregators&#39;, None),
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )


class DeduplicationFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Composable filter to deduplicate a HXL dataset.

    Removes duplicate lines from a dataset, where &#34;duplicate&#34; is
    optionally defined by a set of keys specified by the user. As a
    result, not all values in duplicate rows will necessarily be
    identical. The filter will always return the *first* matching row
    of a set of duplicates.

    Supports the hxldedup command-line script.

    TODO: add more-sophisticated matching, edit distance, etc.
    &#34;&#34;&#34;

    def __init__(self, source, patterns=None, queries=[]):
        &#34;&#34;&#34;
        Constructor
        @param source: the upstream source dataset
        @param patterns: if provided, a list of tag patterns for columns to use for uniqueness testing.
        @param filters: optional list of filter queries for columns to be considered for deduplication.
        &#34;&#34;&#34;
        super().__init__(source)
        self.patterns = hxl.model.TagPattern.parse_list(patterns)
        self.seen_map = set() # row signatures that we&#39;ve seen so far
        self.queries = self._setup_queries(queries)

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: the row&#39;s values, or C{None} if it&#39;s a duplicate&#34;&#34;&#34;
        if hxl.model.RowQuery.match_list(row, self.queries):
            if not row:
                return None
            key = row.key(self.patterns)
            if key in self.seen_map:
                return None
            # if we get to here, we haven&#39;t seen the row before
            self.seen_map.add(key)
            return copy.copy(row.values)
        else:
            return row.values

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a dedup filter from a dict spec.
        @param source: the upstream source
        @param spec: the JSON-like spec
        @returns: a L{DeduplicationFilter} object
        &#34;&#34;&#34;
        return DeduplicationFilter(
            source = source,
            patterns=opt_arg(spec, &#39;patterns&#39;, []),
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )


class ExpandListsFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Expand in-cell lists by duplicating data rows.
    &#34;&#34;&#34;

    def __init__(self, source, patterns=None, separator=&#34;|&#34;, correlate=False, queries=[]):
        super().__init__(source)
        self.separator = str(separator)
        self.scan_columns(patterns)
        self.correlate = correlate
        self.queries = self._setup_queries(queries)
        &#34;&#34;&#34;The row queries to limit where we expand lists&#34;&#34;&#34;

    def filter_columns(self):
        &#34;&#34;&#34; Remove the +list attribute from targeted columns &#34;&#34;&#34;
        columns = list(self.source.columns)
        for index in self.column_indices:
            column = copy.deepcopy(columns[index])
            column.remove_attribute(&#39;list&#39;)
            columns[index] = column
        return columns

    def scan_columns(self, patterns):
        &#34;&#34;&#34; Save the indices of the columns containing lists &#34;&#34;&#34;
        self.column_indices = []
        if patterns:
            patterns = hxl.model.TagPattern.parse_list(patterns)
            for i, column in enumerate(self.source.columns):
                if hxl.model.TagPattern.match_list(column, patterns):
                    self.column_indices.append(i)
        else:
            for i, column in enumerate(self.source.columns):
                if column.has_attribute(&#34;list&#34;):
                    self.column_indices.append(i)

    def __iter__(self):

        # Special case: no columns to expand
        if len(self.column_indices) == 0:
            for row in self.source:
                yield row
            return


        # Regular case

        min_length = max(self.column_indices) + 1

        for row in self.source:

            # If there are queries, the row must match one of them
            if not hxl.model.RowQuery.match_list(row, self.queries):
                yield row
                continue

            # parse the lists
            value_lists = []
            for index in self.column_indices:
                if index &lt; len(row.values):
                    values = str(row.values[index]).split(self.separator)
                    value_lists.append(list(map(hxl.datatypes.normalise_space, values)))
                else:
                    value_lists.append([&#34;&#34;])

            if (self.correlate):
                # correlate the lists

                nrows = max([len(item) for item in value_lists])

                for i in range(0, nrows):
                    values = copy.deepcopy(row.values)
                    for j, v in enumerate(value_lists):
                        index = self.column_indices[j]
                        if len(v) &lt;= i:
                            values[index] = &#34;&#34;
                        else:
                            values[index] = v[i]
                    yield hxl.model.Row(self.columns, values)

            else:
                # generate the cartesian product of all the lists

                # generate the cartesian product of the values
                row_value_list = list(itertools.product(*value_lists))

                # yield all of the resulting rows
                for row_values in row_value_list:
                    values = copy.deepcopy(row.values)

                    # make sure the value list is long enough
                    if len(values) &lt; min_length:
                        values += [&#34;&#34;] * (min_length - len(values))

                    # replace the list values
                    for i, value in enumerate(row_values):
                        values[self.column_indices[i]] = value

                    # yield a new row
                    yield hxl.model.Row(self.columns, values)

        
    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;New instance from a JSON-style dictionary.
        @param source: the upstream data source
        @param spec: the JSON-style specification
        &#34;&#34;&#34;
        return ExpandListsFilter(
            source=source,
            patterns=opt_arg(spec, &#39;patterns&#39;),
            separator=opt_arg(spec, &#39;separator&#39;),
            correlate=opt_arg(spec, &#39;correlate&#39;),
            queries=opt_arg(spec, &#39;queries&#39;)
        )


class ExplodeFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Explode a wide (series) dataset into a long version.

    Every set of identically-tagged columns that contain the +label
    attribute in their hashtag will get their own row, with the header
    text and the value side by side.  For example,

    Country,2015,2014,2013
    #country,#affected+label,#affected+label,#affected+label
    Cameroon,100,150,120

    will be converted to

    Country,Header,Value
    #country,#affected+header,#affected+value
    Cameroon,2015,100
    Cameroon,2014,150
    Cameroon,2015,120

    (You can use the RenameFilter to change the names and hashtags of
    the generated columns.)

    @see: hxl.model.Dataset.explode
    @see: hxl.filters.ImplodeFilter
    &#34;&#34;&#34;

    def __init__(self, source, header_attribute=&#39;header&#39;, value_attribute=&#39;value&#39;):
        &#34;&#34;&#34;
        Constructor
        @param source: the upstream source dataset
        @param header_attribute: the attribute to add to the hashtag for the column with the former header (default: &#39;header&#39;)
        @param value_attribute: the attribute to add to the hashtag for the column with the former header (default: &#39;value&#39;)
        &#34;&#34;&#34;
        super(ExplodeFilter, self).__init__(source)
        self.header_attribute = header_attribute
        &#34;&#34;&#34;Attribute to add to exploded values from the header&#34;&#34;&#34;
        self.value_attribute = value_attribute
        &#34;&#34;&#34;Attribute to add to the original value from the data cell&#34;&#34;&#34;
        self._generator = None
        self._plan = self._make_plan()

    def filter_columns(self):
        &#34;&#34;&#34;@returns: the new (exploded) column headers&#34;&#34;&#34;
        columns = []
        for spec in self._plan:
            if isinstance(spec, list):
                model_column = self.source.columns[spec[0]]
                columns.append(copy.deepcopy(model_column).remove_attribute(&#39;label&#39;).add_attribute(self.header_attribute))
                columns.append(copy.deepcopy(model_column).remove_attribute(&#39;label&#39;).add_attribute(self.value_attribute))
            else:
                columns.append(self.source.columns[spec])
        return columns

    def __iter__(self):
        &#34;&#34;&#34;Custom iterator to produce exploded rows.&#34;&#34;&#34;
        for row in self.source:
            for values in self._expand(row, self._plan):
                yield hxl.model.Row(self.columns, values)

    def _expand(self, row, plan, values_in=[]):
        &#34;&#34;&#34;Recursive generator for the row data.
        https://wiki.python.org/moin/Generators
        @param row: the row to expland
        @param plan: the pre-generated expansion plan
        @param values_in: the input values
        &#34;&#34;&#34;
        if not plan: # terminal condition
            yield values_in
        else:
            spec = plan[0]
            plan = plan[1:]
            if isinstance(spec, list): # multiple branches
                for index in spec:
                    values = values_in + [row.columns[index].header, row.values[index]]
                    for values_out in self._expand(row, plan, values):
                        yield values_out
            else: # continue on a single branch
                values = values_in + [row.values[spec]]
                for values_out in self._expand(row, plan, values):
                    yield values_out

    def _make_plan(self):
        &#34;&#34;&#34;Create an expansion plan
        The plan is a list of integers, representing columns in the original source.
        Some items are lists of integers, representing variants to show for multiple rows.
        @returns: an expansion plan for the row
        &#34;&#34;&#34;
        plan = []
        groups = {}
        for index, column in enumerate(self.source.columns):
            if &#39;label&#39; in column.attributes:
                if column not in groups:
                    plan.append([index])
                    groups[column] = len(plan) - 1;
                else:
                    plan[groups.get(column)].append(index)
            else:
                plan.append(index)
        return plan

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create an explode filter from a dict spec.
        @param source: the upstream source
        @param spec: the JSON-like filter specification
        @returns: an L{ExplodeFilter} object
        &#34;&#34;&#34;
        return ExplodeFilter(
            source=source,
            header_attribute=opt_arg(spec, &#39;header_attribute&#39;, &#39;header&#39;),
            value_attribute=opt_arg(spec, &#39;value_attribute&#39;, &#39;value&#39;)
        )


class ImplodeFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Implode a long (series) dataset into a wide version.

    The first column matching the pattern will be used as headers. For example, with the tag pattern #date+year,

    Country,Header,Value
    #country,#date+year,#affected
    Cameroon,2015,100
    Cameroon,2014,150
    Cameroon,2015,120

    will be converted to 

    Country,2015,2014,2013
    #country,#affected+label,#affected+label,#affected+label
    Cameroon,100,150,120

    @see: hxl.model.Dataset.implode
    @see: hxl.filters.ExplodeFilter
    &#34;&#34;&#34;

    def __init__(self, source, label_pattern, value_pattern):
        &#34;&#34;&#34; Constructor
        @param source: the upstream source dataset
        @param pattern: the tag pattern to use for the labels
        @param output_tagspec: the tagspec to use for the repeated, wide columns
        &#34;&#34;&#34;
        super(ImplodeFilter, self).__init__(source)
        self.label_pattern = label_pattern
        self.value_pattern = value_pattern
        
        self.processed = False
        self.label_index = -1
        self.value_index = -1
        self.labels = set()
        self.rows = dict()
        self.new_columns = None
        self.source_iterator = None

    def filter_columns(self):
        &#34;&#34;&#34;@returns: the new (exploded) column headers&#34;&#34;&#34;
        if self.new_columns is None:
            self.process()
            # add existing columns (excluding label and value columns)
            self.new_columns = []
            for i, column in enumerate(self.source.columns):
                if i != self.label_index and i != self.value_index:
                    self.new_columns.append(column)

            # add extra columns for new, &#34;wide&#34; data
            model = self.source.columns[self.value_index]
            for label in sorted(self.labels):
                attributes = set(model.attributes)
                attributes.add(&#34;label&#34;)
                column = hxl.model.Column(tag=model.tag, attributes=attributes, header=label)
                self.new_columns.append(column)

        return self.new_columns

    def __iter__(self):
        &#34;&#34;&#34;Custom iterator to produce exploded rows.&#34;&#34;&#34;
        self.process()
        for key in self.rows:
            values = list(key)
            # extra, wide values
            for label in sorted(self.labels):
                values.append(self.rows[key].get(label, &#34;&#34;))
            yield hxl.model.Row(self.columns, values)

    def process(self):
        # check if we&#39;ve already done all this
        if self.processed:
            return

        # determine the indices of the label and value columns
        # if either is missing, just pass on the source data normally (with logged errors)
        lpattern = hxl.model.TagPattern.parse(self.label_pattern)
        vpattern = hxl.model.TagPattern.parse(self.value_pattern)
        for i, column in enumerate(self.source.columns):
            if lpattern.match(column):
                if self.label_index == -1:
                    self.label_index = i
                else:
                    logger.warning(
                        &#34;[Implode filter] multiple columns match label pattern %s; using first match %s (%s)&#34;,
                        self.label_pattern,
                        self.source.columns[self.label_index].display_tag,
                        self.source.columns[self.label_index].header
                    )
            if vpattern.match(column):
                if self.value_index == -1:
                    self.value_index = i
                else:
                    logger.warning(
                        &#34;[Implode filter] multiple columns match value pattern %s; using first match&#34;,
                        self.value_pattern,
                        self.source.columns[self.value_index].display_tag,
                        self.source.columns[self.value_index].header
                    )

        if self.label_index == -1:
            raise HXLFilterException(&#34;No matching label column for {}&#34;.format(self.label_pattern))
        
        if self.value_index == -1:
            raise HXLFilterException(&#34;No matching value column for {}&#34;.format(self.value_pattern))

        # iterate through the dataset
        for row in self.source:

            values = list(row.values)

            # get the &#34;wide&#34; label and value
            label = &#34;&#34;
            if self.label_index &lt; len(values):
                label = values[self.label_index]

            self.labels.add(label)

            value = &#34;&#34;
            if self.value_index &lt; len(values):
                value = values[self.value_index]

            # make a key tuple, excluding the label and value columns
            values = []
            for i, value in enumerate(row.values):
                if i != self.label_index and i != self.value_index:
                    values.append(value)
            key = tuple(values)

            # check to see if we already have data for that key
            if key not in self.rows:
                self.rows[key] = {}
            if label in self.rows[key]:
                logger.error(&#34;Multiple values for %s in implode filter; using %s&#34;, label, self.rows[key][label])
            else:
                self.rows[key][label] = value
            
    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create an implode filter from a dict spec.
        @param source: the upstream source
        @param spec: the JSON-like filter specification
        @returns: an L{ImplodeFilter} object
        &#34;&#34;&#34;
        return ImplodeFilter(
            source=source,
            label_pattern=req_arg(spec, &#39;label_pattern&#39;),
            value_pattern=req_arg(spec, &#39;value_pattern&#39;)
        )


class MergeDataFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Composable filter class to merge values from two HXL datasets.

    Merges the values for the *last* matching row in the merge
    dataset. Can use patterns to match multiple cells for merging
    (using all candidate columns when there are muliple columns
    matching the same hashtag pattern). Can overwrite existing columns
    and values.

    Warning: this filter may store a large amount of data in memory,
    depending on the merge.

    Usage:

    &lt;pre&gt;
    MergeDataFilter(source, merge_source=merge_source, keys=&#39;adm1+code&#39;, tags=&#39;adm1+name&#39;)
    &lt;/pre&gt;

    &lt;pre&gt;
    hxl.data(url).merge_data(merge_source=merge_source, keys=&#39;adm1+code&#39;, tags=&#39;adm1+name&#39;)
    &lt;/pre&gt;

    (Add the column matching #adm1+name from the merge dataset to the
    source dataset, syncing the rows using the value of #adm1+code in
    each dataset.)

    @see hxl.model.Dataset.merge_data
    @see hxl.scripts.hxlmerge_main
    &#34;&#34;&#34;

    def __init__(self, source, merge_source, keys, tags, replace=False, overwrite=False, queries=[]):
        &#34;&#34;&#34;
        Constructor.
        @param source: the HXL data source.
        @param merge_source: a second HXL data source to merge into the first.
        @param keys: the shared key hashtags to use for the merge
        @param tags: the tags to include from the second dataset
        @param replace: if True, replace existing columns when possible
        @param overwrite: if True, overwrite non-empty values in existing columns
        @param queries: optional list of filter queries for rows to be considered from the merge dataset.
        &#34;&#34;&#34;
        super().__init__(source)
        self.merge_source = merge_source
        &#34;&#34;&#34;The source dataset for pulling merged values&#34;&#34;&#34;
        self.keys = hxl.model.TagPattern.parse_list(keys)
        &#34;&#34;&#34;The shared keys for merging&#34;&#34;&#34;
        self.merge_tags = hxl.model.TagPattern.parse_list(tags)
        &#34;&#34;&#34;The merged values to pull from the merge_source&#34;&#34;&#34;
        self.replace = replace
        &#34;&#34;&#34;If True, replace columns when possible&#34;&#34;&#34;
        self.overwrite = overwrite
        &#34;&#34;&#34;If true, overwrite non-empty values in existing columns&#34;&#34;&#34;
        self.queries = self._setup_queries(queries)
        &#34;&#34;&#34;Query to filter rows to be merged&#34;&#34;&#34;
        self._merge_indices = []
        &#34;&#34;&#34;Indices for mapping columns from merge source to output dataset
        [source_index, output_index, overwrite_ok]
        &#34;&#34;&#34;
        self._merge_values = None
        &#34;&#34;&#34;Dictionary of values from merge source, indexed by key.&#34;&#34;&#34;

    def filter_columns(self):
        &#34;&#34;&#34;Filter the columns to add newly-merged ones.  
        Note: this is called only once, the first time someone
        accesses the Dataset.columns property, then the result is saved for future use.
        As a side effect, builds the _merge_indices specs for generating the merged data.
        @see hxl.filters.AbstractBaseFilter.filter_columns
        &#34;&#34;&#34;

        new_columns = list(self.source.columns)
        &#34;&#34;&#34;The new column list to return.&#34;&#34;&#34;
        
        merge_column_index = len(self.source.columns)
        &#34;&#34;&#34;Target index for merging into the output dataset&#34;&#34;&#34;
            
        # Check every pattern
        for pattern in self.merge_tags:

            # Check the pattern against every column
            for index, column in enumerate(self.merge_source.columns):

                seen_replacement = False
                &#34;&#34;&#34;We can replace inline exactly once for every pattern.&#34;&#34;&#34;

                if pattern.match(column):

                    # Replace inside existing columns, if conditions are met
                    if self.replace and not seen_replacement and pattern.find_column(self.source.columns):
                        # TODO: check for closest match
                        # TODO: allow for multiple replacements per pattern
                        self._merge_indices.append([index, pattern.find_column_index(self.source.columns), self.overwrite])
                        seen_replacement = True

                    # Replace into a new column on the right
                    else:
                        new_columns.append(column)
                        self._merge_indices.append([index, merge_column_index, True])
                        merge_column_index += 1

        return new_columns

    def filter_row(self, row):
        &#34;&#34;&#34;Set up a merged data row, replacing existing values if requested.
        Uses the _merge_indices map created by filter_columns.
        @param row: the data row to filter.
        @returns: a list of filtered values for the row.
        @see hxl.filters.AbstractStreamingFilter.filter_row
        &#34;&#34;&#34;

        # First, check if we already have the merge map, and read it if not
        if self._merge_values is None:
            self._merge_values = self._read_merge()

        # Make an initial array of the correct length
        values = copy.copy(row.values)
        values += ([&#39;&#39;] * (len(self.columns) - len(row.values)))

        # Look up the merge values, based on the keys
        for key in self._make_keys(row):
            merge_values = self._merge_values.get(key)
            if merge_values:
                for i, spec in enumerate(self._merge_indices):
                    if spec[2] or hxl.datatypes.is_empty(values[spec[1]]):
                        values[spec[1]] = merge_values[i]

        return values

    def _make_keys(self, row):
        &#34;&#34;&#34;Return all possible key-value combinations for the row as tuples.
        @param row: the row from which to generate the key
        &#34;&#34;&#34;
        candidate_values = []
        for pattern in self.keys:
            candidate_values.append(hxl.datatypes.normalise_string(value) for value in row.get_all(pattern, default=&#39;&#39;))
        return [tuple(value) for value in list_product(candidate_values)]

    def _read_merge(self):
        &#34;&#34;&#34;Read the second (merging) dataset into memory.
        Stores only the values necessary for the merge.
        Uses *last* matching row for each key (top to bottom).
        @returns: a map of merge values
        &#34;&#34;&#34;
        
        self.columns # make sure we&#39;ve created the _merge_indices map

        merge_values = {}
        &#34;&#34;&#34;Map of keys to merge values from the merge source.&#34;&#34;&#34;

        for row in self.merge_source:
            if hxl.model.RowQuery.match_list(row, self.queries):
                values = []

                # Save only the values we need
                for spec in self._merge_indices:
                    try:
                        values.append(row.values[spec[0]])
                    except IndexError:
                        values.append(&#39;&#39;)

                # Generate a key tuple and add to the map
                for key in self._make_keys(row):
                    merge_values[key] = values

        return merge_values

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a merge filter from a dict spec.
        @param source: the upstream data source
        @param spec: the JSON-like filter specification
        @returns: a L{MergeDataFilter} object
        &#34;&#34;&#34;
        return MergeDataFilter(
            source=source,
            merge_source=req_arg(spec, &#39;merge_source&#39;),
            keys=req_arg(spec, &#39;keys&#39;),
            tags=req_arg(spec, &#39;tags&#39;),
            replace=opt_arg(spec, &#39;replace&#39;, False),
            overwrite=opt_arg(spec, &#39;overwrite&#39;, False),
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )


class RenameFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;
    Composable filter class to rename columns in a HXL dataset.

    This is the class supporting the hxlrename command-line utility.

    Usage:

    &lt;pre&gt;
    hxl.data(url).rename_columns(&#39;#foo:New header#bar&#39;)
    &lt;/pre&gt;
    &#34;&#34;&#34;

    def __init__(self, source, rename=[]):
        &#34;&#34;&#34;
        Constructor
        @param source: the Dataset for the data.
        @param rename_map: map of tags to rename
        &#34;&#34;&#34;
        super().__init__(source)
        if isinstance(rename, six.string_types):
            rename = [rename]
        self.rename = [RenameFilter.parse_rename(spec) for spec in rename]

    def filter_columns(self):
        &#34;&#34;&#34;Rename requested columns.&#34;&#34;&#34;
        return [self._rename_column(column) for column in self.source.columns]

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: a deep copy of the row&#39;s values&#34;&#34;&#34;
        return copy.copy(row.values)

    def _rename_column(self, column):
        &#34;&#34;&#34;@returns: a copy of the column object, with a new name if needed&#34;&#34;&#34;
        for spec in self.rename:
            norm = hxl.datatypes.normalise_string
            if spec[0].match(column) and (not spec[2] or norm(spec[2]) == norm(column.header)):
                new_column = copy.deepcopy(spec[1])
                if new_column.header is None:
                    new_column.header = column.header
                return new_column
        return copy.deepcopy(column)

    RENAME_PATTERN = r&#39;^\s*(?:([^#]*)#)?({token}(?:\s*[+-]{token})*)\s*:\s*(?:([^#]*)#)?({token}(?:\s*[+]{token})*)\s*$&#39;.format(
        token=hxl.datatypes.TOKEN_PATTERN
    )
    &#34;&#34;&#34;Regular expression for parsing a rename pattern&#34;&#34;&#34;

    @staticmethod
    def parse_rename(s):
        &#34;&#34;&#34;Parse a rename specification from the parameters.
        @param s: the specification to parse
        @returns: a tuple with the old pattern to match and new column spec
        @exception HXLFilterException: if the spec is not parseable
        &#34;&#34;&#34;
        if isinstance(s, six.string_types):
            result = re.match(RenameFilter.RENAME_PATTERN, s)
            if result:
                header = result.group(1)
                pattern = hxl.model.TagPattern.parse(result.group(2))
                column = hxl.model.Column.parse(&#39;#&#39; + result.group(4), header=result.group(3), use_exception=True)
                return (pattern, column, header)
            else:
                raise HXLFilterException(&#34;Bad rename expression: &#34; + s)
        else:
            return s

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a rename filter from a dict spec.
        @param source: the upstream data source
        @param spec: the JSON-like filter specification
        @returns: a L{RenameFilter} object
        &#34;&#34;&#34;
        return RenameFilter(
            source=source,
            rename=req_arg(spec, &#39;specs&#39;)
        )

    
class JSONPathFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Extract values from a JSON string expression using JSONPath
    See http://goessner.net/articles/JsonPath/
    Optionally restrict to specific columns and/or rows
    &#34;&#34;&#34;

    def __init__(self, source, path, patterns=None, queries=[], use_json=True):
        &#34;&#34;&#34;Constructor
        @param source: the upstream data source
        @param path: a JSONPath expression for extracting data
        @param patterns: a tag pattern or list of patterns for the columns to use (default to all)
        @param queries: a predicate or list of predicates for the rows to consider.
        @param use_json: if True, serialise multiple values as JSON (default); otherwise, separate with &#34; | &#34;
        &#34;&#34;&#34;
        super().__init__(source)
        self.path = jsonpath_ng.ext.parse(path)
        self.patterns = hxl.model.TagPattern.parse_list(patterns)
        self.queries = self._setup_queries(queries)
        self.use_json = use_json
        self._indices = None

    def filter_row(self, row):
        if self._indices is None:
            self._indices = self._get_indices(self.patterns)

        values = list(row.values)

        if hxl.model.RowQuery.match_list(row, self.queries):
        
            for i in self._indices:
                try:
                    expr = json.loads(values[i])
                    results = [match.value for match in self.path.find(expr)]
                    if len(results) == 0:
                        values[i] = &#39;&#39;
                    elif len(results) == 1:
                        values[i] = hxl.datatypes.flatten(results[0], self.use_json)
                    else:
                        values[i] = hxl.datatypes.flatten(results, self.use_json)
                except (ValueError, TypeError,) as e:
                    logger.warning(&#34;Skipping invalid JSON expression &#39;%s&#39;&#34;, values[i])

        return values
    
    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a JSONPath filter from a dict spec.
        @param source: the upstream data source
        @param spec: the JSON-like filter specification
        @returns: a L{RenameFilter} object
        &#34;&#34;&#34;
        return JSONPathFilter(
            source=source,
            path=req_arg(spec, &#39;path&#39;),
            patterns=opt_arg(spec, &#39;patterns&#39;),
            queries=opt_arg(spec, &#39;queries&#39;)
        )

    
class FillDataFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Fill empty cells in a dataset.
    By default, fill all empty cells with the closest non-empty value in a previous row.
    Optionally restrict to specific columns and/or rows.
    &#34;&#34;&#34;

    def __init__(self, source, patterns=None, queries=[]):
        &#34;&#34;&#34;Constructor
        @param source: the source dataset
        @param patterns: a tag pattern or list of patterns for the columns to fill (default to all)
        @param queries: restrict filling to rows matching one of these queries (default: fill all rows).
        &#34;&#34;&#34;
        super().__init__(source)
        self.patterns = hxl.model.TagPattern.parse_list(patterns)
        self.queries = self._setup_queries(queries)
        self._saved = {}
        self._indices = None

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: row values with some empty values possibly filled in&#34;&#34;&#34;
        values = list(row.values)

        # Guessing at empty cells (column-wise only)
        if self._indices is None:
            self._indices = self._get_indices(self.patterns)
        for i in self._indices:
            if i &gt;= len(values):
                values += [&#39;&#39;] * (i - len(values) + 1) # make sure list is long enough
            if values[i]:
                self._saved[i] = values[i]
            elif (not self.queries) or (hxl.model.RowQuery.match_list(row, self.queries)):
                values[i] = self._saved[i] if self._saved.get(i) else &#39;&#39;
                    
        return values

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a fill-data filter from a dict spec.
        @param source: the upstream data source
        @param spec: the JSON-like filter specification
        @returns: a L{FillDataFilter} object
        &#34;&#34;&#34;
        return FillDataFilter(
            source=source,
            patterns=opt_arg(spec, &#39;patterns&#39;),
            queries=opt_arg(spec, &#39;queries&#39;),
        )

    
class ReplaceDataFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;
    Composable filter class to replace values in a HXL dataset.

    This is the class supporting the hxlreplace console script.

    Usage:

    &lt;pre&gt;
    hxl.data(url).replace_data(&#39;foo&#39;, &#39;bar&#39;, &#39;#activity&#39;)
    &lt;/pre&gt;
    &#34;&#34;&#34;

    def __init__(self, source, replacements, queries=[]):
        &#34;&#34;&#34;
        Constructor
        @param source: the HXL data source
        @param original: a string or regular expression to replace (string must match the whole value, not just part)
        @param replacements: list of replacement objects
        @param queries: optional list of filter queries for rows where replacements should be applied.
        &#34;&#34;&#34;
        super(ReplaceDataFilter, self).__init__(source)
        self.replacements = replacements
        if isinstance(self.replacements, ReplaceDataFilter.Replacement):
            self.replacements = [self.replacements]
        self.queries = self._setup_queries(queries)

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: the row values with replacements&#34;&#34;&#34;
        if hxl.model.RowQuery.match_list(row, self.queries):
            values = copy.copy(row.values)
            for index, value in enumerate(values):
                for replacement in self.replacements:
                    value = replacement.sub(row.columns[index], value)
                    values[index] = value
            return values
        else:
            return row.values

    class Replacement:
        &#34;&#34;&#34;Replacement specification.&#34;&#34;&#34;

        def __init__(self, original, replacement, patterns=None, is_regex=False):
            &#34;&#34;&#34;
            @param original: a string (case- and space-insensitive) or regular expression (sensitive) to replace
            @param replacement: the replacement string or regular expression substitution
            @param patterns: (optional) a list of tag patterns to limit the replacement to specific columns
            @param is_regex: (optional) True to use regular-expression processing (defaults to False)
            &#34;&#34;&#34;
            self.original = original
            if replacement is None:
                self.replacement = &#39;&#39;
            else:
                self.replacement = replacement
            if patterns:
                self.patterns = hxl.model.TagPattern.parse_list(patterns)
            else:
                self.patterns = None
            self.is_regex = is_regex
            if not self.is_regex:
                self.original = hxl.datatypes.normalise_string(self.original)

        def sub(self, column, value):
            &#34;&#34;&#34;
            Substitute inside the value, if appropriate.
            @param column: the column definition
            @param value: the cell value
            @returns: the value, possibly changed
            &#34;&#34;&#34;
            if self.patterns and not hxl.model.TagPattern.match_list(column, self.patterns):
                return value
            elif self.is_regex:
                return re.sub(self.original, self.replacement, str(value))
            elif self.original == hxl.datatypes.normalise_string(value):
                return self.replacement
            else:
                return value

        @staticmethod
        def parse_map(source):
            &#34;&#34;&#34;Parse a substitution map.&#34;&#34;&#34;
            replacements = []
            for row in source:
                if row.get(&#39;#x_pattern&#39;):
                    replacements.append(
                        ReplaceDataFilter.Replacement(
                            row.get(&#39;#x_pattern&#39;), row.get(&#39;#x_substitution&#39;),
                            row.get(&#39;#x_tag&#39;), row.get(&#39;#x_regex&#39;)
                        ))
            return replacements

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a replace-data filter from a dict spec.
        @param source: the upstream data source
        @param spec: a JSON-like filter specification
        @returns: a L{ReplaceDataFilter} object
        &#34;&#34;&#34;

        replacements = []

        if spec.get(&#39;filter&#39;) == &#39;replace_data_map&#39;:
            # using an external map
            replacements = ReplaceDataFilter.Replacement.parse_map(
                hxl.data(req_arg(spec, &#39;map_source&#39;))
            )
        elif spec.get(&#39;filter&#39;) == &#39;replace_data&#39;:
            # simple replacement
            replacements = [
                ReplaceDataFilter.Replacement(
                    original=req_arg(spec, &#39;original&#39;),
                    replacement=req_arg(spec, &#39;replacement&#39;),
                    patterns=opt_arg(spec, &#39;pattern&#39;, None),
                    is_regex=opt_arg(spec, &#39;use_regex&#39;, False)
                )
            ]

        return ReplaceDataFilter(
            source=source,
            replacements=replacements,
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )

        
class RowCountFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;
    Composable filter class to count lines (and nothing else)

    The output is identical to the input; the line count is
    stored in the filter itself.  As a result, there is no corresponding
    command-line utility.
    
    Usage:

    &lt;pre&gt;
    counter = hxl.data(url).row_counter();
    // process the filter
    print(&#34;{} lines&#34;.format(counter.row_count);
    &lt;/pre&gt;
    &#34;&#34;&#34;

    def __init__(self, source, queries=[]):
        super(RowCountFilter, self).__init__(source)
        self.row_count = 0
        self.queries = self._setup_queries(queries)

    def filter_row(self, row):
        if hxl.model.RowQuery.match_list(row, self.queries):
            self.row_count += 1
        return row.values
    

class RowFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;
    Composable filter class to select rows from a HXL dataset.

    Usage:

    &lt;pre&gt;
    # include list
    hxl.data(url).with_rows(&#39;org=OXFAM&#39;)

    # exclude list
    hxl.data(url).without_rows(&#39;org=OXFAM&#39;)
    &lt;/pre&gt;
    &#34;&#34;&#34;

    def __init__(self, source, queries=[], reverse=False, mask=[]):
        &#34;&#34;&#34;
        Constructor
        @param source: the HXL data source
        @param queries: a series of predicates for rows to include or ignore
        @param reverse: True to reverse the sense of the select
        @param mask: a series of predicates to limit the rows to test (default: [] to test all)
        &#34;&#34;&#34;
        super(RowFilter, self).__init__(source)
        self.queries = self._setup_queries(queries)
        self.mask = self._setup_queries(mask)
        self.reverse = reverse

        for query in self.queries:
            if query.needs_aggregate:
                if not self.source.is_cached:
                    self.source = self.source.cache()
                query.calc_aggregate(self.source)

    def filter_row(self, row):
        &#34;&#34;&#34;Filter data row-wise.
        @param row: the row to filter
        @returns: the row&#39;s values as an array, or None if it fails the filters
        &#34;&#34;&#34;
        if hxl.model.RowQuery.match_list(row, self.mask):
            if not hxl.model.RowQuery.match_list(row, self.queries, self.reverse):
                return None
        return row.values

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Construct a row filter from a dict spec.&#34;&#34;&#34;
        
        reverse = False
        if spec.get(&#39;filter&#39;) == &#39;without_rows&#39;:
            reverse = True

        return RowFilter(
            source=source,
            queries=req_arg(spec, &#39;queries&#39;),
            reverse=reverse,
            mask=opt_arg(spec, &#39;mask&#39;, [])
        )

    
class SortFilter(AbstractCachingFilter):
    &#34;&#34;&#34;
    Composable filter class to sort a HXL dataset.

    This is the class supporting the hxlsort command-line utility.

    Usage:

    &lt;pre&gt;
    hxl.data(url).sort(&#39;sector,org,adm1&#39;)
    &lt;/pre&gt;
    &#34;&#34;&#34;

    def __init__(self, source, tags=[], reverse=False):
        &#34;&#34;&#34;
        @param source: a HXL data source
        @param tags: list of TagPattern objects for sorting
        @param reverse: True to reverse the sort order
        &#34;&#34;&#34;
        super(SortFilter, self).__init__(source)
        self.sort_tags = hxl.model.TagPattern.parse_list(tags)
        self.reverse = reverse
        self._iter = None

    def filter_rows(self):
        &#34;&#34;&#34;Return a sorted list of values, row by row.&#34;&#34;&#34;

        # Figure out the indices for sort keys
        indices = self._make_indices()

        def make_key(values):
            &#34;&#34;&#34;Closure, to get the object reference into the key method.&#34;&#34;&#34;
            return self._make_key(indices, values)

        return sorted(self.source.values, key=make_key, reverse=self.reverse)

    def _make_indices(self):
        &#34;&#34;&#34;Determine the indices of the data to sort.&#34;&#34;&#34;
        indices = []
        for pattern in self.sort_tags:
            index = pattern.find_column_index(self.columns)
            if index is not None:
                indices.append(index)
        return indices

    def _make_key(self, indices, values):
        &#34;&#34;&#34;
        Make a sort key from a an array of values.
        @param indices: an array of indices for the sort key (if empty, use all values).
        @param values: an array of values to sort
        @returns: a sort key as a tuple
        &#34;&#34;&#34;

        key = []

        if indices:
            for index in indices:
                key.append(SortFilter._make_sort_value(self.columns[index].tag, values[index]))
        else:
            # Sort everything, left to right
            for index, value in enumerate(values):
                if index &lt; len(self.columns):
                    key.append(SortFilter._make_sort_value(self.columns[index].tag, value))

        # convert the key to a tuple for sorting
        return tuple(key)

    @staticmethod
    def _make_sort_value(tag, value):
        &#34;&#34;&#34;
        Make a special sort value

        The sort value is is a tuple of a numeric value (possibly inf)
        and the original string value. This will ensure that numeric
        values sort properly, and string values sort after them.
        &#34;&#34;&#34;
        norm = hxl.datatypes.normalise_string(value)
        if tag == &#39;#date&#39;:
            try:
                return (float(&#39;inf&#39;), hxl.datatypes.normalise_date(norm))
            except ValueError:
                return (float(&#39;inf&#39;), norm)
        else:
            try:
                return (float(norm), norm)
            except:
                return (float(&#39;inf&#39;), norm)

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a sort filter from a dict spec.&#34;&#34;&#34;
        return SortFilter(
            source = source,
            tags=opt_arg(spec, &#39;tags&#39;, []),
            reverse=opt_arg(spec, &#39;reverse&#39;, False)
        )


#
# Compile a filter chain
#

LOAD_MAP = {
    &#39;add_columns&#39;: AddColumnsFilter._load,
    &#39;append&#39;: AppendFilter._load,
    &#39;append_external_list&#39;: AppendFilter._load,
    &#39;cache&#39;: CacheFilter._load,
    &#39;clean_data&#39;: CleanDataFilter._load,
    &#39;count&#39;: CountFilter._load,
    &#39;dedup&#39;: DeduplicationFilter._load,
    &#39;expand_lists&#39;: ExpandListsFilter._load,
    &#39;explode&#39;: ExplodeFilter._load,
    &#39;fill_data&#39;: FillDataFilter._load,
    &#39;implode&#39;: ImplodeFilter._load,
    &#39;jsonpath&#39;: JSONPathFilter._load,
    &#39;merge_data&#39;: MergeDataFilter._load,
    &#39;rename_columns&#39;: RenameFilter._load,
    &#39;replace_data&#39;: ReplaceDataFilter._load,
    &#39;replace_data_map&#39;: ReplaceDataFilter._load,
    &#39;sort&#39;: SortFilter._load,
    &#39;with_columns&#39;: ColumnFilter._load,
    &#39;with_rows&#39;: RowFilter._load,
    &#39;without_columns&#39;: ColumnFilter._load,
    &#39;without_rows&#39;: RowFilter._load,
}
&#34;&#34;&#34;Static functions for creating filters from dicts (from JSON, typically).&#34;&#34;&#34;


def req_arg(spec, property):
    &#34;&#34;&#34;Get a required property, and raise an exception if missing.
    @param spec: the JSON-like filter spec (a dict)
    @param property: the property name to retrieve
    @returns: the property value
    @exception HXLFilterException: if the property is not present
    &#34;&#34;&#34;
    value = spec.get(property)
    if value is None:
        raise HXLFilterException(&#34;Missing required property: \&#34;{}\&#34;&#34;.format(property))
    return value


def opt_arg(spec, property, default_value=None):
    &#34;&#34;&#34;Get an optional property, possibly with a default value.
    @param spec: the JSON-like filter spec (a dict)(
    @param property: the property name to retrieve
    @param default_value: the default value to return if not found
    @returns: the value if found, otherwise default_value/None
    &#34;&#34;&#34;
    value = spec.get(property)
    if value is None:
        return default_value
    else:
        return value


def from_recipe(source, recipe):
    &#34;&#34;&#34;Build a filter chain from a JSON-like list of filter specs.

    Each recipe dictionary contains the property &#39;filter&#39;, describing
    the filter type, and zero or more other properties providing
    parameters for the filter. Filter and parameter names are the same
    as the methods and arguments in hxl.model.Dataset.

    @param source: a HXL data source, URL, etc.
    @param recipe: a list of dictionaries, each describing a filter.
    @returns: the filter at the end of the new chain.
    &#34;&#34;&#34;
    source = hxl.data(source)

    #
    # Clean up recipe if needed
    #
    if isinstance(recipe, six.string_types):
        # a JSON string (parse it first)
        recipe = json.loads(recipe)
    if isinstance(recipe, dict) and recipe.get(&#39;filter&#39;):
        # a single filter (make it into a list)
        recipe = [recipe]

    # Process each filter in turn
    for spec in recipe:

        # Find the loader method
        type = req_arg(spec, &#39;filter&#39;)
        loader = LOAD_MAP.get(type)
        if not loader:
            raise HXLFilterException(&#34;Unknown filter type {}&#34;.format(type))

        # Create the filter
        source = loader(source, spec)
        
    return source


def list_product(lists, head=[]):
    &#34;&#34;&#34;Generate the cartesian product of a list of lists 
    The elements of the result will be all possible combinations of the elements of
    the input lists.
    @param lists: a list of lists
    @return: the cross-product of the lists
    &#34;&#34;&#34;
    if lists:
        result = []
        for item in lists[0]:
            tail = list_product(lists[1:], head + [item])
            result = result + tail
        return result
    else:
        return [head]


def is_sourcey(arg):
    &#34;&#34;&#34;Convoluted method to try to distinguish a single HXL data source from a list of sources.
    Trying to recognise all the source types supported by hxl.input.make_input
    @param arg: the thing to test (we want to know if it&#39;s a single source or lists of sources)
    @returns: True if we think it&#39;s a single source; False otherwise.
    &#34;&#34;&#34;

    # Not a list
    if ((not hasattr(arg, &#39;__len__&#39;)) or
        isinstance(arg, dict) or
        isinstance(arg, six.string_types) or
        isinstance(arg, hxl.model.Dataset)):
        return True

    # Quick-and-dirty test for a list representation of a HXL dataset
    try:
        if (isinstance(arg[0], six.string_types)):
            return False
        elif ((not hasattr(arg[0][0], &#39;__len__&#39;)) or isinstance(arg[0][0], six.string_types)):
            return True
    except:
        pass

    return False


# end</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="hxl.filters.LOAD_MAP"><code class="name">var <span class="ident">LOAD_MAP</span></code></dt>
<dd>
<div class="desc"><p>Static functions for creating filters from dicts (from JSON, typically).</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hxl.filters.from_recipe"><code class="name flex">
<span>def <span class="ident">from_recipe</span></span>(<span>source, recipe)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a filter chain from a JSON-like list of filter specs.</p>
<p>Each recipe dictionary contains the property 'filter', describing
the filter type, and zero or more other properties providing
parameters for the filter. Filter and parameter names are the same
as the methods and arguments in hxl.model.Dataset.</p>
<p>@param source: a HXL data source, URL, etc.
@param recipe: a list of dictionaries, each describing a filter.
@returns: the filter at the end of the new chain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_recipe(source, recipe):
    &#34;&#34;&#34;Build a filter chain from a JSON-like list of filter specs.

    Each recipe dictionary contains the property &#39;filter&#39;, describing
    the filter type, and zero or more other properties providing
    parameters for the filter. Filter and parameter names are the same
    as the methods and arguments in hxl.model.Dataset.

    @param source: a HXL data source, URL, etc.
    @param recipe: a list of dictionaries, each describing a filter.
    @returns: the filter at the end of the new chain.
    &#34;&#34;&#34;
    source = hxl.data(source)

    #
    # Clean up recipe if needed
    #
    if isinstance(recipe, six.string_types):
        # a JSON string (parse it first)
        recipe = json.loads(recipe)
    if isinstance(recipe, dict) and recipe.get(&#39;filter&#39;):
        # a single filter (make it into a list)
        recipe = [recipe]

    # Process each filter in turn
    for spec in recipe:

        # Find the loader method
        type = req_arg(spec, &#39;filter&#39;)
        loader = LOAD_MAP.get(type)
        if not loader:
            raise HXLFilterException(&#34;Unknown filter type {}&#34;.format(type))

        # Create the filter
        source = loader(source, spec)
        
    return source</code></pre>
</details>
</dd>
<dt id="hxl.filters.is_sourcey"><code class="name flex">
<span>def <span class="ident">is_sourcey</span></span>(<span>arg)</span>
</code></dt>
<dd>
<div class="desc"><p>Convoluted method to try to distinguish a single HXL data source from a list of sources.
Trying to recognise all the source types supported by hxl.input.make_input
@param arg: the thing to test (we want to know if it's a single source or lists of sources)
@returns: True if we think it's a single source; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_sourcey(arg):
    &#34;&#34;&#34;Convoluted method to try to distinguish a single HXL data source from a list of sources.
    Trying to recognise all the source types supported by hxl.input.make_input
    @param arg: the thing to test (we want to know if it&#39;s a single source or lists of sources)
    @returns: True if we think it&#39;s a single source; False otherwise.
    &#34;&#34;&#34;

    # Not a list
    if ((not hasattr(arg, &#39;__len__&#39;)) or
        isinstance(arg, dict) or
        isinstance(arg, six.string_types) or
        isinstance(arg, hxl.model.Dataset)):
        return True

    # Quick-and-dirty test for a list representation of a HXL dataset
    try:
        if (isinstance(arg[0], six.string_types)):
            return False
        elif ((not hasattr(arg[0][0], &#39;__len__&#39;)) or isinstance(arg[0][0], six.string_types)):
            return True
    except:
        pass

    return False</code></pre>
</details>
</dd>
<dt id="hxl.filters.list_product"><code class="name flex">
<span>def <span class="ident">list_product</span></span>(<span>lists, head=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the cartesian product of a list of lists
The elements of the result will be all possible combinations of the elements of
the input lists.
@param lists: a list of lists
@return: the cross-product of the lists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_product(lists, head=[]):
    &#34;&#34;&#34;Generate the cartesian product of a list of lists 
    The elements of the result will be all possible combinations of the elements of
    the input lists.
    @param lists: a list of lists
    @return: the cross-product of the lists
    &#34;&#34;&#34;
    if lists:
        result = []
        for item in lists[0]:
            tail = list_product(lists[1:], head + [item])
            result = result + tail
        return result
    else:
        return [head]</code></pre>
</details>
</dd>
<dt id="hxl.filters.opt_arg"><code class="name flex">
<span>def <span class="ident">opt_arg</span></span>(<span>spec, property, default_value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an optional property, possibly with a default value.
@param spec: the JSON-like filter spec (a dict)(
@param property: the property name to retrieve
@param default_value: the default value to return if not found
@returns: the value if found, otherwise default_value/None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opt_arg(spec, property, default_value=None):
    &#34;&#34;&#34;Get an optional property, possibly with a default value.
    @param spec: the JSON-like filter spec (a dict)(
    @param property: the property name to retrieve
    @param default_value: the default value to return if not found
    @returns: the value if found, otherwise default_value/None
    &#34;&#34;&#34;
    value = spec.get(property)
    if value is None:
        return default_value
    else:
        return value</code></pre>
</details>
</dd>
<dt id="hxl.filters.req_arg"><code class="name flex">
<span>def <span class="ident">req_arg</span></span>(<span>spec, property)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a required property, and raise an exception if missing.
@param spec: the JSON-like filter spec (a dict)
@param property: the property name to retrieve
@returns: the property value
@exception HXLFilterException: if the property is not present</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def req_arg(spec, property):
    &#34;&#34;&#34;Get a required property, and raise an exception if missing.
    @param spec: the JSON-like filter spec (a dict)
    @param property: the property name to retrieve
    @returns: the property value
    @exception HXLFilterException: if the property is not present
    &#34;&#34;&#34;
    value = spec.get(property)
    if value is None:
        raise HXLFilterException(&#34;Missing required property: \&#34;{}\&#34;&#34;.format(property))
    return value</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hxl.filters.AbstractBaseFilter"><code class="flex name class">
<span>class <span class="ident">AbstractBaseFilter</span></span>
<span>(</span><span>source)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for composable filters.</p>
<p>This is the base class for all filters. A B{filter} is like a
L{hxl.model.Dataset}, except that it uses another dataset as its source, and
performs some kind of transformation on it before producing its
output.</p>
<p>This class stores the upstream source, and provides a
L{filter_columns} method that child classes can implement. The
L{columns} method will call filter_columns() precisely once for
each instantiation, giving the child a chance to provide a
different set of columns than those in the source.</p>
<p>If you're writing your own filter classes, you should normally
subclass L{AbstractStreamingFilter} or L{AbstractCachingFilter},
both of which are child classes of this one; however, there may be
some special applications where you need to subclass
I{AbstractBaseFilter} directly (see L{AppendFilter} for an
example).</p>
<p>Subclassing works like this::</p>
<p>class MyFilter(hxl.filters.AbstractBaseFilter):</p>
<pre><code>  def __init__(self, source):
      super(AbstractBaseFilter, self).__init__(source)

  def filter_columns(self):
      return [Column.parse('#org'), Column.parse('#adm1')]
</code></pre>
<p>The output will be identical to the source, except that the
columns will now be '#org' and '#adm1'.</p>
<p>@see: L{AbstractStreamingFilter}
@see: L{AbstractCachingFilter}</p>
<p>Construct a new abstract filter.
@param source: the source dataset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractBaseFilter(hxl.model.Dataset):
    &#34;&#34;&#34;Abstract base class for composable filters.

    This is the base class for all filters. A B{filter} is like a
    L{hxl.model.Dataset}, except that it uses another dataset as its source, and
    performs some kind of transformation on it before producing its
    output.

    This class stores the upstream source, and provides a
    L{filter_columns} method that child classes can implement. The
    L{columns} method will call filter_columns() precisely once for
    each instantiation, giving the child a chance to provide a
    different set of columns than those in the source.

    If you&#39;re writing your own filter classes, you should normally
    subclass L{AbstractStreamingFilter} or L{AbstractCachingFilter},
    both of which are child classes of this one; however, there may be
    some special applications where you need to subclass
    I{AbstractBaseFilter} directly (see L{AppendFilter} for an
    example).

    Subclassing works like this::
    
      class MyFilter(hxl.filters.AbstractBaseFilter):

          def __init__(self, source):
              super(AbstractBaseFilter, self).__init__(source)

          def filter_columns(self):
              return [Column.parse(&#39;#org&#39;), Column.parse(&#39;#adm1&#39;)]

    The output will be identical to the source, except that the
    columns will now be &#39;#org&#39; and &#39;#adm1&#39;.

    @see: L{AbstractStreamingFilter}
    @see: L{AbstractCachingFilter}

    &#34;&#34;&#34;

    __metaclass__ = abc.ABCMeta

    def __init__(self, source):
        &#34;&#34;&#34;Construct a new abstract filter.
        @param source: the source dataset
        &#34;&#34;&#34;

        super().__init__()

        self.source = source
        &#34;&#34;&#34;HXL data source for the filter&#34;&#34;&#34;

        self._filtered_column_cache = None
        &#34;&#34;&#34;Cache of columns as filtered by the child class.&#34;&#34;&#34;

    @property
    def is_cached(self):
        &#34;&#34;&#34;Test if the input is cached (can be replayed).
        Subclasses that cache should override this.
        @returns: C{True} only if the source is cached.
        &#34;&#34;&#34;
        return self.source.is_cached

    @property
    def columns(self):
        &#34;&#34;&#34;Return the filter&#39;s (possibly-modified) columns.

        By default, return the columns defined by the source HXL
        data. Child classes override the L{filter_columns} method to
        return something different.

        @returns: a list of L{hxl.model.Column} objects
        &#34;&#34;&#34;
        if self._filtered_column_cache is None:
            self._filtered_column_cache = self.filter_columns()
        return self._filtered_column_cache

    def filter_columns(self):
        &#34;&#34;&#34;Return a new list of columns for the filtered dataset.

        By default, return the source HXL data&#39;s columns. Child
        classes override this method to return a different set of
        columns

        @returns: a list of L{hxl.model.Column} objects
        @see: L{AbstractStreamingFilter.filter_row}
        @see: L{AbstractCachingFilter.filter_rows}
        &#34;&#34;&#34;
        return self.source.columns

    def _setup_queries(self, query_specs):
        &#34;&#34;&#34;Parse a list of query specs, and calculate aggregates when needed.
        Side-effect: may replace self.source with a caching filter.
        @param query_specs: a list of row-query string specs
        @returns: a list of hxl.model.RowQuery objects, ready for use
        &#34;&#34;&#34;
        queries = hxl.model.RowQuery.parse_list(query_specs)

        # Some queries need to run through the dataset first to calculate an aggregate value
        for query in queries:
            if query.needs_aggregate:
                if not self.source.is_cached:
                    self.source = self.source.cache()
                query.calc_aggregate(self.source)

        return queries

    def _get_indices(self, patterns):
        &#34;&#34;&#34;Get indices of columns to fill.
        If there&#39;s no column pattern, then fill all columns.
        @param patterns: list of tag patterns for matching columns (if empty, all columns match)
        @returns: a set of indices for filling.
        &#34;&#34;&#34;
        indices = set()
        for i, column in enumerate(self.source.columns):
            if len(patterns) == 0 or hxl.model.TagPattern.match_list(column, patterns):
                indices.add(i)
        return indices

    @staticmethod
    def _load (source, spec):
        &#34;&#34;&#34;Create an instance of the filter from a dict.
        Child classes must override this method.
        @param spec: the JSON-like spec to read
        @returns: a new filter object
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No static _load method implemented.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractCachingFilter" href="#hxl.filters.AbstractCachingFilter">AbstractCachingFilter</a></li>
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AppendFilter" href="#hxl.filters.AppendFilter">AppendFilter</a></li>
<li><a title="hxl.filters.CacheFilter" href="#hxl.filters.CacheFilter">CacheFilter</a></li>
<li><a title="hxl.filters.ExpandListsFilter" href="#hxl.filters.ExpandListsFilter">ExpandListsFilter</a></li>
<li><a title="hxl.filters.ExplodeFilter" href="#hxl.filters.ExplodeFilter">ExplodeFilter</a></li>
<li><a title="hxl.filters.ImplodeFilter" href="#hxl.filters.ImplodeFilter">ImplodeFilter</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.filters.AbstractBaseFilter.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"><p>Return the filter's (possibly-modified) columns.</p>
<p>By default, return the columns defined by the source HXL
data. Child classes override the L{filter_columns} method to
return something different.</p>
<p>@returns: a list of L{hxl.model.Column} objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def columns(self):
    &#34;&#34;&#34;Return the filter&#39;s (possibly-modified) columns.

    By default, return the columns defined by the source HXL
    data. Child classes override the L{filter_columns} method to
    return something different.

    @returns: a list of L{hxl.model.Column} objects
    &#34;&#34;&#34;
    if self._filtered_column_cache is None:
        self._filtered_column_cache = self.filter_columns()
    return self._filtered_column_cache</code></pre>
</details>
</dd>
<dt id="hxl.filters.AbstractBaseFilter.is_cached"><code class="name">var <span class="ident">is_cached</span></code></dt>
<dd>
<div class="desc"><p>Test if the input is cached (can be replayed).
Subclasses that cache should override this.
@returns: C{True} only if the source is cached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_cached(self):
    &#34;&#34;&#34;Test if the input is cached (can be replayed).
    Subclasses that cache should override this.
    @returns: C{True} only if the source is cached.
    &#34;&#34;&#34;
    return self.source.is_cached</code></pre>
</details>
</dd>
<dt id="hxl.filters.AbstractBaseFilter.source"><code class="name">var <span class="ident">source</span></code></dt>
<dd>
<div class="desc"><p>HXL data source for the filter</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.AbstractBaseFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new list of columns for the filtered dataset.</p>
<p>By default, return the source HXL data's columns. Child
classes override this method to return a different set of
columns</p>
<p>@returns: a list of L{hxl.model.Column} objects
@see: L{AbstractStreamingFilter.filter_row}
@see: L{AbstractCachingFilter.filter_rows}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34;Return a new list of columns for the filtered dataset.

    By default, return the source HXL data&#39;s columns. Child
    classes override this method to return a different set of
    columns

    @returns: a list of L{hxl.model.Column} objects
    @see: L{AbstractStreamingFilter.filter_row}
    @see: L{AbstractCachingFilter.filter_rows}
    &#34;&#34;&#34;
    return self.source.columns</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.model.Dataset.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.model.Dataset.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.model.Dataset.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.model.Dataset.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.model.Dataset.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.model.Dataset.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.model.Dataset.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.model.Dataset.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.model.Dataset.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.model.Dataset.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.model.Dataset.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.model.Dataset.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.model.Dataset.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.model.Dataset.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.model.Dataset.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.model.Dataset.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.model.Dataset.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.model.Dataset.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.model.Dataset.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.model.Dataset.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.model.Dataset.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.model.Dataset.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.model.Dataset.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.model.Dataset.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.model.Dataset.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.model.Dataset.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.model.Dataset.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.model.Dataset.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.model.Dataset.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.model.Dataset.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.model.Dataset.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.model.Dataset.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.model.Dataset.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.model.Dataset.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.model.Dataset.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.model.Dataset.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.model.Dataset.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.model.Dataset.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.AbstractCachingFilter"><code class="flex name class">
<span>class <span class="ident">AbstractCachingFilter</span></span>
<span>(</span><span>source)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for caching filters.</p>
<p>A caching filter processes the entire dataset together in
memory. This approach is less efficient than a L{streaming
filter<AbstractStreamingFilter>}, but it's necessary when a filter
needs to reorder rows, or to change some rows that depend on
others. Examples of caching filters include L{SortFilter},
L{CountFilter}, and L{CacheFilter}.</p>
<p>Another important property of a caching filter is that it's
possible to replay it. As a result, caching filters are especially
useful for data that a client application needs to process more
than once, and the L{CacheFilter} class exists for precisely that
purpose. The filter will transform the data only once, then save a
copy of it for future use.</p>
<p>Child classes may implement the
L{AbstractBaseFilter.filter_columns} method to change the columns
and tags, and/or this class's L{filter_rows} method to change the
data all at once, like this::</p>
<p>class MyFilter(hxl.filters.AbstractCachingFilter):</p>
<pre><code>  def __init__(self, source):
      super(AbstractStreamingFilter, self).__init__(source)

  def filter_rows(self, row):
      raw_data = self.source.values
      # return a list of lists, one for each row
      return raw_data.sort()
</code></pre>
<p>This simple filter will produce a copy of the source data sorted
using Python's default sorting method.</p>
<p>@see: L{AbstractStreamingFilter}</p>
<p>Construct a new caching filter.
@param source: the source dataset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractCachingFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Abstract base class for caching filters.

    A caching filter processes the entire dataset together in
    memory. This approach is less efficient than a L{streaming
    filter&lt;AbstractStreamingFilter&gt;}, but it&#39;s necessary when a filter
    needs to reorder rows, or to change some rows that depend on
    others. Examples of caching filters include L{SortFilter},
    L{CountFilter}, and L{CacheFilter}.

    Another important property of a caching filter is that it&#39;s
    possible to replay it. As a result, caching filters are especially
    useful for data that a client application needs to process more
    than once, and the L{CacheFilter} class exists for precisely that
    purpose. The filter will transform the data only once, then save a
    copy of it for future use.

    Child classes may implement the
    L{AbstractBaseFilter.filter_columns} method to change the columns
    and tags, and/or this class&#39;s L{filter_rows} method to change the
    data all at once, like this::

      class MyFilter(hxl.filters.AbstractCachingFilter):

          def __init__(self, source):
              super(AbstractStreamingFilter, self).__init__(source)

          def filter_rows(self, row):
              raw_data = self.source.values
              # return a list of lists, one for each row
              return raw_data.sort()

    This simple filter will produce a copy of the source data sorted
    using Python&#39;s default sorting method.

    @see: L{AbstractStreamingFilter}

    &#34;&#34;&#34;

    __metaclass__ = abc.ABCMeta

    def __init__(self, source):
        &#34;&#34;&#34;Construct a new caching filter.
        @param source: the source dataset
        &#34;&#34;&#34;
        super().__init__(source)

        self._saved_rows = None
        &#34;&#34;&#34;Cache of the output rows, for replaying.&#34;&#34;&#34;

    @property
    def is_cached(self):
        &#34;&#34;&#34;Test if the input is cached.
        @returns: always C{True} for caching filters
        &#34;&#34;&#34;
        return True

    def filter_rows(self):
        &#34;&#34;&#34;Filter all of the data together.
        
        This method returns raw lists and strings, not objects from
        the L{hxl.model} module; for example, it could return the
        following for a three-row dataset::

          [[&#39;UNICEF&#39;, &#39;20&#39;], [&#39;UNHCR&#39;, &#39;15&#39;], [&#39;OXFAM&#39;, &#39;25&#39;]]

        The I{AbstractCachingFilter} class will construct the
        appropriate objects around the data.
        
        @returns: a list of lists of strings, one list for each row.
        @see: L{AbstractBaseFilter.filter_columns}
        &#34;&#34;&#34;
        return self.source.values

    def __iter__(self):
        return AbstractCachingFilter._Iterator(self)

    class _Iterator:
        &#34;&#34;&#34;Internal iterator class to return the filtered rows.&#34;&#34;&#34;

        def __init__(self, outer):
            &#34;&#34;&#34;Create an iterator for a caching filter
            @param outer: a reference to the parent object (an L{AbstractStreamingFilter}).
            &#34;&#34;&#34;
            self.outer = outer
            self.values_iter = None
            self.row_number = -1

        def __iter__(self):
            return self

        def __next__(self):
            &#34;&#34;&#34;Return the next filtered row.

            If we haven&#39;t called L{AbstractCachingFilter.filter_rows}
            yet, call it now, and save the result in the parent&#39;s I{_saved_rows} property.

            @returns: a L{hxl.model.Row} object
            &#34;&#34;&#34;

            if self.values_iter is None:
                if self.outer._saved_rows is None:
                    # filter rows only once, when requested
                    self.outer._saved_rows = self.outer.filter_rows()
                self.values_iter = iter(self.outer._saved_rows)
            self.row_number += 1
            return hxl.model.Row(self.outer.columns, next(self.values_iter), self.row_number)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hxl.filters.CountFilter" href="#hxl.filters.CountFilter">CountFilter</a></li>
<li><a title="hxl.filters.SortFilter" href="#hxl.filters.SortFilter">SortFilter</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.filters.AbstractCachingFilter.is_cached"><code class="name">var <span class="ident">is_cached</span></code></dt>
<dd>
<div class="desc"><p>Test if the input is cached.
@returns: always C{True} for caching filters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_cached(self):
    &#34;&#34;&#34;Test if the input is cached.
    @returns: always C{True} for caching filters
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.AbstractCachingFilter.filter_rows"><code class="name flex">
<span>def <span class="ident">filter_rows</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter all of the data together.</p>
<p>This method returns raw lists and strings, not objects from
the L{hxl.model} module; for example, it could return the
following for a three-row dataset::</p>
<p>[['UNICEF', '20'], ['UNHCR', '15'], ['OXFAM', '25']]</p>
<p>The I{AbstractCachingFilter} class will construct the
appropriate objects around the data.</p>
<p>@returns: a list of lists of strings, one list for each row.
@see: L{AbstractBaseFilter.filter_columns}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_rows(self):
    &#34;&#34;&#34;Filter all of the data together.
    
    This method returns raw lists and strings, not objects from
    the L{hxl.model} module; for example, it could return the
    following for a three-row dataset::

      [[&#39;UNICEF&#39;, &#39;20&#39;], [&#39;UNHCR&#39;, &#39;15&#39;], [&#39;OXFAM&#39;, &#39;25&#39;]]

    The I{AbstractCachingFilter} class will construct the
    appropriate objects around the data.
    
    @returns: a list of lists of strings, one list for each row.
    @see: L{AbstractBaseFilter.filter_columns}
    &#34;&#34;&#34;
    return self.source.values</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractBaseFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.AbstractStreamingFilter"><code class="flex name class">
<span>class <span class="ident">AbstractStreamingFilter</span></span>
<span>(</span><span>source)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for streaming filters.</p>
<p>A streaming filter processes one row at a time.
It can skip rows,
but it never reorders them.
As a result, a streaming filter is
I{much} more efficient than a L{caching
filter<AbstractCachingFilter>}, since it needs to hold only one
row in memory at a time.</p>
<p>It is not possible to replay the data from a streaming filter
(e.g. to run a second processing pass), unless it has a caching
filter higher up the filter chain; if you are reading directly
from disk or a URL, the data is gone once it has passed through
the filter once.</p>
<p>If you are implementing your own filter class, you should subclass
I{AbstractStreamingFilter} whenever possible. Child classes may
implement the L{AbstractBaseFilter.filter_columns} method to
change the columns and tags, and/or this class's L{filter_row}
method to change, add, or suppress individual rows, like this:</p>
<p>class MyFilter(hxl.filters.AbstractStreamingFilter):</p>
<pre><code>  def __init__(self, source):
      super(AbstractStreamingFilter, self).__init__(source)

  def filter_row(self, row):
      if row.get('org+name') == "Unknown":
          return None # remove from output
      else:
          return row
</code></pre>
<p>This simple filter will produce a copy of the source data, but
omitting rows where the org name is "Unknown".</p>
<p>@see: L{AbstractCachingFilter}</p>
<p>Construct a new streaming filter.
@param source: the source dataset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractStreamingFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Abstract base class for streaming filters.

    A streaming filter processes one row at a time.  It can skip rows,
    but it never reorders them.  As a result, a streaming filter is
    I{much} more efficient than a L{caching
    filter&lt;AbstractCachingFilter&gt;}, since it needs to hold only one
    row in memory at a time.

    It is not possible to replay the data from a streaming filter
    (e.g. to run a second processing pass), unless it has a caching
    filter higher up the filter chain; if you are reading directly
    from disk or a URL, the data is gone once it has passed through
    the filter once.

    If you are implementing your own filter class, you should subclass
    I{AbstractStreamingFilter} whenever possible. Child classes may
    implement the L{AbstractBaseFilter.filter_columns} method to
    change the columns and tags, and/or this class&#39;s L{filter_row}
    method to change, add, or suppress individual rows, like this:

      class MyFilter(hxl.filters.AbstractStreamingFilter):

          def __init__(self, source):
              super(AbstractStreamingFilter, self).__init__(source)

          def filter_row(self, row):
              if row.get(&#39;org+name&#39;) == &#34;Unknown&#34;:
                  return None # remove from output
              else:
                  return row

    This simple filter will produce a copy of the source data, but
    omitting rows where the org name is &#34;Unknown&#34;.

    @see: L{AbstractCachingFilter}

    &#34;&#34;&#34;

    __metaclass__ = abc.ABCMeta

    def __init__(self, source):
        &#34;&#34;&#34;Construct a new streaming filter.
        @param source: the source dataset
        &#34;&#34;&#34;
        super().__init__(source)

    @abc.abstractmethod
    def filter_row(self, row):
        &#34;&#34;&#34;Filter a single row of data.

        By default, this method returns the row&#39;s values,
        unchanged. Subclasses can use it to replace, add or suppress
        rows on the fly, without having to keep a copy of the entire
        dataset in memory.

        @param row: the original L{hxl.model.Row} object.  
        @returns: A list of string values (I{not} a Row object) or
        C{None} to skip the row.
        @see: L{AbstractBaseFilter.filter_columns}

        &#34;&#34;&#34;
        return row.values

    def __iter__(self):
        return AbstractStreamingFilter._Iterator(self)

    class _Iterator:
        &#34;&#34;&#34;Internal iterator class to return the filtered rows.
        Note that the filtering happens here, not in the main class.
        &#34;&#34;&#34;

        def __init__(self, outer):
            &#34;&#34;&#34;Create an iterator for a streaming filter
            @param outer: a reference to the parent object (an L{AbstractStreamingFilter}).
            &#34;&#34;&#34;
            self.outer = outer # ref to outer object
            self.source_iter = iter(self.outer.source) # iterator for the source data
            self.row_number = -1

        def __iter__(self):
            return self

        def __next__(self):
            &#34;&#34;&#34;Return the next filtered row of data.  

            Uses the L{AbstractStreamingFilter.filter_row} method. The
            returned row is always a new object, so that if the client
            changes it, it won&#39;t change the version visible upstream
            in the filter chain.

            @returns: a L{hxl.model.Row} object

            &#34;&#34;&#34;
            # call this here, in case it caches any useful information
            columns = self.outer.columns
            while True:
                # a StopIterationException will terminate the loop
                row = next(self.source_iter)
                # get a new list of filtered values
                values = self.outer.filter_row(row)
                if values is not None:
                    # keep looping if filter_row(row) returned None
                    self.row_number += 1
                    # create a new Row object
                    return hxl.model.Row(columns, values, self.row_number)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hxl.filters.AddColumnsFilter" href="#hxl.filters.AddColumnsFilter">AddColumnsFilter</a></li>
<li><a title="hxl.filters.CleanDataFilter" href="#hxl.filters.CleanDataFilter">CleanDataFilter</a></li>
<li><a title="hxl.filters.ColumnFilter" href="#hxl.filters.ColumnFilter">ColumnFilter</a></li>
<li><a title="hxl.filters.DeduplicationFilter" href="#hxl.filters.DeduplicationFilter">DeduplicationFilter</a></li>
<li><a title="hxl.filters.FillDataFilter" href="#hxl.filters.FillDataFilter">FillDataFilter</a></li>
<li><a title="hxl.filters.JSONPathFilter" href="#hxl.filters.JSONPathFilter">JSONPathFilter</a></li>
<li><a title="hxl.filters.MergeDataFilter" href="#hxl.filters.MergeDataFilter">MergeDataFilter</a></li>
<li><a title="hxl.filters.RenameFilter" href="#hxl.filters.RenameFilter">RenameFilter</a></li>
<li><a title="hxl.filters.ReplaceDataFilter" href="#hxl.filters.ReplaceDataFilter">ReplaceDataFilter</a></li>
<li><a title="hxl.filters.RowCountFilter" href="#hxl.filters.RowCountFilter">RowCountFilter</a></li>
<li><a title="hxl.filters.RowFilter" href="#hxl.filters.RowFilter">RowFilter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.AbstractStreamingFilter.filter_row"><code class="name flex">
<span>def <span class="ident">filter_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter a single row of data.</p>
<p>By default, this method returns the row's values,
unchanged. Subclasses can use it to replace, add or suppress
rows on the fly, without having to keep a copy of the entire
dataset in memory.</p>
<p>@param row: the original L{hxl.model.Row} object.<br>
@returns: A list of string values (I{not} a Row object) or
C{None} to skip the row.
@see: L{AbstractBaseFilter.filter_columns}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def filter_row(self, row):
    &#34;&#34;&#34;Filter a single row of data.

    By default, this method returns the row&#39;s values,
    unchanged. Subclasses can use it to replace, add or suppress
    rows on the fly, without having to keep a copy of the entire
    dataset in memory.

    @param row: the original L{hxl.model.Row} object.  
    @returns: A list of string values (I{not} a Row object) or
    C{None} to skip the row.
    @see: L{AbstractBaseFilter.filter_columns}

    &#34;&#34;&#34;
    return row.values</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractBaseFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.AddColumnsFilter"><code class="flex name class">
<span>class <span class="ident">AddColumnsFilter</span></span>
<span>(</span><span>source, specs, before=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter class to add constant values to every row of a HXL dataset.</p>
<p>This is a L{streaming filter<AbstractStreamingFilter>} to add
constant values, such as a country code, to every row of data.
It
supports the L{hxl.model.Dataset.add_columns} method and the
L{hxladd<hxl.scripts.hxladd>} command-line utility.</p>
<p>This example will add a column with the label "Country name", the
HXL hashtag "#country", and the value "Malaysia" to every row in
the dataset::</p>
<pre><code>filter = AddColumnsFilter(source, "Country name#country=Malaysia")
</code></pre>
<p>This filter also supports substitution patterns in the fixed
values, surrounded by double braces. For example, the pattern</p>
<pre><code>X-{{#country+code}}
</code></pre>
<p>will include the value "X-" followed by the value of the column</p>
<h1 id="countrycode-in-each-new-cell-in-the-new-column">country+code in each new cell in the new column.</h1>
<p>@see: L{ColumnFilter}, L{RenameFilter}</p>
<p>Construct a new AddColumnsFilter.</p>
<p>The I{source} parameter may be either a string or a list of
strings (for multiple columns). Each string must have the
following format (I{<header text>} is optional):</p>
<p>I{<header text>}B{#}I{<tag and attributes>}B{=}I{<constant value>}</p>
<p>Example::</p>
<pre><code>Country name#country=Malasia
</code></pre>
<p>By default, this filter will add new columns to the end of
existing ones, but you can use optional I{before} parameter to
add them to the front.</p>
<p>@param source: a HXL data source</p>
<p>@param specs: a string or list of strings containing new
column specifications, as described above (or a list of tuples
as described in L{parse_spec})
@param before: true to add new columns before existing ones (default C{False})</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AddColumnsFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Composable filter class to add constant values to every row of a HXL dataset.

    This is a L{streaming filter&lt;AbstractStreamingFilter&gt;} to add
    constant values, such as a country code, to every row of data.  It
    supports the L{hxl.model.Dataset.add_columns} method and the
    L{hxladd&lt;hxl.scripts.hxladd&gt;} command-line utility.

    This example will add a column with the label &#34;Country name&#34;, the
    HXL hashtag &#34;#country&#34;, and the value &#34;Malaysia&#34; to every row in
    the dataset::

        filter = AddColumnsFilter(source, &#34;Country name#country=Malaysia&#34;)

    This filter also supports substitution patterns in the fixed
    values, surrounded by double braces. For example, the pattern

        X-{{#country+code}}

    will include the value &#34;X-&#34; followed by the value of the column
    #country+code in each new cell in the new column.

    @see: L{ColumnFilter}, L{RenameFilter}

    &#34;&#34;&#34;

    def __init__(self, source, specs, before=False):
        &#34;&#34;&#34;Construct a new AddColumnsFilter.

        The I{source} parameter may be either a string or a list of
        strings (for multiple columns). Each string must have the
        following format (I{&lt;header text&gt;} is optional):

        I{&lt;header text&gt;}B{#}I{&lt;tag and attributes&gt;}B{=}I{&lt;constant value&gt;}

        Example::

            Country name#country=Malasia

        By default, this filter will add new columns to the end of
        existing ones, but you can use optional I{before} parameter to
        add them to the front.

        @param source: a HXL data source

        @param specs: a string or list of strings containing new
        column specifications, as described above (or a list of tuples
        as described in L{parse_spec})
        @param before: true to add new columns before existing ones (default C{False})

        &#34;&#34;&#34;
        super().__init__(source)
        if isinstance(specs, six.string_types):
            # make a one-item list if the param is a string
            specs = [specs]
        self.specs = [AddColumnsFilter.parse_spec(spec) for spec in specs]
        self.before = before
        &#34;&#34;&#34;If True, add new columns before existing ones&#34;&#34;&#34;
        self.const_values = None
        &#34;&#34;&#34;Constant values to add to the new columns&#34;&#34;&#34;

    def filter_columns(self):
        &#34;&#34;&#34;Internal: return the new columns list
        @returns: a list of L{hxl.model.Column} objects
        &#34;&#34;&#34;
        new_columns = [spec[0] for spec in self.specs]
        if self.before:
            new_columns = new_columns + self.source.columns
        else:
            new_columns = self.source.columns + new_columns
        self.const_values = [spec[1] for spec in self.specs]
        return new_columns

    def filter_row(self, row):
        &#34;&#34;&#34;Internal: return each row with the new fixed value(s) attached.
        Will execute pattern substitutions inside double braces for the fixed values.
        @returns: a list of values, including the fixed values for new columns
        &#34;&#34;&#34;
        values = copy.copy(row.values)
        if self.before:
            return self._subst(row, self.const_values) + values
        else:
            return values + self._subst(row, self.const_values)

    _SUBST_PATTERN = r&#39;{{(.+?)}}&#39; # non-greedy expression
    &#34;&#34;&#34;Regular expression to parse a substitution pattern in the fixed contents for the new cell&#34;&#34;&#34;

    def _subst(self, row, const_values):
        &#34;&#34;&#34;Execute pattern substitutions for fixed values for the new columns.
        Substitutions are tag patterns inside double braces. Example: &#34;X-{{#country+code}}&#34;
        @param row: the row to search for matches to any patterns.
        @param const_values: the constant values to scan for patterns
        @returns: the constant values (only) with substitutions executed
        &#34;&#34;&#34;
        def do_sub(match_object):
            # FIXME don&#39;t want to reparse the formula for every row
            # Need to pre-parse and pre-chunk the replacement string
            result = feval.eval(row, match_object.group(1))
            return str(result)
        values = []
        for value in const_values:
            values.append(re.sub(AddColumnsFilter._SUBST_PATTERN, do_sub, value))
        return values

    SPEC_PATTERN = r&#39;^\s*(?:([^#]*?)#)?({token}(?:\s*\+{token})*)=(.*)\s*$&#39;.format(token=hxl.datatypes.TOKEN_PATTERN)
    &#34;&#34;&#34;Pattern for a string specification for a new column&#34;&#34;&#34;

    @staticmethod
    def parse_spec(spec):
        &#34;&#34;&#34;Parse a new-column specification.

        The format is I{&lt;header text&gt;}B{#}I{&lt;tag and
        attributes&gt;}B{=}I{&lt;fixed value&gt;}. Example::

          Country name#country=Malaysia

        @param spec: the string spec to parse, in the format above.
        @returns: a tuple containing a L{hxl.model.Column} object and the fixed value.
        &#34;&#34;&#34;

        if not isinstance(spec, six.string_types):
            return spec
        result = re.match(AddColumnsFilter.SPEC_PATTERN, spec)
        if result:
            header = result.group(1)
            tag = &#39;#&#39; + result.group(2)
            value = result.group(3)
            return (hxl.model.Column.parse(tag, header=header), value)
        else:
            raise HXLFilterException(&#34;Badly formatted new-column spec: &#34; + spec)

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;New instance from a JSON-style dictionary.
        @param source: the upstream data source
        @param spec: the JSON-style specification
        &#34;&#34;&#34;
        return AddColumnsFilter(
            source=source,
            specs=req_arg(spec, &#39;specs&#39;),
            before=opt_arg(spec, &#39;before&#39;, False)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hxl.filters.AddColumnsFilter.SPEC_PATTERN"><code class="name">var <span class="ident">SPEC_PATTERN</span></code></dt>
<dd>
<div class="desc"><p>Pattern for a string specification for a new column</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="hxl.filters.AddColumnsFilter.parse_spec"><code class="name flex">
<span>def <span class="ident">parse_spec</span></span>(<span>spec)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a new-column specification.</p>
<p>The format is I{<header text>}B{#}I{<tag and
attributes>}B{=}I{<fixed value>}. Example::</p>
<p>Country name#country=Malaysia</p>
<p>@param spec: the string spec to parse, in the format above.
@returns: a tuple containing a L{hxl.model.Column} object and the fixed value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_spec(spec):
    &#34;&#34;&#34;Parse a new-column specification.

    The format is I{&lt;header text&gt;}B{#}I{&lt;tag and
    attributes&gt;}B{=}I{&lt;fixed value&gt;}. Example::

      Country name#country=Malaysia

    @param spec: the string spec to parse, in the format above.
    @returns: a tuple containing a L{hxl.model.Column} object and the fixed value.
    &#34;&#34;&#34;

    if not isinstance(spec, six.string_types):
        return spec
    result = re.match(AddColumnsFilter.SPEC_PATTERN, spec)
    if result:
        header = result.group(1)
        tag = &#39;#&#39; + result.group(2)
        value = result.group(3)
        return (hxl.model.Column.parse(tag, header=header), value)
    else:
        raise HXLFilterException(&#34;Badly formatted new-column spec: &#34; + spec)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.filters.AddColumnsFilter.before"><code class="name">var <span class="ident">before</span></code></dt>
<dd>
<div class="desc"><p>If True, add new columns before existing ones</p></div>
</dd>
<dt id="hxl.filters.AddColumnsFilter.const_values"><code class="name">var <span class="ident">const_values</span></code></dt>
<dd>
<div class="desc"><p>Constant values to add to the new columns</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.AddColumnsFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal: return the new columns list
@returns: a list of L{hxl.model.Column} objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34;Internal: return the new columns list
    @returns: a list of L{hxl.model.Column} objects
    &#34;&#34;&#34;
    new_columns = [spec[0] for spec in self.specs]
    if self.before:
        new_columns = new_columns + self.source.columns
    else:
        new_columns = self.source.columns + new_columns
    self.const_values = [spec[1] for spec in self.specs]
    return new_columns</code></pre>
</details>
</dd>
<dt id="hxl.filters.AddColumnsFilter.filter_row"><code class="name flex">
<span>def <span class="ident">filter_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal: return each row with the new fixed value(s) attached.
Will execute pattern substitutions inside double braces for the fixed values.
@returns: a list of values, including the fixed values for new columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_row(self, row):
    &#34;&#34;&#34;Internal: return each row with the new fixed value(s) attached.
    Will execute pattern substitutions inside double braces for the fixed values.
    @returns: a list of values, including the fixed values for new columns
    &#34;&#34;&#34;
    values = copy.copy(row.values)
    if self.before:
        return self._subst(row, self.const_values) + values
    else:
        return values + self._subst(row, self.const_values)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.Aggregator"><code class="flex name class">
<span>class <span class="ident">Aggregator</span></span>
<span>(</span><span>type='count', pattern=None, column=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for aggregating a single value vertically through a dataset
.
This is the class that accumulates a line count, sum, min, max, or average value
across all rows of a dataset. Add any new aggregator types here.</p>
<p>Constructor
See the L{parse} and L{parse_list} static methods for creating an aggregator from a string spec.
@param type: the aggregator type to create, as a string
@param pattern: the tag pattern for disaggregation (may be C{None} for just counting lines)
@param column: the hashtag and attributes for the output column with aggregated values
@exception HXLFilterException: if C{pattern} is C{None} and C{type} isn't C{"count"}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Aggregator(object):
    &#34;&#34;&#34;Class for aggregating a single value vertically through a dataset
.
    This is the class that accumulates a line count, sum, min, max, or average value
    across all rows of a dataset. Add any new aggregator types here.
    &#34;&#34;&#34;

    def __init__(self, type=&#39;count&#39;, pattern=None, column=None):
        &#34;&#34;&#34;Constructor
        See the L{parse} and L{parse_list} static methods for creating an aggregator from a string spec.
        @param type: the aggregator type to create, as a string
        @param pattern: the tag pattern for disaggregation (may be C{None} for just counting lines)
        @param column: the hashtag and attributes for the output column with aggregated values
        @exception HXLFilterException: if C{pattern} is C{None} and C{type} isn&#39;t C{&#34;count&#34;}
        &#34;&#34;&#34;
        super().__init__()
        self.type = type.lower()
        if pattern:
            self.pattern = hxl.model.TagPattern.parse(pattern)
        elif type == &#39;count&#39;:
            self.pattern = None
        else:
            raise HXLFilterException(&#39;Pattern missing for {} aggregator&#39;.format(type))
        if not column:
            column = &#39;{type}#meta+{type}&#39;.format(type=self.type)
        self.column = hxl.model.Column.parse_spec(column)

        self.total = 0
        &#34;&#34;&#34;Total number of rows used.&#34;&#34;&#34;

        self.value = None
        &#34;&#34;&#34;Resulting aggregation value.&#34;&#34;&#34;

        self.normalised = None
        &#34;&#34;&#34;Normalised value to use for internal comparison&#34;&#34;&#34;

        self.values = set()
        &#34;&#34;&#34;Unique values seen (for concat)&#34;&#34;&#34;

    def evaluate_row(self, row):
        &#34;&#34;&#34;Evaluate a single row of HXL data against this aggregator.
        @param row: the input row to read
        @exception HXLFilterException: for an unrecognised aggregator type
        &#34;&#34;&#34;

        #
        # Shortcut: just counting rows
        #
        if self.type == &#39;count&#39;:
            if self.value is None:
                self.value = 0
            self.value += 1
            return

        #
        # Aggregating values
        #
        value = row.get(self.pattern)

        # Skip empty values
        if hxl.datatypes.is_empty(value):
            return

        # Numbers only for sum and average
        datatype = hxl.datatypes.typeof(value, self.pattern)
        if self.type in [&#39;sum&#39;, &#39;average&#39;] and datatype != &#39;number&#39;:
            logger.error(&#34;Cannot use %s as a numeric value for aggregation; skipping.&#34;, value)
            return

        normalised = hxl.datatypes.normalise(value, self.pattern)
        self.total += 1

        # aggregate as appropriate
        # note that we track a separate normalised value for strings and dates
        if self.type == &#39;sum&#39;:
            if self.value is None:
                self.value = 0
            self.value += normalised
        elif self.type == &#39;average&#39;:
            if self.value is None:
                self.value = 0
            self.value = ((self.value * (self.total - 1)) + normalised) / self.total
        elif self.type == &#39;min&#39;:
            def gt(a, b):
                try:
                    return a &gt; b
                except TypeError:
                    return str(a) &gt; str(b)
            if self.normalised is None or gt(self.normalised, normalised):
                self.value = value
                self.normalised = normalised
        elif self.type == &#39;max&#39;:
            def lt(a, b):
                try:
                    return a &lt; b
                except TypeError:
                    return str(a) &lt; str(b)
            if self.normalised is None or lt(self.normalised, normalised):
                self.value = value
                self.normalised = normalised
        elif self.type == &#39;concat&#39;:
            if not hxl.datatypes.is_empty(value):
                value = hxl.datatypes.normalise_space(value)
                if value not in self.values:
                    # regenerate the list if it&#39;s a new value
                    self.values.add(value)
                    self.value = &#34;|&#34;.join(sorted(self.values))
        else:
            raise HXLFilterException(&#34;Bad aggregator type for count filter: {}&#34;.format(type))

    TAG_PATTERN = r&#39;#?{token}(?:\s*[+-]{token})*&#39;.format(token=hxl.datatypes.TOKEN_PATTERN)
    &#34;&#34;&#34;Regular expression for a tag pattern&#34;&#34;&#34;
    
    COL_PATTERN = r&#39;#{token}(?:\s*\+{token})*&#39;.format(token=hxl.datatypes.TOKEN_PATTERN)
    &#34;&#34;&#34;Regular expression for an output column pattern&#34;&#34;&#34;

    AGGREGATOR_PATTERN = r&#39;^\s*({token})\(({tag})?\)(?:\s*as\s+([^#]*)({col}))?$&#39;.format(
        token = hxl.datatypes.TOKEN_PATTERN,
        tag = TAG_PATTERN,
        col = COL_PATTERN
    )
    &#34;&#34;&#34; Regular expression for an aggregation pattern
    Matches 1=aggregator, 2=tag pattern, 3=column header, 4=column tag
    &#34;&#34;&#34;

    @staticmethod
    def parse(spec):
        &#34;&#34;&#34;Parse a string specification and create an aggregator.
        Example: C{sum(#affected) as #affected+total}
        @param spec: the string specification
        @returns: an aggregator
        @exception HXLFilterException: if unable to parse, or an unrecognised aggregator type
        &#34;&#34;&#34;
        if isinstance(spec, Aggregator):
            # in case it&#39;s already parsed
            return spec
        match = re.match(Aggregator.AGGREGATOR_PATTERN, spec)
        if not match:
            raise HXLFilterException(&#34;Malformed aggregator: {}&#34;.format(spec))
        return Aggregator(
            type=match.group(1),
            pattern=hxl.model.TagPattern.parse(match.group(2)) if match.group(2) else None,
            column=hxl.model.Column.parse(match.group(4), header=match.group(3), use_exception=True) if match.group(4) else None,
        )

    @staticmethod
    def parse_list(specs):
        &#34;&#34;&#34;Parse a list of string specifications for aggregators
        Applies L{parse} to each item in the list
        @param specs: a list of string specifications for aggregators
        @returns: a list of L{Aggregator} objects
        @exception HXLFilterException: if unable to parse, or an unrecognised aggregator type
        &#34;&#34;&#34;
        result = []
        if isinstance(specs, six.string_types):
            specs = [specs]
        for spec in specs:
            result.append(Aggregator.parse(spec))
        return result</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="hxl.filters.Aggregator.AGGREGATOR_PATTERN"><code class="name">var <span class="ident">AGGREGATOR_PATTERN</span></code></dt>
<dd>
<div class="desc"><p>Regular expression for an aggregation pattern
Matches 1=aggregator, 2=tag pattern, 3=column header, 4=column tag</p></div>
</dd>
<dt id="hxl.filters.Aggregator.COL_PATTERN"><code class="name">var <span class="ident">COL_PATTERN</span></code></dt>
<dd>
<div class="desc"><p>Regular expression for an output column pattern</p></div>
</dd>
<dt id="hxl.filters.Aggregator.TAG_PATTERN"><code class="name">var <span class="ident">TAG_PATTERN</span></code></dt>
<dd>
<div class="desc"><p>Regular expression for a tag pattern</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="hxl.filters.Aggregator.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>spec)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a string specification and create an aggregator.
Example: C{sum(#affected) as #affected+total}
@param spec: the string specification
@returns: an aggregator
@exception HXLFilterException: if unable to parse, or an unrecognised aggregator type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(spec):
    &#34;&#34;&#34;Parse a string specification and create an aggregator.
    Example: C{sum(#affected) as #affected+total}
    @param spec: the string specification
    @returns: an aggregator
    @exception HXLFilterException: if unable to parse, or an unrecognised aggregator type
    &#34;&#34;&#34;
    if isinstance(spec, Aggregator):
        # in case it&#39;s already parsed
        return spec
    match = re.match(Aggregator.AGGREGATOR_PATTERN, spec)
    if not match:
        raise HXLFilterException(&#34;Malformed aggregator: {}&#34;.format(spec))
    return Aggregator(
        type=match.group(1),
        pattern=hxl.model.TagPattern.parse(match.group(2)) if match.group(2) else None,
        column=hxl.model.Column.parse(match.group(4), header=match.group(3), use_exception=True) if match.group(4) else None,
    )</code></pre>
</details>
</dd>
<dt id="hxl.filters.Aggregator.parse_list"><code class="name flex">
<span>def <span class="ident">parse_list</span></span>(<span>specs)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a list of string specifications for aggregators
Applies L{parse} to each item in the list
@param specs: a list of string specifications for aggregators
@returns: a list of L{Aggregator} objects
@exception HXLFilterException: if unable to parse, or an unrecognised aggregator type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_list(specs):
    &#34;&#34;&#34;Parse a list of string specifications for aggregators
    Applies L{parse} to each item in the list
    @param specs: a list of string specifications for aggregators
    @returns: a list of L{Aggregator} objects
    @exception HXLFilterException: if unable to parse, or an unrecognised aggregator type
    &#34;&#34;&#34;
    result = []
    if isinstance(specs, six.string_types):
        specs = [specs]
    for spec in specs:
        result.append(Aggregator.parse(spec))
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.filters.Aggregator.normalised"><code class="name">var <span class="ident">normalised</span></code></dt>
<dd>
<div class="desc"><p>Normalised value to use for internal comparison</p></div>
</dd>
<dt id="hxl.filters.Aggregator.total"><code class="name">var <span class="ident">total</span></code></dt>
<dd>
<div class="desc"><p>Total number of rows used.</p></div>
</dd>
<dt id="hxl.filters.Aggregator.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Resulting aggregation value.</p></div>
</dd>
<dt id="hxl.filters.Aggregator.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>Unique values seen (for concat)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.Aggregator.evaluate_row"><code class="name flex">
<span>def <span class="ident">evaluate_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate a single row of HXL data against this aggregator.
@param row: the input row to read
@exception HXLFilterException: for an unrecognised aggregator type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_row(self, row):
    &#34;&#34;&#34;Evaluate a single row of HXL data against this aggregator.
    @param row: the input row to read
    @exception HXLFilterException: for an unrecognised aggregator type
    &#34;&#34;&#34;

    #
    # Shortcut: just counting rows
    #
    if self.type == &#39;count&#39;:
        if self.value is None:
            self.value = 0
        self.value += 1
        return

    #
    # Aggregating values
    #
    value = row.get(self.pattern)

    # Skip empty values
    if hxl.datatypes.is_empty(value):
        return

    # Numbers only for sum and average
    datatype = hxl.datatypes.typeof(value, self.pattern)
    if self.type in [&#39;sum&#39;, &#39;average&#39;] and datatype != &#39;number&#39;:
        logger.error(&#34;Cannot use %s as a numeric value for aggregation; skipping.&#34;, value)
        return

    normalised = hxl.datatypes.normalise(value, self.pattern)
    self.total += 1

    # aggregate as appropriate
    # note that we track a separate normalised value for strings and dates
    if self.type == &#39;sum&#39;:
        if self.value is None:
            self.value = 0
        self.value += normalised
    elif self.type == &#39;average&#39;:
        if self.value is None:
            self.value = 0
        self.value = ((self.value * (self.total - 1)) + normalised) / self.total
    elif self.type == &#39;min&#39;:
        def gt(a, b):
            try:
                return a &gt; b
            except TypeError:
                return str(a) &gt; str(b)
        if self.normalised is None or gt(self.normalised, normalised):
            self.value = value
            self.normalised = normalised
    elif self.type == &#39;max&#39;:
        def lt(a, b):
            try:
                return a &lt; b
            except TypeError:
                return str(a) &lt; str(b)
        if self.normalised is None or lt(self.normalised, normalised):
            self.value = value
            self.normalised = normalised
    elif self.type == &#39;concat&#39;:
        if not hxl.datatypes.is_empty(value):
            value = hxl.datatypes.normalise_space(value)
            if value not in self.values:
                # regenerate the list if it&#39;s a new value
                self.values.add(value)
                self.value = &#34;|&#34;.join(sorted(self.values))
    else:
        raise HXLFilterException(&#34;Bad aggregator type for count filter: {}&#34;.format(type))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hxl.filters.AppendFilter"><code class="flex name class">
<span>class <span class="ident">AppendFilter</span></span>
<span>(</span><span>source, append_sources, add_columns=True, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter class to concatenate two datasets.</p>
<p>Usage::</p>
<pre><code>filter = AppendFilter(hxl.data(url), hxl.data(url2))
</code></pre>
<p>This filter concatenates a second dataset to the end of the first
one. It supports the L{hxl.model.Dataset.append} convenience
method, and the L{hxl.scripts.hxlappend} command-line script.</p>
<p>The filter preserves the order of the columns in the first
dataset. If there are any columns in the second dataset that do
not appear in the first, then the behaviour depends on the value
of the I{add_columns} property:</p>
<ul>
<li>if C{True} (default), add extra columns from the second dataset
(and leave their values blank for the first).</li>
<li>if C{False}, ignore extra columns from the second dataset.</li>
</ul>
<p>Note that HXL tags must match exactly, including any tag
attributes, for two columns to be considered as matches.</p>
<p>A common use case is be to start with an empty dataset as a
template so that the columns and headers are as desired in the
final output, then append other datasets to that, with
I{add_columns} set to C{False} to ignore any extra data in the
dataset.</p>
<p>To append multiple datasets, chain the filters::</p>
<pre><code>filter = HXLAppend(HXLAppend(hxl.data(url), hxl.data(url2), False), hxl.data(url3), False)
</code></pre>
<p>Or, more intuitively (using the convenience methods)::</p>
<pre><code>hxl.data(url).append(url2, False).append(url3, False)
</code></pre>
<p>If you have an unknown number of URLs to append, try something
like this::</p>
<pre><code>source = hxl.data(template_url)
for url in my_list_of_urls:
    source = AppendFilter(source, url, True)
</code></pre>
<p>It's also possible to be selective about what you append, using the I{queries} parameter::</p>
<pre><code>filter = AppendFilter(source, source2, queries='org=UNICEF')
</code></pre>
<p>In the second dataset, this filter will include I{only} rows where
the value "UNICEF" appears under the C{#org} tag.</p>
<p>This class class is a special case, neither a L{streaming
filter<AbstractStreamingFilter>} nor a L{caching
filter<AbstractCachingFilter>}; instead, it streams two separate
datasets, one starting after the other, so it extends
L{AbstractBaseFilter} directly, and implements its own custom
iterator.</p>
<p>@see: L{MergeDataFilter}, which combines two datasets horizontally
rather than vertically.</p>
<p>Construct a new I{AppendFilter}
@param source: a L{hxl.model.Dataset} object for the principal data
@param append_sources: one or more L{hxl.model.Dataset} objects for the dataset to append (or strings containing URLs)
@param add_columns: flag for adding extra columns in append_sources but not source (default True)
@param queries: optional list of L{hxl.model.RowQuery} objects
(or a single strig) to select which rows to include from the
second dataset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppendFilter(AbstractBaseFilter):

    &#34;&#34;&#34;Composable filter class to concatenate two datasets.

    Usage::
    
        filter = AppendFilter(hxl.data(url), hxl.data(url2))

    This filter concatenates a second dataset to the end of the first
    one. It supports the L{hxl.model.Dataset.append} convenience
    method, and the L{hxl.scripts.hxlappend} command-line script.

    The filter preserves the order of the columns in the first
    dataset. If there are any columns in the second dataset that do
    not appear in the first, then the behaviour depends on the value
    of the I{add_columns} property:

      - if C{True} (default), add extra columns from the second dataset
        (and leave their values blank for the first).
      - if C{False}, ignore extra columns from the second dataset.

    Note that HXL tags must match exactly, including any tag
    attributes, for two columns to be considered as matches.

    A common use case is be to start with an empty dataset as a
    template so that the columns and headers are as desired in the
    final output, then append other datasets to that, with
    I{add_columns} set to C{False} to ignore any extra data in the
    dataset.

    To append multiple datasets, chain the filters::

        filter = HXLAppend(HXLAppend(hxl.data(url), hxl.data(url2), False), hxl.data(url3), False)

    Or, more intuitively (using the convenience methods)::

        hxl.data(url).append(url2, False).append(url3, False)

    If you have an unknown number of URLs to append, try something
    like this::

        source = hxl.data(template_url)
        for url in my_list_of_urls:
            source = AppendFilter(source, url, True)

    It&#39;s also possible to be selective about what you append, using the I{queries} parameter::

        filter = AppendFilter(source, source2, queries=&#39;org=UNICEF&#39;)

    In the second dataset, this filter will include I{only} rows where
    the value &#34;UNICEF&#34; appears under the C{#org} tag.

    This class class is a special case, neither a L{streaming
    filter&lt;AbstractStreamingFilter&gt;} nor a L{caching
    filter&lt;AbstractCachingFilter&gt;}; instead, it streams two separate
    datasets, one starting after the other, so it extends
    L{AbstractBaseFilter} directly, and implements its own custom
    iterator.

    @see: L{MergeDataFilter}, which combines two datasets horizontally
    rather than vertically.

    &#34;&#34;&#34;

    def __init__(self, source, append_sources, add_columns=True, queries=[]):
        &#34;&#34;&#34;Construct a new I{AppendFilter}
        @param source: a L{hxl.model.Dataset} object for the principal data
        @param append_sources: one or more L{hxl.model.Dataset} objects for the dataset to append (or strings containing URLs)
        @param add_columns: flag for adding extra columns in append_sources but not source (default True)
        @param queries: optional list of L{hxl.model.RowQuery} objects
        (or a single strig) to select which rows to include from the
        second dataset
        &#34;&#34;&#34;
        super(AppendFilter, self).__init__(source)

        # parameters
        if is_sourcey(append_sources):
            append_sources = [append_sources]
        self.append_sources = [hxl.data(src) for src in append_sources] # so that we can take a plain URL
        &#34;&#34;&#34;The sources to append to this source&#34;&#34;&#34;
        self.add_extra_columns = add_columns
        &#34;&#34;&#34;If true, always add new columns instead of replacing existing ones&#34;&#34;&#34;
        self.queries = self._setup_queries(queries)
        &#34;&#34;&#34;The row queries to limit where we choose append candidates&#34;&#34;&#34;

        # internal properties
        self._column_positions = []
        &#34;&#34;&#34;Cache of column positions, to avoid rescanning on every pass&#34;&#34;&#34;
        self._template_row = []
        &#34;&#34;&#34;Empty template for appending to each row (will copy and fill in as needed&#34;&#34;&#34;

    def filter_columns(self):
        &#34;&#34;&#34;Internal: generate the columns for the combined dataset
        We expect this method to run only once.
        @returns: the output list of L{hxl.model.Column} objects
        &#34;&#34;&#34;

        columns_out = copy.deepcopy(self.source.columns)

        for i, append_source in enumerate(self.append_sources):

            columns_in = list(columns_out)
            self._column_positions.append({})

            # see if there&#39;s a corresponding column in the source
            for j, column in enumerate(append_source.columns):
                for k, original_column in enumerate(columns_in):
                    if column == original_column:
                        # yes, there is one; clear it, so it&#39;s not reused
                        self._column_positions[i][j] = k
                        columns_in[k] = None
                        break
                if self._column_positions[i].get(j) is None:
                    # no -- we need to add a new column
                    if self.add_extra_columns:
                        self._column_positions[i][j] = len(columns_out)
                        columns_out.append(copy.deepcopy(column))
                    else:
                        self._column_positions[i][j] = None

        # make an empty template for each row
        self._template_row = [&#39;&#39;] * len(columns_out)

        # return the (usually cached) columns
        return columns_out


    def __iter__(self):
        self.columns # make sure this is triggered first
        return AppendFilter._Iterator(self)

    class _Iterator:
        &#34;&#34;&#34;Custom iterator to return the contents of all sources, in sequence.&#34;&#34;&#34;

        def __init__(self, outer):
            &#34;&#34;&#34;@param outer: reference to outer object&#34;&#34;&#34;
            self.outer = outer
            
            self._iterator = iter(outer.source)
            self._column_map = {i: i for i in range(len(self.outer.source.columns))}
            self._is_source = True

            self._sources = list(self.outer.append_sources)
            self._column_positions = list(self.outer._column_positions)

        def __iter__(self):
            return self

        def __next__(self):

            def make_row():
                row_in = next(self._iterator)
                while ((not self._is_source) and (not hxl.model.RowQuery.match_list(row_in, self.outer.queries))):
                    row_in = next(self._iterator)

                row_out = hxl.model.Row(
                    columns=self.outer.columns,
                    values=copy.deepcopy(self.outer._template_row)
                )

                for i, value in enumerate(row_in.values):
                    pos = self._column_map[i]
                    if pos is not None:
                        row_out.values[pos] = value

                return row_out

            while self._iterator is not None:
                try:
                    return make_row()
                except StopIteration:
                    if self._sources:
                        self._iterator = iter(self._sources[0])
                        self._column_map = self._column_positions[0]
                        self._sources = self._sources[1:]
                        self._column_positions = self._column_positions[1:]
                        self._is_source = False
                    else:
                        self._iterator = None

            raise StopIteration()

    @staticmethod
    def parse_external_source_list(input):
        append_sources = []
        with hxl.data(input) as source:
            for row in source:
                append_source = row.get(&#39;#x_source&#39;)
                if append_source:
                    append_sources.append(append_source)
        return append_sources
        
    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create an AppendFilter from a dict spec.
        @param spec: the string specification
        &#34;&#34;&#34;

        if spec.get(&#39;filter&#39;) == &#39;append_external_list&#39;:
            append_sources = AppendFilter.parse_external_source_list(
                hxl.data(req_arg(spec, &#39;source_list_url&#39;))
            )
        else:
            append_sources = req_arg(spec, &#39;append_sources&#39;)
            
        return AppendFilter(
            source=source,
            append_sources=append_sources,
            add_columns=opt_arg(spec, &#39;add_columns&#39;, True),
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="hxl.filters.AppendFilter.parse_external_source_list"><code class="name flex">
<span>def <span class="ident">parse_external_source_list</span></span>(<span>input)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_external_source_list(input):
    append_sources = []
    with hxl.data(input) as source:
        for row in source:
            append_source = row.get(&#39;#x_source&#39;)
            if append_source:
                append_sources.append(append_source)
    return append_sources</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.filters.AppendFilter.add_extra_columns"><code class="name">var <span class="ident">add_extra_columns</span></code></dt>
<dd>
<div class="desc"><p>If true, always add new columns instead of replacing existing ones</p></div>
</dd>
<dt id="hxl.filters.AppendFilter.append_sources"><code class="name">var <span class="ident">append_sources</span></code></dt>
<dd>
<div class="desc"><p>The sources to append to this source</p></div>
</dd>
<dt id="hxl.filters.AppendFilter.queries"><code class="name">var <span class="ident">queries</span></code></dt>
<dd>
<div class="desc"><p>The row queries to limit where we choose append candidates</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.AppendFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal: generate the columns for the combined dataset
We expect this method to run only once.
@returns: the output list of L{hxl.model.Column} objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34;Internal: generate the columns for the combined dataset
    We expect this method to run only once.
    @returns: the output list of L{hxl.model.Column} objects
    &#34;&#34;&#34;

    columns_out = copy.deepcopy(self.source.columns)

    for i, append_source in enumerate(self.append_sources):

        columns_in = list(columns_out)
        self._column_positions.append({})

        # see if there&#39;s a corresponding column in the source
        for j, column in enumerate(append_source.columns):
            for k, original_column in enumerate(columns_in):
                if column == original_column:
                    # yes, there is one; clear it, so it&#39;s not reused
                    self._column_positions[i][j] = k
                    columns_in[k] = None
                    break
            if self._column_positions[i].get(j) is None:
                # no -- we need to add a new column
                if self.add_extra_columns:
                    self._column_positions[i][j] = len(columns_out)
                    columns_out.append(copy.deepcopy(column))
                else:
                    self._column_positions[i][j] = None

    # make an empty template for each row
    self._template_row = [&#39;&#39;] * len(columns_out)

    # return the (usually cached) columns
    return columns_out</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractBaseFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.CacheFilter"><code class="flex name class">
<span>class <span class="ident">CacheFilter</span></span>
<span>(</span><span>source, max_rows=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter to cache HXL data in memory.</p>
<p>This filter saves a copy of the HXL data in memory. It supports
the L{hxl.model.Dataset.cache} method, and has no corresponding
command-line script.</p>
<p>Does not extend AbstractCachingFilter, because it needs to
preserve original row numbers (when they exist).</p>
<p>While L{streaming filters<AbstractStreamingFilter>} are more
efficient, sometimes you need to keep a copy of your HXL data in
memory, so that you can iterate over it more than once. Some
filters, like L{SortFilter} and L{CountFilter}, do that as a side
effect, but you can also choose to add a I{CacheFilter} explicitly
to your chain.</p>
<p>This filter does nothing but save a copy of your data for repeated
use, as in the following example::</p>
<p>filter = Cache(hxl.data(url))</p>
<p>or::</p>
<p>filter = hxl.data(url).cache()</p>
<p>It is also possible to cache just I{part} of the data, as a
preview or to avoid crashing on excessively-large datasets::</p>
<p># cache just the first 10 rows
preview = Cache(hxl.data(url), 10)</p>
<p>If there were more rows of data available, then the filter will
set the L{overflow} property to C{True}.</p>
<p>You can also use the cache filter strategically in a filter chain
to save the results of an expensive operation (like replacing
data) to avoid repeating it.
For example, this sequence will
never run the replacements more than once::</p>
<p>filter = hxl.data(url).replace_data_map(map_url).cache().with_rows('org=UNICEF')</p>
<p>Constructor
@param source: the upstream data source
@param max_rows: if &gt;0, maximum number of rows to cache</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CacheFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Composable filter to cache HXL data in memory.

    This filter saves a copy of the HXL data in memory. It supports
    the L{hxl.model.Dataset.cache} method, and has no corresponding
    command-line script.

    Does not extend AbstractCachingFilter, because it needs to
    preserve original row numbers (when they exist).

    While L{streaming filters&lt;AbstractStreamingFilter&gt;} are more
    efficient, sometimes you need to keep a copy of your HXL data in
    memory, so that you can iterate over it more than once. Some
    filters, like L{SortFilter} and L{CountFilter}, do that as a side
    effect, but you can also choose to add a I{CacheFilter} explicitly
    to your chain.

    This filter does nothing but save a copy of your data for repeated
    use, as in the following example::

      filter = Cache(hxl.data(url))

    or::

      filter = hxl.data(url).cache()

    It is also possible to cache just I{part} of the data, as a
    preview or to avoid crashing on excessively-large datasets::

      # cache just the first 10 rows
      preview = Cache(hxl.data(url), 10)

    If there were more rows of data available, then the filter will
    set the L{overflow} property to C{True}.

    You can also use the cache filter strategically in a filter chain
    to save the results of an expensive operation (like replacing
    data) to avoid repeating it.  For example, this sequence will
    never run the replacements more than once::

      filter = hxl.data(url).replace_data_map(map_url).cache().with_rows(&#39;org=UNICEF&#39;)

    &#34;&#34;&#34;

    def __init__(self, source, max_rows=None):
        &#34;&#34;&#34;Constructor
        @param source: the upstream data source
        @param max_rows: if &gt;0, maximum number of rows to cache
        &#34;&#34;&#34;
        super().__init__(source)

        self.max_rows = max_rows
        &#34;&#34;&#34;Maximum number of rows to keep in the cache (-1 means no limit)&#34;&#34;&#34;

        self.overflow = False
        &#34;&#34;&#34;Flag for whether there were more rows than L{max_rows} available.&#34;&#34;&#34;

        self.cached_rows = None

    @property
    def is_cached(self):
        return True

    def filter_columns(self):
        &#34;&#34;&#34;@returns: a deep copy of the source columns&#34;&#34;&#34;
        return copy.deepcopy(self.source.columns)

    def __iter__(self):

        # if we haven&#39;t read the source yet, cache some rows
        if self.cached_rows is None:
            self.cached_rows = []
            for row_number, row in enumerate(self.source):
                # is there a limit?
                if self.max_rows is not None and row_number &gt;= self.max_rows:
                    self.overflow = True
                    break
                else:
                    self.cached_rows.append(row)

        # return the iterator over the cached rows (repeatable)
        return iter(self.cached_rows)

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a new CacheFilter from a dict spec.&#34;&#34;&#34;
        return CacheFilter(
            source=source,
            max_rows=opt_arg(spec, &#39;max_rows&#39;, None)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.filters.CacheFilter.max_rows"><code class="name">var <span class="ident">max_rows</span></code></dt>
<dd>
<div class="desc"><p>Maximum number of rows to keep in the cache (-1 means no limit)</p></div>
</dd>
<dt id="hxl.filters.CacheFilter.overflow"><code class="name">var <span class="ident">overflow</span></code></dt>
<dd>
<div class="desc"><p>Flag for whether there were more rows than L{max_rows} available.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.CacheFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: a deep copy of the source columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34;@returns: a deep copy of the source columns&#34;&#34;&#34;
    return copy.deepcopy(self.source.columns)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractBaseFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.CleanDataFilter"><code class="flex name class">
<span>class <span class="ident">CleanDataFilter</span></span>
<span>(</span><span>source, whitespace=False, upper=[], lower=[], date=[], date_format=None, number=[], number_format=None, latlon=[], purge=False, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Data-cleaning filter.</p>
<p>This filter can perform a set of automated cleaning tasks,
including character-case conversion, whitespace normalisation, and
date and number normalisation. It supports the
L{hxl.model.Dataset.clean_data} method and the
L{hxl.scripts.hxlclean} command-line script.</p>
<p>The clean filter is especially useful when you are working with
data from different sources who might use different date and
number conventions, and also for datasets with inconsistent
whitespace and capitalisation. The following functions are
available (and can be filtered by row and column):</p>
<ul>
<li>B{whitespace}: strip leading/trailing spaces, and normalise
all internal whitespace (including lineends) to a single
space.</li>
<li>B{upper}: convert text to all uppercase.</li>
<li>B{lower}: convert text to all lowercase.</li>
<li>B{date}: attempt to parse and normalise dates to ISO 8601
format (YYYY-MM-DD). This will not always succeed &ndash; for
example, it is impossible to guess whether "9/6/15" refers to
6 September 2016 or 9 June 2016 (hence the need for ISO dates)
&ndash; but it will do its best.</li>
<li>B{number}: attempt to normalise numbers to standard computer
format (remove commas or spaces between thousands, and use "."
as the decimal separator).</li>
<li>B{latlon}: attempt to normalise latitude and longitude values.</li>
</ul>
<p>For each type of cleaning, you specify one or more L{tag
patterns<hxl.model.TagPattern>} to which the cleaning applies (you
may use string representations instead of creating the objects),
or use C{True} to apply the cleaning to the whole row. You may
also include L{hxl.model.RowQuery} objects to apply the cleaning
tasks only to specific rows. You can also specify a format for
normalised dates or numbers, and choose to purge any dates,
numbers, or latlon that can't be parsed (to guarantee clean data,
at the cost of possible information loss).</p>
<p>This example normalises all start dates from Oxfam::</p>
<p>filter = CleanFilter(hxl.data('data.csv'), dates='date+start', queries='org=Oxfam')</p>
<p># or</p>
<p>filter = hxl.data('data.csv').clean_data(dates='date+start', queries='org=Oxfam')</p>
<p>@see: L{ReplaceDataFilter}, which allows for more-specific
replacements using string and regular-expression patterns.</p>
<p>Construct a new data-cleaning filter.</p>
<p>The I{upper}, I{lower}, I{date}, I{number}, and I{latlon}
arguments all accept either lists of tag
patterns&lt;hxl.model.TagPattern or individual patterns, which
can be strings (like C{#org+impl-code}) or full
L{hxl.model.TagPattern} objects. The I{queries} argument
accepts either lists of queries or individual queries, which
can be strings (like C{org=Oxfam}) or full
L{hxl.model.RowQuery} objects.</p>
<p>@param source: a L{hxl.model.Dataset} object to filter
@param whitespace: a tag pattern or list of tag patterns for whitespace normalisation
@param upper: a tag pattern or list of tag patterns for conversion to uppercase
@param lower: a tag pattern or list of tag patterns for conversion to lowercase
@param date: a tag pattern or list of tag patterns for date normalisation
@param date_format: a date-format string for output, as used by strftime
@param number: a tag pattern or list of tag patterns for number normalisation
@param number_format: a number-format string for output, as used by format.
@param laton: a list of tag patterns for normalising latitude/longitude.
@param purge: if True, remove any dates, numbers, or lat/lon that can't be parsed during cleaning.
@param queries: optional list of queries to select rows to be cleaned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CleanDataFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Data-cleaning filter.

    This filter can perform a set of automated cleaning tasks,
    including character-case conversion, whitespace normalisation, and
    date and number normalisation. It supports the
    L{hxl.model.Dataset.clean_data} method and the
    L{hxl.scripts.hxlclean} command-line script.

    The clean filter is especially useful when you are working with
    data from different sources who might use different date and
    number conventions, and also for datasets with inconsistent
    whitespace and capitalisation. The following functions are
    available (and can be filtered by row and column):

      - B{whitespace}: strip leading/trailing spaces, and normalise
        all internal whitespace (including lineends) to a single
        space.
      - B{upper}: convert text to all uppercase.
      - B{lower}: convert text to all lowercase.
      - B{date}: attempt to parse and normalise dates to ISO 8601
        format (YYYY-MM-DD). This will not always succeed -- for
        example, it is impossible to guess whether &#34;9/6/15&#34; refers to
        6 September 2016 or 9 June 2016 (hence the need for ISO dates)
        -- but it will do its best.
      - B{number}: attempt to normalise numbers to standard computer
        format (remove commas or spaces between thousands, and use &#34;.&#34;
        as the decimal separator).
      - B{latlon}: attempt to normalise latitude and longitude values.
      
    For each type of cleaning, you specify one or more L{tag
    patterns&lt;hxl.model.TagPattern&gt;} to which the cleaning applies (you
    may use string representations instead of creating the objects),
    or use C{True} to apply the cleaning to the whole row. You may
    also include L{hxl.model.RowQuery} objects to apply the cleaning
    tasks only to specific rows. You can also specify a format for
    normalised dates or numbers, and choose to purge any dates,
    numbers, or latlon that can&#39;t be parsed (to guarantee clean data,
    at the cost of possible information loss).

    This example normalises all start dates from Oxfam::

      filter = CleanFilter(hxl.data(&#39;data.csv&#39;), dates=&#39;date+start&#39;, queries=&#39;org=Oxfam&#39;)

      # or

      filter = hxl.data(&#39;data.csv&#39;).clean_data(dates=&#39;date+start&#39;, queries=&#39;org=Oxfam&#39;)

    @see: L{ReplaceDataFilter}, which allows for more-specific
    replacements using string and regular-expression patterns.
    &#34;&#34;&#34;

    def __init__(
            self, source, whitespace=False, upper=[], lower=[], date=[], date_format=None,
            number=[], number_format=None, latlon=[], purge=False, queries=[]):
        &#34;&#34;&#34;Construct a new data-cleaning filter.

        The I{upper}, I{lower}, I{date}, I{number}, and I{latlon}
        arguments all accept either lists of tag
        patterns&lt;hxl.model.TagPattern or individual patterns, which
        can be strings (like C{#org+impl-code}) or full
        L{hxl.model.TagPattern} objects. The I{queries} argument
        accepts either lists of queries or individual queries, which
        can be strings (like C{org=Oxfam}) or full
        L{hxl.model.RowQuery} objects.

        @param source: a L{hxl.model.Dataset} object to filter
        @param whitespace: a tag pattern or list of tag patterns for whitespace normalisation
        @param upper: a tag pattern or list of tag patterns for conversion to uppercase
        @param lower: a tag pattern or list of tag patterns for conversion to lowercase
        @param date: a tag pattern or list of tag patterns for date normalisation
        @param date_format: a date-format string for output, as used by strftime
        @param number: a tag pattern or list of tag patterns for number normalisation
        @param number_format: a number-format string for output, as used by format.
        @param laton: a list of tag patterns for normalising latitude/longitude.
        @param purge: if True, remove any dates, numbers, or lat/lon that can&#39;t be parsed during cleaning.
        @param queries: optional list of queries to select rows to be cleaned.
        &#34;&#34;&#34;
        super(CleanDataFilter, self).__init__(source)
        self.whitespace = hxl.model.TagPattern.parse_list(whitespace)
        self.upper = hxl.model.TagPattern.parse_list(upper)
        self.lower = hxl.model.TagPattern.parse_list(lower)
        self.date = hxl.model.TagPattern.parse_list(date)
        self.date_format = date_format
        self.number = hxl.model.TagPattern.parse_list(number)
        self.number_format = number_format
        self.latlon = hxl.model.TagPattern.parse_list(latlon)
        self.purge = purge
        self.queries = self._setup_queries(queries)

        # We need to prescan for dates
        if date:
            self.source = self.source.cache();
            self.date_dayfirst = self._guess_dayfirst()

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: cleaned row data&#34;&#34;&#34;
        if hxl.model.RowQuery.match_list(row, self.queries):
            # if there are no queries, or row matches at least one
            columns = self.columns
            values = copy.copy(row.values)
            for i in range(min(len(values), len(columns))):
                values[i] = self._clean_value(values[i], columns[i])
            return values
        else:
            # otherwise, leave as-is
            return row.values

    def _guess_dayfirst(self):
        &#34;&#34;&#34;Guess whether the default should be DD-MM-YYYY or MM-DD-YYYY
        @returns: true if we should default to dayfirst format
        &#34;&#34;&#34;
        ddmm_count = 0
        mmdd_count = 0
        
        # prescan columns to speed things up
        indices = []
        for i, column in enumerate(self.source.columns):
            if hxl.TagPattern.match_list(column, self.date):
                indices.append(i)

        # if there are any matching columns, then prescan values
        if indices:
            for row in self.source:
                for i in indices:
                    value = row.values[i]
                    if value:
                        result = re.match(r&#39;^[^\d]*(\d\d?)[^\d]+(\d\d?)[^\d].*$&#39;, hxl.datatypes.normalise_string(value))
                        if result:
                            if int(result.group(1)) &gt; 12:
                                ddmm_count += 1
                            elif int(result.group(2)) &gt; 12:
                                mmdd_count += 1

        return (ddmm_count &gt;= mmdd_count)

    
    def _clean_value(self, value, column):
        &#34;&#34;&#34;Clean a single value, using the column def for guidance.
        @returns: a single cleaned value
        &#34;&#34;&#34;
        value = str(value)

        # Whitespace (-w)
        if self._match_patterns(self.whitespace, column):
            value = re.sub(r&#39;^\s+&#39;, &#39;&#39;, value)
            value = re.sub(r&#39;\s+$&#39;, &#39;&#39;, value)
            value = re.sub(r&#39;\s+&#39;, &#39; &#39;, value)

        # Uppercase (-u)
        if self._match_patterns(self.upper, column):
            value = value.upper()

        # Lowercase (-l)
        if self._match_patterns(self.lower, column):
            value = value.lower()

        # Date
        if self._match_patterns(self.date, column):
            if value:
                try:
                    value = hxl.datatypes.normalise_date(value, self.date_dayfirst)
                    if self.date_format is not None:
                        value = dateutil.parser.parse(value).strftime(self.date_format)
                except ValueError:
                    logger.warning(&#39;Cannot parse %s as a date&#39;, str(value))
                    if self.purge:
                        value = &#39;&#39;

        # Number
        if self._match_patterns(self.number, column):

            def try_number(s):
                try:
                    n = float(s)
                    if self.number_format:
                        return format(n, self.number_format)
                    elif n.is_integer():
                        return str(int(n))
                    else:
                        return str(n)
                except:
                    return None

                # fixme - get much smarter about numbers
            if value:
                n = try_number(value)
                if n is None:
                    s = re.sub(r&#39;[^\de.]+&#39;, &#39;&#39;, value)
                    n = try_number(s) # OK, try again
                if n is not None:
                    value = n
                else:
                    logger.warning(&#39;Cannot parse {} as a number&#39;, str(value))
                    if self.purge:
                        value = &#39;&#39;

        # Latlon
        if self._match_patterns(self.latlon, column):
            if &#39;lat&#39; in column.attributes:
                lat = hxl.geo.parse_lat(value)
                if lat is not None:
                    value = format(lat, &#39;0.4f&#39;)
                else:
                    logger.warning(&#39;Cannot parse %s as a latitude&#39;, str(value))
                    if self.purge:
                        value = &#39;&#39;
            elif &#39;lon&#39; in column.attributes:
                lon = hxl.geo.parse_lon(value)
                if lon is not None:
                    value = format(lon, &#39;0.4f&#39;)
                else:
                    logger.warning(&#39;Cannot parse %s as a longitude&#39;, str(value))
                    if self.purge:
                        value = &#39;&#39;
            elif &#39;coord&#39; in column. attributes:
                coord = hxl.geo.parse_coord(value)
                if coord is not None:
                    value = &#39;{:.4f},{:.4f}&#39;.format(coord[0], coord[1])
                else:
                    logger.warning(&#39;Cannot parse %s as geographical coordinates&#39;, str(value))
                    if self.purge:
                        value = &#39;&#39;
        
        return value

    def _match_patterns(self, patterns, column):
        &#34;&#34;&#34;Test if a column matches a list of patterns.
        @param patterns: a list of tag patterns to match
        @param column: the column definition to test
        @returns: C{True} if the column matches at least one pattern in the list
        &#34;&#34;&#34;
        if not patterns:
            return False
        else:
            for pattern in patterns:
                if pattern.match(column):
                    return True
            return False

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a new clean-data filter from a dict spec.
        @returns: a L{CleanDataFilter} object
        &#34;&#34;&#34;
        return CleanDataFilter(
            source=source,
            whitespace=opt_arg(spec,&#39;whitespace&#39;, []),
            upper=opt_arg(spec, &#39;upper&#39;, []),
            lower=opt_arg(spec, &#39;lower&#39;, []),
            date=opt_arg(spec, &#39;date&#39;, []),
            date_format=opt_arg(spec, &#39;date_format&#39;, None),
            number=opt_arg(spec, &#39;number&#39;, []),
            number_format=opt_arg(spec, &#39;number_format&#39;, None),
            latlon=opt_arg(spec, &#39;latlon&#39;, []),
            purge=opt_arg(spec, &#39;purge&#39;, False),
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.CleanDataFilter.filter_row"><code class="name flex">
<span>def <span class="ident">filter_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: cleaned row data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_row(self, row):
    &#34;&#34;&#34;@returns: cleaned row data&#34;&#34;&#34;
    if hxl.model.RowQuery.match_list(row, self.queries):
        # if there are no queries, or row matches at least one
        columns = self.columns
        values = copy.copy(row.values)
        for i in range(min(len(values), len(columns))):
            values[i] = self._clean_value(values[i], columns[i])
        return values
    else:
        # otherwise, leave as-is
        return row.values</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.ColumnFilter"><code class="flex name class">
<span>class <span class="ident">ColumnFilter</span></span>
<span>(</span><span>source, include_tags=[], exclude_tags=[], skip_untagged=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter class to remove columns from a HXL dataset.</p>
<p>This filter supports removing columns based on either an include
list or an exclude list of L{tag
patterns<hxl.model.TagPattern>}. It supports the
L{hxl.model.Dataset.with_columns} and
L{hxl.model.Dataset.without_columns} convenience methods and the
L{hxl.scripts.hxlcut} command-line script.</p>
<p>Remove all columns matching the pattern "#contact+email" from the
dataset::</p>
<p>filter = ColumnFilter(hxl.data(url), exclude_tags='contact+email')</p>
<p># or</p>
<p>filter = hxl.data(url).without_columns('contact+email')</p>
<p>Remove all columns I{except} those matching the patterns '#org',
'#sector', and '#activity'::</p>
<p>filter = ColumnFilter(hxl.data(url), include_tags=['org', 'sector', 'activity'])</p>
<p># or</p>
<p>filter = hxl.data(url).with_columns(['org', 'sector', 'activity'])</p>
<p>@see: L{RowFilter}</p>
<p>Construct a column filter.
@param source: a L{hxl.model.Dataset}
@param include_tags: an include list of L{tag patterns<hxl.model.TagPattern>} objects to include
@param exclude_tags: an exclude list of tag patterns objects to exclude
@param skip_untagged: True if all columns without HXL hashtags should be removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColumnFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Composable filter class to remove columns from a HXL dataset.

    This filter supports removing columns based on either an include
    list or an exclude list of L{tag
    patterns&lt;hxl.model.TagPattern&gt;}. It supports the
    L{hxl.model.Dataset.with_columns} and
    L{hxl.model.Dataset.without_columns} convenience methods and the
    L{hxl.scripts.hxlcut} command-line script.

    Remove all columns matching the pattern &#34;#contact+email&#34; from the
    dataset::

      filter = ColumnFilter(hxl.data(url), exclude_tags=&#39;contact+email&#39;)

      # or

      filter = hxl.data(url).without_columns(&#39;contact+email&#39;)

    Remove all columns I{except} those matching the patterns &#39;#org&#39;,
    &#39;#sector&#39;, and &#39;#activity&#39;::

      filter = ColumnFilter(hxl.data(url), include_tags=[&#39;org&#39;, &#39;sector&#39;, &#39;activity&#39;])

      # or

      filter = hxl.data(url).with_columns([&#39;org&#39;, &#39;sector&#39;, &#39;activity&#39;])

    @see: L{RowFilter}

    &#34;&#34;&#34;

    def __init__(self, source, include_tags=[], exclude_tags=[], skip_untagged=False):
        &#34;&#34;&#34;Construct a column filter.
        @param source: a L{hxl.model.Dataset}
        @param include_tags: an include list of L{tag patterns&lt;hxl.model.TagPattern&gt;} objects to include
        @param exclude_tags: an exclude list of tag patterns objects to exclude
        @param skip_untagged: True if all columns without HXL hashtags should be removed
        &#34;&#34;&#34;
        super(ColumnFilter, self).__init__(source)
        self.include_tags = hxl.model.TagPattern.parse_list(include_tags)
        self.exclude_tags = hxl.model.TagPattern.parse_list(exclude_tags)
        self.skip_untagged = skip_untagged
        self.indices = [] # saved indices for columns to include

    def filter_columns(self):
        &#34;&#34;&#34;@returns: filtered list of column definitions&#34;&#34;&#34;
        columns_in = self.source.columns
        columns_out = []
        for i in range(len(columns_in)):
            if self._test_column(columns_in[i]):
                columns_out.append(copy.deepcopy(columns_in[i]))
                self.indices.append(i) # save index to avoid retesting for data
        return columns_out

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: filtered list of row values&#34;&#34;&#34;
        values = []
        for i in self.indices:
            try:
                values.append(row.values[i])
            except IndexError:
                pass # don&#39;t add anything
        return values

    def _test_column(self, column):
        &#34;&#34;&#34;Test whether a column should be included in the output.  If there
        is an include list, it must be in that list; if there is an
        exclude list, it must not be in that list.

        @param column: the L{hxl.model.Column} to test 
        @returns: True if the column should be included

        &#34;&#34;&#34;
        if self.include_tags:
            # exclude list
            for pattern in self.include_tags:
                if pattern.match(column):
                    # succeed as soon as we match an included pattern
                    return True
            # fail if there was an exclude list and we didn&#39;t match
            return False

        if self.exclude_tags or self.skip_untagged:
            # skip untagged columns?
            if self.skip_untagged and not column.tag:
                return False
            # exclude list
            for pattern in self.exclude_tags:
                if pattern.match(column):
                    # fail as soon as we match an excluded pattern
                    return False

        # not an include list, and no reason to exclude
        return True

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a filter object from a JSON-like spec.
        Note that there are two JSON filter definitions for this class: &#34;with_columns&#34; and &#34;without_columns&#34;.
        @param spec: the specification
        @returns: a L{ColumnFilter} object
        &#34;&#34;&#34;
        if spec.get(&#39;filter&#39;) == &#39;with_columns&#39;:
            return ColumnFilter(
                source=source,
                include_tags=req_arg(spec, &#39;includes&#39;)
            )
        else:
            return ColumnFilter(
                source=source,
                exclude_tags=req_arg(spec, &#39;excludes&#39;),
                skip_untagged=opt_arg(spec, &#39;skip_untagged&#39;)
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.ColumnFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: filtered list of column definitions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34;@returns: filtered list of column definitions&#34;&#34;&#34;
    columns_in = self.source.columns
    columns_out = []
    for i in range(len(columns_in)):
        if self._test_column(columns_in[i]):
            columns_out.append(copy.deepcopy(columns_in[i]))
            self.indices.append(i) # save index to avoid retesting for data
    return columns_out</code></pre>
</details>
</dd>
<dt id="hxl.filters.ColumnFilter.filter_row"><code class="name flex">
<span>def <span class="ident">filter_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: filtered list of row values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_row(self, row):
    &#34;&#34;&#34;@returns: filtered list of row values&#34;&#34;&#34;
    values = []
    for i in self.indices:
        try:
            values.append(row.values[i])
        except IndexError:
            pass # don&#39;t add anything
    return values</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.CountFilter"><code class="flex name class">
<span>class <span class="ident">CountFilter</span></span>
<span>(</span><span>source, patterns, aggregators=None, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter class to aggregate rows in a HXL dataset (like a pivot table)</p>
<p>This class supports the L{hxl.model.Dataset.count} convenience
method and the L{hxl.scripts.hxlcount} command-line script.</p>
<p>This is a L{caching filter<AbstractCachingFilter>} that performs
aggregate actions such as counting, summing, and averaging across
multiple rows of data. For example, it can reduce a dataset to a
list of the number of times that each organisation or sector
appears. This is the main filter for producing reports, or the
data underlying charts and other visualisations; it is also useful
for anonymising data by rolling it up to higher levels of
abstraction.</p>
<p>This example counts the number of rows for each organisation::</p>
<p>filter = CountFilter(hxl.data(url), 'org')</p>
<p># or</p>
<p>filter = hxl.data(url).count('org')</p>
<p>You can do multiple levels of counting like this::</p>
<p>filter = hxl.data(url).count(['org', 'sector'])</p>
<p>You can also use the I{queries} argument to limit the counting to
specific fields. This example will count only the rows where C{#adm1} is set to "Coast"::</p>
<p>filter = hxl.data(url).count('org', queries='adm1=Coast')</p>
<p>Construct a new count filter
If the caller does not supply any aggregators, use "count() as Count#meta+count"
@param source: a L{hxl.model.Dataset}
@param patterns: a single L{tag pattern<hxl.model.TagPattern>} or list of tag patterns that, together, form a unique key for counting.
@param aggregators: one or more Aggregator objects or string representations to define the output.
@param queries: an optional list of L{row queries<hxl.model.RowQuery>} to filter the rows being counted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CountFilter(AbstractCachingFilter):
    &#34;&#34;&#34;Composable filter class to aggregate rows in a HXL dataset (like a pivot table)

    This class supports the L{hxl.model.Dataset.count} convenience
    method and the L{hxl.scripts.hxlcount} command-line script.

    This is a L{caching filter&lt;AbstractCachingFilter&gt;} that performs
    aggregate actions such as counting, summing, and averaging across
    multiple rows of data. For example, it can reduce a dataset to a
    list of the number of times that each organisation or sector
    appears. This is the main filter for producing reports, or the
    data underlying charts and other visualisations; it is also useful
    for anonymising data by rolling it up to higher levels of
    abstraction.

    This example counts the number of rows for each organisation::

      filter = CountFilter(hxl.data(url), &#39;org&#39;)

      # or

      filter = hxl.data(url).count(&#39;org&#39;)

    You can do multiple levels of counting like this::

      filter = hxl.data(url).count([&#39;org&#39;, &#39;sector&#39;])

    You can also use the I{queries} argument to limit the counting to
    specific fields. This example will count only the rows where C{#adm1} is set to &#34;Coast&#34;::

      filter = hxl.data(url).count(&#39;org&#39;, queries=&#39;adm1=Coast&#39;)
    &#34;&#34;&#34;

    def __init__(self, source, patterns, aggregators=None, queries=[]):
        &#34;&#34;&#34;Construct a new count filter
        If the caller does not supply any aggregators, use &#34;count() as Count#meta+count&#34;
        @param source: a L{hxl.model.Dataset}
        @param patterns: a single L{tag pattern&lt;hxl.model.TagPattern&gt;} or list of tag patterns that, together, form a unique key for counting.
        @param aggregators: one or more Aggregator objects or string representations to define the output.
        @param queries: an optional list of L{row queries&lt;hxl.model.RowQuery&gt;} to filter the rows being counted.
        &#34;&#34;&#34;
        super().__init__(source)
        self.patterns = hxl.model.TagPattern.parse_list(patterns)
        if not aggregators:
            aggregators = &#39;count() as Count#meta+count&#39;
        self.aggregators = Aggregator.parse_list(aggregators)
        self.queries = self._setup_queries(queries)

    def filter_columns(self):
        &#34;&#34;&#34;@returns: the filtered columns&#34;&#34;&#34;
        columns = []

        # Add columns being counted
        for pattern in self.patterns:
            column = pattern.find_column(self.source.columns)
            if column:
                columns.append(copy.deepcopy(column))
            else:
                columns.append(hxl.Column())

        # Add generated columns
        for aggregator in self.aggregators:
            columns.append(aggregator.column)
            
        return columns

    def filter_rows(self):
        &#34;&#34;&#34;@returns: the filtered row values&#34;&#34;&#34;

        raw_data = []

        # each item is a sequence containing a tuple of key values and an _Aggregator object
        for aggregate in self._aggregate_data():
            raw_data.append(
                list(aggregate[0]) + [aggregator.value if aggregator.value is not None else &#39;&#39; for aggregator in aggregate[1]]
            )
            
        return raw_data

    def _aggregate_data(self):
        &#34;&#34;&#34;Read the entire source dataset and produce saved aggregate data.
        @returns: the aggregated values as raw data
        &#34;&#34;&#34;
        aggregators = {}

        # read the whole source dataset at once
        for row in self.source:
            # will always match if there are no queries
            if hxl.model.RowQuery.match_list(row, self.queries):
                # get the values in the order we need them
                values = [hxl.datatypes.normalise_space(row.get(pattern, default=&#39;&#39;)) for pattern in self.patterns]
                # make a dict key for the aggregator
                key = tuple(values)
                if not key in aggregators:
                    aggregators[key] = [copy.deepcopy(aggregator) for aggregator in self.aggregators]
                for aggregator in aggregators[key]:
                    aggregator.evaluate_row(row)

        # sort the aggregators by their keys
        return sorted(aggregators.items())

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a new count filter from a dict spec.
        @param spec: the JSON-like spec
        @returns: a new L{CountFilter} object
        &#34;&#34;&#34;
        return CountFilter(
            source = source,
            patterns=opt_arg(spec, &#39;patterns&#39;),
            aggregators=opt_arg(spec, &#39;aggregators&#39;, None),
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractCachingFilter" href="#hxl.filters.AbstractCachingFilter">AbstractCachingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.CountFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: the filtered columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34;@returns: the filtered columns&#34;&#34;&#34;
    columns = []

    # Add columns being counted
    for pattern in self.patterns:
        column = pattern.find_column(self.source.columns)
        if column:
            columns.append(copy.deepcopy(column))
        else:
            columns.append(hxl.Column())

    # Add generated columns
    for aggregator in self.aggregators:
        columns.append(aggregator.column)
        
    return columns</code></pre>
</details>
</dd>
<dt id="hxl.filters.CountFilter.filter_rows"><code class="name flex">
<span>def <span class="ident">filter_rows</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: the filtered row values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_rows(self):
    &#34;&#34;&#34;@returns: the filtered row values&#34;&#34;&#34;

    raw_data = []

    # each item is a sequence containing a tuple of key values and an _Aggregator object
    for aggregate in self._aggregate_data():
        raw_data.append(
            list(aggregate[0]) + [aggregator.value if aggregator.value is not None else &#39;&#39; for aggregator in aggregate[1]]
        )
        
    return raw_data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractCachingFilter" href="#hxl.filters.AbstractCachingFilter">AbstractCachingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractCachingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.is_cached" href="#hxl.filters.AbstractCachingFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.DeduplicationFilter"><code class="flex name class">
<span>class <span class="ident">DeduplicationFilter</span></span>
<span>(</span><span>source, patterns=None, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter to deduplicate a HXL dataset.</p>
<p>Removes duplicate lines from a dataset, where "duplicate" is
optionally defined by a set of keys specified by the user. As a
result, not all values in duplicate rows will necessarily be
identical. The filter will always return the <em>first</em> matching row
of a set of duplicates.</p>
<p>Supports the hxldedup command-line script.</p>
<p>TODO: add more-sophisticated matching, edit distance, etc.</p>
<p>Constructor
@param source: the upstream source dataset
@param patterns: if provided, a list of tag patterns for columns to use for uniqueness testing.
@param filters: optional list of filter queries for columns to be considered for deduplication.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeduplicationFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Composable filter to deduplicate a HXL dataset.

    Removes duplicate lines from a dataset, where &#34;duplicate&#34; is
    optionally defined by a set of keys specified by the user. As a
    result, not all values in duplicate rows will necessarily be
    identical. The filter will always return the *first* matching row
    of a set of duplicates.

    Supports the hxldedup command-line script.

    TODO: add more-sophisticated matching, edit distance, etc.
    &#34;&#34;&#34;

    def __init__(self, source, patterns=None, queries=[]):
        &#34;&#34;&#34;
        Constructor
        @param source: the upstream source dataset
        @param patterns: if provided, a list of tag patterns for columns to use for uniqueness testing.
        @param filters: optional list of filter queries for columns to be considered for deduplication.
        &#34;&#34;&#34;
        super().__init__(source)
        self.patterns = hxl.model.TagPattern.parse_list(patterns)
        self.seen_map = set() # row signatures that we&#39;ve seen so far
        self.queries = self._setup_queries(queries)

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: the row&#39;s values, or C{None} if it&#39;s a duplicate&#34;&#34;&#34;
        if hxl.model.RowQuery.match_list(row, self.queries):
            if not row:
                return None
            key = row.key(self.patterns)
            if key in self.seen_map:
                return None
            # if we get to here, we haven&#39;t seen the row before
            self.seen_map.add(key)
            return copy.copy(row.values)
        else:
            return row.values

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a dedup filter from a dict spec.
        @param source: the upstream source
        @param spec: the JSON-like spec
        @returns: a L{DeduplicationFilter} object
        &#34;&#34;&#34;
        return DeduplicationFilter(
            source = source,
            patterns=opt_arg(spec, &#39;patterns&#39;, []),
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.DeduplicationFilter.filter_row"><code class="name flex">
<span>def <span class="ident">filter_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: the row's values, or C{None} if it's a duplicate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_row(self, row):
    &#34;&#34;&#34;@returns: the row&#39;s values, or C{None} if it&#39;s a duplicate&#34;&#34;&#34;
    if hxl.model.RowQuery.match_list(row, self.queries):
        if not row:
            return None
        key = row.key(self.patterns)
        if key in self.seen_map:
            return None
        # if we get to here, we haven&#39;t seen the row before
        self.seen_map.add(key)
        return copy.copy(row.values)
    else:
        return row.values</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.ExpandListsFilter"><code class="flex name class">
<span>class <span class="ident">ExpandListsFilter</span></span>
<span>(</span><span>source, patterns=None, separator='|', correlate=False, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Expand in-cell lists by duplicating data rows.</p>
<p>Construct a new abstract filter.
@param source: the source dataset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExpandListsFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Expand in-cell lists by duplicating data rows.
    &#34;&#34;&#34;

    def __init__(self, source, patterns=None, separator=&#34;|&#34;, correlate=False, queries=[]):
        super().__init__(source)
        self.separator = str(separator)
        self.scan_columns(patterns)
        self.correlate = correlate
        self.queries = self._setup_queries(queries)
        &#34;&#34;&#34;The row queries to limit where we expand lists&#34;&#34;&#34;

    def filter_columns(self):
        &#34;&#34;&#34; Remove the +list attribute from targeted columns &#34;&#34;&#34;
        columns = list(self.source.columns)
        for index in self.column_indices:
            column = copy.deepcopy(columns[index])
            column.remove_attribute(&#39;list&#39;)
            columns[index] = column
        return columns

    def scan_columns(self, patterns):
        &#34;&#34;&#34; Save the indices of the columns containing lists &#34;&#34;&#34;
        self.column_indices = []
        if patterns:
            patterns = hxl.model.TagPattern.parse_list(patterns)
            for i, column in enumerate(self.source.columns):
                if hxl.model.TagPattern.match_list(column, patterns):
                    self.column_indices.append(i)
        else:
            for i, column in enumerate(self.source.columns):
                if column.has_attribute(&#34;list&#34;):
                    self.column_indices.append(i)

    def __iter__(self):

        # Special case: no columns to expand
        if len(self.column_indices) == 0:
            for row in self.source:
                yield row
            return


        # Regular case

        min_length = max(self.column_indices) + 1

        for row in self.source:

            # If there are queries, the row must match one of them
            if not hxl.model.RowQuery.match_list(row, self.queries):
                yield row
                continue

            # parse the lists
            value_lists = []
            for index in self.column_indices:
                if index &lt; len(row.values):
                    values = str(row.values[index]).split(self.separator)
                    value_lists.append(list(map(hxl.datatypes.normalise_space, values)))
                else:
                    value_lists.append([&#34;&#34;])

            if (self.correlate):
                # correlate the lists

                nrows = max([len(item) for item in value_lists])

                for i in range(0, nrows):
                    values = copy.deepcopy(row.values)
                    for j, v in enumerate(value_lists):
                        index = self.column_indices[j]
                        if len(v) &lt;= i:
                            values[index] = &#34;&#34;
                        else:
                            values[index] = v[i]
                    yield hxl.model.Row(self.columns, values)

            else:
                # generate the cartesian product of all the lists

                # generate the cartesian product of the values
                row_value_list = list(itertools.product(*value_lists))

                # yield all of the resulting rows
                for row_values in row_value_list:
                    values = copy.deepcopy(row.values)

                    # make sure the value list is long enough
                    if len(values) &lt; min_length:
                        values += [&#34;&#34;] * (min_length - len(values))

                    # replace the list values
                    for i, value in enumerate(row_values):
                        values[self.column_indices[i]] = value

                    # yield a new row
                    yield hxl.model.Row(self.columns, values)

        
    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;New instance from a JSON-style dictionary.
        @param source: the upstream data source
        @param spec: the JSON-style specification
        &#34;&#34;&#34;
        return ExpandListsFilter(
            source=source,
            patterns=opt_arg(spec, &#39;patterns&#39;),
            separator=opt_arg(spec, &#39;separator&#39;),
            correlate=opt_arg(spec, &#39;correlate&#39;),
            queries=opt_arg(spec, &#39;queries&#39;)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.filters.ExpandListsFilter.queries"><code class="name">var <span class="ident">queries</span></code></dt>
<dd>
<div class="desc"><p>The row queries to limit where we expand lists</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.ExpandListsFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the +list attribute from targeted columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34; Remove the +list attribute from targeted columns &#34;&#34;&#34;
    columns = list(self.source.columns)
    for index in self.column_indices:
        column = copy.deepcopy(columns[index])
        column.remove_attribute(&#39;list&#39;)
        columns[index] = column
    return columns</code></pre>
</details>
</dd>
<dt id="hxl.filters.ExpandListsFilter.scan_columns"><code class="name flex">
<span>def <span class="ident">scan_columns</span></span>(<span>self, patterns)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the indices of the columns containing lists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_columns(self, patterns):
    &#34;&#34;&#34; Save the indices of the columns containing lists &#34;&#34;&#34;
    self.column_indices = []
    if patterns:
        patterns = hxl.model.TagPattern.parse_list(patterns)
        for i, column in enumerate(self.source.columns):
            if hxl.model.TagPattern.match_list(column, patterns):
                self.column_indices.append(i)
    else:
        for i, column in enumerate(self.source.columns):
            if column.has_attribute(&#34;list&#34;):
                self.column_indices.append(i)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractBaseFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.ExplodeFilter"><code class="flex name class">
<span>class <span class="ident">ExplodeFilter</span></span>
<span>(</span><span>source, header_attribute='header', value_attribute='value')</span>
</code></dt>
<dd>
<div class="desc"><p>Explode a wide (series) dataset into a long version.</p>
<p>Every set of identically-tagged columns that contain the +label
attribute in their hashtag will get their own row, with the header
text and the value side by side.
For example,</p>
<p>Country,2015,2014,2013</p>
<h1 id="countryaffectedlabelaffectedlabelaffectedlabel">country,#affected+label,#affected+label,#affected+label</h1>
<p>Cameroon,100,150,120</p>
<p>will be converted to</p>
<p>Country,Header,Value</p>
<h1 id="countryaffectedheaderaffectedvalue">country,#affected+header,#affected+value</h1>
<p>Cameroon,2015,100
Cameroon,2014,150
Cameroon,2015,120</p>
<p>(You can use the RenameFilter to change the names and hashtags of
the generated columns.)</p>
<p>@see: hxl.model.Dataset.explode
@see: hxl.filters.ImplodeFilter</p>
<p>Constructor
@param source: the upstream source dataset
@param header_attribute: the attribute to add to the hashtag for the column with the former header (default: 'header')
@param value_attribute: the attribute to add to the hashtag for the column with the former header (default: 'value')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExplodeFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Explode a wide (series) dataset into a long version.

    Every set of identically-tagged columns that contain the +label
    attribute in their hashtag will get their own row, with the header
    text and the value side by side.  For example,

    Country,2015,2014,2013
    #country,#affected+label,#affected+label,#affected+label
    Cameroon,100,150,120

    will be converted to

    Country,Header,Value
    #country,#affected+header,#affected+value
    Cameroon,2015,100
    Cameroon,2014,150
    Cameroon,2015,120

    (You can use the RenameFilter to change the names and hashtags of
    the generated columns.)

    @see: hxl.model.Dataset.explode
    @see: hxl.filters.ImplodeFilter
    &#34;&#34;&#34;

    def __init__(self, source, header_attribute=&#39;header&#39;, value_attribute=&#39;value&#39;):
        &#34;&#34;&#34;
        Constructor
        @param source: the upstream source dataset
        @param header_attribute: the attribute to add to the hashtag for the column with the former header (default: &#39;header&#39;)
        @param value_attribute: the attribute to add to the hashtag for the column with the former header (default: &#39;value&#39;)
        &#34;&#34;&#34;
        super(ExplodeFilter, self).__init__(source)
        self.header_attribute = header_attribute
        &#34;&#34;&#34;Attribute to add to exploded values from the header&#34;&#34;&#34;
        self.value_attribute = value_attribute
        &#34;&#34;&#34;Attribute to add to the original value from the data cell&#34;&#34;&#34;
        self._generator = None
        self._plan = self._make_plan()

    def filter_columns(self):
        &#34;&#34;&#34;@returns: the new (exploded) column headers&#34;&#34;&#34;
        columns = []
        for spec in self._plan:
            if isinstance(spec, list):
                model_column = self.source.columns[spec[0]]
                columns.append(copy.deepcopy(model_column).remove_attribute(&#39;label&#39;).add_attribute(self.header_attribute))
                columns.append(copy.deepcopy(model_column).remove_attribute(&#39;label&#39;).add_attribute(self.value_attribute))
            else:
                columns.append(self.source.columns[spec])
        return columns

    def __iter__(self):
        &#34;&#34;&#34;Custom iterator to produce exploded rows.&#34;&#34;&#34;
        for row in self.source:
            for values in self._expand(row, self._plan):
                yield hxl.model.Row(self.columns, values)

    def _expand(self, row, plan, values_in=[]):
        &#34;&#34;&#34;Recursive generator for the row data.
        https://wiki.python.org/moin/Generators
        @param row: the row to expland
        @param plan: the pre-generated expansion plan
        @param values_in: the input values
        &#34;&#34;&#34;
        if not plan: # terminal condition
            yield values_in
        else:
            spec = plan[0]
            plan = plan[1:]
            if isinstance(spec, list): # multiple branches
                for index in spec:
                    values = values_in + [row.columns[index].header, row.values[index]]
                    for values_out in self._expand(row, plan, values):
                        yield values_out
            else: # continue on a single branch
                values = values_in + [row.values[spec]]
                for values_out in self._expand(row, plan, values):
                    yield values_out

    def _make_plan(self):
        &#34;&#34;&#34;Create an expansion plan
        The plan is a list of integers, representing columns in the original source.
        Some items are lists of integers, representing variants to show for multiple rows.
        @returns: an expansion plan for the row
        &#34;&#34;&#34;
        plan = []
        groups = {}
        for index, column in enumerate(self.source.columns):
            if &#39;label&#39; in column.attributes:
                if column not in groups:
                    plan.append([index])
                    groups[column] = len(plan) - 1;
                else:
                    plan[groups.get(column)].append(index)
            else:
                plan.append(index)
        return plan

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create an explode filter from a dict spec.
        @param source: the upstream source
        @param spec: the JSON-like filter specification
        @returns: an L{ExplodeFilter} object
        &#34;&#34;&#34;
        return ExplodeFilter(
            source=source,
            header_attribute=opt_arg(spec, &#39;header_attribute&#39;, &#39;header&#39;),
            value_attribute=opt_arg(spec, &#39;value_attribute&#39;, &#39;value&#39;)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.filters.ExplodeFilter.header_attribute"><code class="name">var <span class="ident">header_attribute</span></code></dt>
<dd>
<div class="desc"><p>Attribute to add to exploded values from the header</p></div>
</dd>
<dt id="hxl.filters.ExplodeFilter.value_attribute"><code class="name">var <span class="ident">value_attribute</span></code></dt>
<dd>
<div class="desc"><p>Attribute to add to the original value from the data cell</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.ExplodeFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: the new (exploded) column headers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34;@returns: the new (exploded) column headers&#34;&#34;&#34;
    columns = []
    for spec in self._plan:
        if isinstance(spec, list):
            model_column = self.source.columns[spec[0]]
            columns.append(copy.deepcopy(model_column).remove_attribute(&#39;label&#39;).add_attribute(self.header_attribute))
            columns.append(copy.deepcopy(model_column).remove_attribute(&#39;label&#39;).add_attribute(self.value_attribute))
        else:
            columns.append(self.source.columns[spec])
    return columns</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractBaseFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.FillDataFilter"><code class="flex name class">
<span>class <span class="ident">FillDataFilter</span></span>
<span>(</span><span>source, patterns=None, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Fill empty cells in a dataset.
By default, fill all empty cells with the closest non-empty value in a previous row.
Optionally restrict to specific columns and/or rows.</p>
<p>Constructor
@param source: the source dataset
@param patterns: a tag pattern or list of patterns for the columns to fill (default to all)
@param queries: restrict filling to rows matching one of these queries (default: fill all rows).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FillDataFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Fill empty cells in a dataset.
    By default, fill all empty cells with the closest non-empty value in a previous row.
    Optionally restrict to specific columns and/or rows.
    &#34;&#34;&#34;

    def __init__(self, source, patterns=None, queries=[]):
        &#34;&#34;&#34;Constructor
        @param source: the source dataset
        @param patterns: a tag pattern or list of patterns for the columns to fill (default to all)
        @param queries: restrict filling to rows matching one of these queries (default: fill all rows).
        &#34;&#34;&#34;
        super().__init__(source)
        self.patterns = hxl.model.TagPattern.parse_list(patterns)
        self.queries = self._setup_queries(queries)
        self._saved = {}
        self._indices = None

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: row values with some empty values possibly filled in&#34;&#34;&#34;
        values = list(row.values)

        # Guessing at empty cells (column-wise only)
        if self._indices is None:
            self._indices = self._get_indices(self.patterns)
        for i in self._indices:
            if i &gt;= len(values):
                values += [&#39;&#39;] * (i - len(values) + 1) # make sure list is long enough
            if values[i]:
                self._saved[i] = values[i]
            elif (not self.queries) or (hxl.model.RowQuery.match_list(row, self.queries)):
                values[i] = self._saved[i] if self._saved.get(i) else &#39;&#39;
                    
        return values

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a fill-data filter from a dict spec.
        @param source: the upstream data source
        @param spec: the JSON-like filter specification
        @returns: a L{FillDataFilter} object
        &#34;&#34;&#34;
        return FillDataFilter(
            source=source,
            patterns=opt_arg(spec, &#39;patterns&#39;),
            queries=opt_arg(spec, &#39;queries&#39;),
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.FillDataFilter.filter_row"><code class="name flex">
<span>def <span class="ident">filter_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: row values with some empty values possibly filled in</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_row(self, row):
    &#34;&#34;&#34;@returns: row values with some empty values possibly filled in&#34;&#34;&#34;
    values = list(row.values)

    # Guessing at empty cells (column-wise only)
    if self._indices is None:
        self._indices = self._get_indices(self.patterns)
    for i in self._indices:
        if i &gt;= len(values):
            values += [&#39;&#39;] * (i - len(values) + 1) # make sure list is long enough
        if values[i]:
            self._saved[i] = values[i]
        elif (not self.queries) or (hxl.model.RowQuery.match_list(row, self.queries)):
            values[i] = self._saved[i] if self._saved.get(i) else &#39;&#39;
                
    return values</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.HXLFilterException"><code class="flex name class">
<span>class <span class="ident">HXLFilterException</span></span>
<span>(</span><span>message, data={})</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for HXL filter exceptions.</p>
<p>This subclass of L{hxl.HXLException} exists only to make it
easier to distinguish filter-based exceptions in C{except:} clauses.</p>
<p>Create a new HXL exception.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>error message for the exception</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>properties associated with the exception (default {})</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HXLFilterException(hxl.HXLException):
    &#34;&#34;&#34;Base class for HXL filter exceptions.

    This subclass of L{hxl.HXLException} exists only to make it
    easier to distinguish filter-based exceptions in C{except:} clauses.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.HXLException" href="index.html#hxl.HXLException">HXLException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.HXLException" href="index.html#hxl.HXLException">HXLException</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.HXLException.data" href="index.html#hxl.HXLException.data">data</a></code></li>
<li><code><a title="hxl.HXLException.message" href="index.html#hxl.HXLException.message">message</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.ImplodeFilter"><code class="flex name class">
<span>class <span class="ident">ImplodeFilter</span></span>
<span>(</span><span>source, label_pattern, value_pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Implode a long (series) dataset into a wide version.</p>
<p>The first column matching the pattern will be used as headers. For example, with the tag pattern #date+year,</p>
<p>Country,Header,Value</p>
<h1 id="countrydateyearaffected">country,#date+year,#affected</h1>
<p>Cameroon,2015,100
Cameroon,2014,150
Cameroon,2015,120</p>
<p>will be converted to </p>
<p>Country,2015,2014,2013</p>
<h1 id="countryaffectedlabelaffectedlabelaffectedlabel">country,#affected+label,#affected+label,#affected+label</h1>
<p>Cameroon,100,150,120</p>
<p>@see: hxl.model.Dataset.implode
@see: hxl.filters.ExplodeFilter</p>
<p>Constructor
@param source: the upstream source dataset
@param pattern: the tag pattern to use for the labels
@param output_tagspec: the tagspec to use for the repeated, wide columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImplodeFilter(AbstractBaseFilter):
    &#34;&#34;&#34;Implode a long (series) dataset into a wide version.

    The first column matching the pattern will be used as headers. For example, with the tag pattern #date+year,

    Country,Header,Value
    #country,#date+year,#affected
    Cameroon,2015,100
    Cameroon,2014,150
    Cameroon,2015,120

    will be converted to 

    Country,2015,2014,2013
    #country,#affected+label,#affected+label,#affected+label
    Cameroon,100,150,120

    @see: hxl.model.Dataset.implode
    @see: hxl.filters.ExplodeFilter
    &#34;&#34;&#34;

    def __init__(self, source, label_pattern, value_pattern):
        &#34;&#34;&#34; Constructor
        @param source: the upstream source dataset
        @param pattern: the tag pattern to use for the labels
        @param output_tagspec: the tagspec to use for the repeated, wide columns
        &#34;&#34;&#34;
        super(ImplodeFilter, self).__init__(source)
        self.label_pattern = label_pattern
        self.value_pattern = value_pattern
        
        self.processed = False
        self.label_index = -1
        self.value_index = -1
        self.labels = set()
        self.rows = dict()
        self.new_columns = None
        self.source_iterator = None

    def filter_columns(self):
        &#34;&#34;&#34;@returns: the new (exploded) column headers&#34;&#34;&#34;
        if self.new_columns is None:
            self.process()
            # add existing columns (excluding label and value columns)
            self.new_columns = []
            for i, column in enumerate(self.source.columns):
                if i != self.label_index and i != self.value_index:
                    self.new_columns.append(column)

            # add extra columns for new, &#34;wide&#34; data
            model = self.source.columns[self.value_index]
            for label in sorted(self.labels):
                attributes = set(model.attributes)
                attributes.add(&#34;label&#34;)
                column = hxl.model.Column(tag=model.tag, attributes=attributes, header=label)
                self.new_columns.append(column)

        return self.new_columns

    def __iter__(self):
        &#34;&#34;&#34;Custom iterator to produce exploded rows.&#34;&#34;&#34;
        self.process()
        for key in self.rows:
            values = list(key)
            # extra, wide values
            for label in sorted(self.labels):
                values.append(self.rows[key].get(label, &#34;&#34;))
            yield hxl.model.Row(self.columns, values)

    def process(self):
        # check if we&#39;ve already done all this
        if self.processed:
            return

        # determine the indices of the label and value columns
        # if either is missing, just pass on the source data normally (with logged errors)
        lpattern = hxl.model.TagPattern.parse(self.label_pattern)
        vpattern = hxl.model.TagPattern.parse(self.value_pattern)
        for i, column in enumerate(self.source.columns):
            if lpattern.match(column):
                if self.label_index == -1:
                    self.label_index = i
                else:
                    logger.warning(
                        &#34;[Implode filter] multiple columns match label pattern %s; using first match %s (%s)&#34;,
                        self.label_pattern,
                        self.source.columns[self.label_index].display_tag,
                        self.source.columns[self.label_index].header
                    )
            if vpattern.match(column):
                if self.value_index == -1:
                    self.value_index = i
                else:
                    logger.warning(
                        &#34;[Implode filter] multiple columns match value pattern %s; using first match&#34;,
                        self.value_pattern,
                        self.source.columns[self.value_index].display_tag,
                        self.source.columns[self.value_index].header
                    )

        if self.label_index == -1:
            raise HXLFilterException(&#34;No matching label column for {}&#34;.format(self.label_pattern))
        
        if self.value_index == -1:
            raise HXLFilterException(&#34;No matching value column for {}&#34;.format(self.value_pattern))

        # iterate through the dataset
        for row in self.source:

            values = list(row.values)

            # get the &#34;wide&#34; label and value
            label = &#34;&#34;
            if self.label_index &lt; len(values):
                label = values[self.label_index]

            self.labels.add(label)

            value = &#34;&#34;
            if self.value_index &lt; len(values):
                value = values[self.value_index]

            # make a key tuple, excluding the label and value columns
            values = []
            for i, value in enumerate(row.values):
                if i != self.label_index and i != self.value_index:
                    values.append(value)
            key = tuple(values)

            # check to see if we already have data for that key
            if key not in self.rows:
                self.rows[key] = {}
            if label in self.rows[key]:
                logger.error(&#34;Multiple values for %s in implode filter; using %s&#34;, label, self.rows[key][label])
            else:
                self.rows[key][label] = value
            
    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create an implode filter from a dict spec.
        @param source: the upstream source
        @param spec: the JSON-like filter specification
        @returns: an L{ImplodeFilter} object
        &#34;&#34;&#34;
        return ImplodeFilter(
            source=source,
            label_pattern=req_arg(spec, &#39;label_pattern&#39;),
            value_pattern=req_arg(spec, &#39;value_pattern&#39;)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.ImplodeFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: the new (exploded) column headers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34;@returns: the new (exploded) column headers&#34;&#34;&#34;
    if self.new_columns is None:
        self.process()
        # add existing columns (excluding label and value columns)
        self.new_columns = []
        for i, column in enumerate(self.source.columns):
            if i != self.label_index and i != self.value_index:
                self.new_columns.append(column)

        # add extra columns for new, &#34;wide&#34; data
        model = self.source.columns[self.value_index]
        for label in sorted(self.labels):
            attributes = set(model.attributes)
            attributes.add(&#34;label&#34;)
            column = hxl.model.Column(tag=model.tag, attributes=attributes, header=label)
            self.new_columns.append(column)

    return self.new_columns</code></pre>
</details>
</dd>
<dt id="hxl.filters.ImplodeFilter.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    # check if we&#39;ve already done all this
    if self.processed:
        return

    # determine the indices of the label and value columns
    # if either is missing, just pass on the source data normally (with logged errors)
    lpattern = hxl.model.TagPattern.parse(self.label_pattern)
    vpattern = hxl.model.TagPattern.parse(self.value_pattern)
    for i, column in enumerate(self.source.columns):
        if lpattern.match(column):
            if self.label_index == -1:
                self.label_index = i
            else:
                logger.warning(
                    &#34;[Implode filter] multiple columns match label pattern %s; using first match %s (%s)&#34;,
                    self.label_pattern,
                    self.source.columns[self.label_index].display_tag,
                    self.source.columns[self.label_index].header
                )
        if vpattern.match(column):
            if self.value_index == -1:
                self.value_index = i
            else:
                logger.warning(
                    &#34;[Implode filter] multiple columns match value pattern %s; using first match&#34;,
                    self.value_pattern,
                    self.source.columns[self.value_index].display_tag,
                    self.source.columns[self.value_index].header
                )

    if self.label_index == -1:
        raise HXLFilterException(&#34;No matching label column for {}&#34;.format(self.label_pattern))
    
    if self.value_index == -1:
        raise HXLFilterException(&#34;No matching value column for {}&#34;.format(self.value_pattern))

    # iterate through the dataset
    for row in self.source:

        values = list(row.values)

        # get the &#34;wide&#34; label and value
        label = &#34;&#34;
        if self.label_index &lt; len(values):
            label = values[self.label_index]

        self.labels.add(label)

        value = &#34;&#34;
        if self.value_index &lt; len(values):
            value = values[self.value_index]

        # make a key tuple, excluding the label and value columns
        values = []
        for i, value in enumerate(row.values):
            if i != self.label_index and i != self.value_index:
                values.append(value)
        key = tuple(values)

        # check to see if we already have data for that key
        if key not in self.rows:
            self.rows[key] = {}
        if label in self.rows[key]:
            logger.error(&#34;Multiple values for %s in implode filter; using %s&#34;, label, self.rows[key][label])
        else:
            self.rows[key][label] = value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractBaseFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.JSONPathFilter"><code class="flex name class">
<span>class <span class="ident">JSONPathFilter</span></span>
<span>(</span><span>source, path, patterns=None, queries=[], use_json=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract values from a JSON string expression using JSONPath
See <a href="http://goessner.net/articles/JsonPath/">http://goessner.net/articles/JsonPath/</a>
Optionally restrict to specific columns and/or rows</p>
<p>Constructor
@param source: the upstream data source
@param path: a JSONPath expression for extracting data
@param patterns: a tag pattern or list of patterns for the columns to use (default to all)
@param queries: a predicate or list of predicates for the rows to consider.
@param use_json: if True, serialise multiple values as JSON (default); otherwise, separate with " | "</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONPathFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Extract values from a JSON string expression using JSONPath
    See http://goessner.net/articles/JsonPath/
    Optionally restrict to specific columns and/or rows
    &#34;&#34;&#34;

    def __init__(self, source, path, patterns=None, queries=[], use_json=True):
        &#34;&#34;&#34;Constructor
        @param source: the upstream data source
        @param path: a JSONPath expression for extracting data
        @param patterns: a tag pattern or list of patterns for the columns to use (default to all)
        @param queries: a predicate or list of predicates for the rows to consider.
        @param use_json: if True, serialise multiple values as JSON (default); otherwise, separate with &#34; | &#34;
        &#34;&#34;&#34;
        super().__init__(source)
        self.path = jsonpath_ng.ext.parse(path)
        self.patterns = hxl.model.TagPattern.parse_list(patterns)
        self.queries = self._setup_queries(queries)
        self.use_json = use_json
        self._indices = None

    def filter_row(self, row):
        if self._indices is None:
            self._indices = self._get_indices(self.patterns)

        values = list(row.values)

        if hxl.model.RowQuery.match_list(row, self.queries):
        
            for i in self._indices:
                try:
                    expr = json.loads(values[i])
                    results = [match.value for match in self.path.find(expr)]
                    if len(results) == 0:
                        values[i] = &#39;&#39;
                    elif len(results) == 1:
                        values[i] = hxl.datatypes.flatten(results[0], self.use_json)
                    else:
                        values[i] = hxl.datatypes.flatten(results, self.use_json)
                except (ValueError, TypeError,) as e:
                    logger.warning(&#34;Skipping invalid JSON expression &#39;%s&#39;&#34;, values[i])

        return values
    
    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a JSONPath filter from a dict spec.
        @param source: the upstream data source
        @param spec: the JSON-like filter specification
        @returns: a L{RenameFilter} object
        &#34;&#34;&#34;
        return JSONPathFilter(
            source=source,
            path=req_arg(spec, &#39;path&#39;),
            patterns=opt_arg(spec, &#39;patterns&#39;),
            queries=opt_arg(spec, &#39;queries&#39;)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.filter_row" href="#hxl.filters.AbstractStreamingFilter.filter_row">filter_row</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.MergeDataFilter"><code class="flex name class">
<span>class <span class="ident">MergeDataFilter</span></span>
<span>(</span><span>source, merge_source, keys, tags, replace=False, overwrite=False, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter class to merge values from two HXL datasets.</p>
<p>Merges the values for the <em>last</em> matching row in the merge
dataset. Can use patterns to match multiple cells for merging
(using all candidate columns when there are muliple columns
matching the same hashtag pattern). Can overwrite existing columns
and values.</p>
<p>Warning: this filter may store a large amount of data in memory,
depending on the merge.</p>
<p>Usage:</p>
<pre>
MergeDataFilter(source, merge_source=merge_source, keys='adm1+code', tags='adm1+name')
</pre>
<pre>
hxl.data(url).merge_data(merge_source=merge_source, keys='adm1+code', tags='adm1+name')
</pre>
<p>(Add the column matching #adm1+name from the merge dataset to the
source dataset, syncing the rows using the value of #adm1+code in
each dataset.)</p>
<p>@see hxl.model.Dataset.merge_data
@see hxl.scripts.hxlmerge_main</p>
<p>Constructor.
@param source: the HXL data source.
@param merge_source: a second HXL data source to merge into the first.
@param keys: the shared key hashtags to use for the merge
@param tags: the tags to include from the second dataset
@param replace: if True, replace existing columns when possible
@param overwrite: if True, overwrite non-empty values in existing columns
@param queries: optional list of filter queries for rows to be considered from the merge dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MergeDataFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;Composable filter class to merge values from two HXL datasets.

    Merges the values for the *last* matching row in the merge
    dataset. Can use patterns to match multiple cells for merging
    (using all candidate columns when there are muliple columns
    matching the same hashtag pattern). Can overwrite existing columns
    and values.

    Warning: this filter may store a large amount of data in memory,
    depending on the merge.

    Usage:

    &lt;pre&gt;
    MergeDataFilter(source, merge_source=merge_source, keys=&#39;adm1+code&#39;, tags=&#39;adm1+name&#39;)
    &lt;/pre&gt;

    &lt;pre&gt;
    hxl.data(url).merge_data(merge_source=merge_source, keys=&#39;adm1+code&#39;, tags=&#39;adm1+name&#39;)
    &lt;/pre&gt;

    (Add the column matching #adm1+name from the merge dataset to the
    source dataset, syncing the rows using the value of #adm1+code in
    each dataset.)

    @see hxl.model.Dataset.merge_data
    @see hxl.scripts.hxlmerge_main
    &#34;&#34;&#34;

    def __init__(self, source, merge_source, keys, tags, replace=False, overwrite=False, queries=[]):
        &#34;&#34;&#34;
        Constructor.
        @param source: the HXL data source.
        @param merge_source: a second HXL data source to merge into the first.
        @param keys: the shared key hashtags to use for the merge
        @param tags: the tags to include from the second dataset
        @param replace: if True, replace existing columns when possible
        @param overwrite: if True, overwrite non-empty values in existing columns
        @param queries: optional list of filter queries for rows to be considered from the merge dataset.
        &#34;&#34;&#34;
        super().__init__(source)
        self.merge_source = merge_source
        &#34;&#34;&#34;The source dataset for pulling merged values&#34;&#34;&#34;
        self.keys = hxl.model.TagPattern.parse_list(keys)
        &#34;&#34;&#34;The shared keys for merging&#34;&#34;&#34;
        self.merge_tags = hxl.model.TagPattern.parse_list(tags)
        &#34;&#34;&#34;The merged values to pull from the merge_source&#34;&#34;&#34;
        self.replace = replace
        &#34;&#34;&#34;If True, replace columns when possible&#34;&#34;&#34;
        self.overwrite = overwrite
        &#34;&#34;&#34;If true, overwrite non-empty values in existing columns&#34;&#34;&#34;
        self.queries = self._setup_queries(queries)
        &#34;&#34;&#34;Query to filter rows to be merged&#34;&#34;&#34;
        self._merge_indices = []
        &#34;&#34;&#34;Indices for mapping columns from merge source to output dataset
        [source_index, output_index, overwrite_ok]
        &#34;&#34;&#34;
        self._merge_values = None
        &#34;&#34;&#34;Dictionary of values from merge source, indexed by key.&#34;&#34;&#34;

    def filter_columns(self):
        &#34;&#34;&#34;Filter the columns to add newly-merged ones.  
        Note: this is called only once, the first time someone
        accesses the Dataset.columns property, then the result is saved for future use.
        As a side effect, builds the _merge_indices specs for generating the merged data.
        @see hxl.filters.AbstractBaseFilter.filter_columns
        &#34;&#34;&#34;

        new_columns = list(self.source.columns)
        &#34;&#34;&#34;The new column list to return.&#34;&#34;&#34;
        
        merge_column_index = len(self.source.columns)
        &#34;&#34;&#34;Target index for merging into the output dataset&#34;&#34;&#34;
            
        # Check every pattern
        for pattern in self.merge_tags:

            # Check the pattern against every column
            for index, column in enumerate(self.merge_source.columns):

                seen_replacement = False
                &#34;&#34;&#34;We can replace inline exactly once for every pattern.&#34;&#34;&#34;

                if pattern.match(column):

                    # Replace inside existing columns, if conditions are met
                    if self.replace and not seen_replacement and pattern.find_column(self.source.columns):
                        # TODO: check for closest match
                        # TODO: allow for multiple replacements per pattern
                        self._merge_indices.append([index, pattern.find_column_index(self.source.columns), self.overwrite])
                        seen_replacement = True

                    # Replace into a new column on the right
                    else:
                        new_columns.append(column)
                        self._merge_indices.append([index, merge_column_index, True])
                        merge_column_index += 1

        return new_columns

    def filter_row(self, row):
        &#34;&#34;&#34;Set up a merged data row, replacing existing values if requested.
        Uses the _merge_indices map created by filter_columns.
        @param row: the data row to filter.
        @returns: a list of filtered values for the row.
        @see hxl.filters.AbstractStreamingFilter.filter_row
        &#34;&#34;&#34;

        # First, check if we already have the merge map, and read it if not
        if self._merge_values is None:
            self._merge_values = self._read_merge()

        # Make an initial array of the correct length
        values = copy.copy(row.values)
        values += ([&#39;&#39;] * (len(self.columns) - len(row.values)))

        # Look up the merge values, based on the keys
        for key in self._make_keys(row):
            merge_values = self._merge_values.get(key)
            if merge_values:
                for i, spec in enumerate(self._merge_indices):
                    if spec[2] or hxl.datatypes.is_empty(values[spec[1]]):
                        values[spec[1]] = merge_values[i]

        return values

    def _make_keys(self, row):
        &#34;&#34;&#34;Return all possible key-value combinations for the row as tuples.
        @param row: the row from which to generate the key
        &#34;&#34;&#34;
        candidate_values = []
        for pattern in self.keys:
            candidate_values.append(hxl.datatypes.normalise_string(value) for value in row.get_all(pattern, default=&#39;&#39;))
        return [tuple(value) for value in list_product(candidate_values)]

    def _read_merge(self):
        &#34;&#34;&#34;Read the second (merging) dataset into memory.
        Stores only the values necessary for the merge.
        Uses *last* matching row for each key (top to bottom).
        @returns: a map of merge values
        &#34;&#34;&#34;
        
        self.columns # make sure we&#39;ve created the _merge_indices map

        merge_values = {}
        &#34;&#34;&#34;Map of keys to merge values from the merge source.&#34;&#34;&#34;

        for row in self.merge_source:
            if hxl.model.RowQuery.match_list(row, self.queries):
                values = []

                # Save only the values we need
                for spec in self._merge_indices:
                    try:
                        values.append(row.values[spec[0]])
                    except IndexError:
                        values.append(&#39;&#39;)

                # Generate a key tuple and add to the map
                for key in self._make_keys(row):
                    merge_values[key] = values

        return merge_values

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a merge filter from a dict spec.
        @param source: the upstream data source
        @param spec: the JSON-like filter specification
        @returns: a L{MergeDataFilter} object
        &#34;&#34;&#34;
        return MergeDataFilter(
            source=source,
            merge_source=req_arg(spec, &#39;merge_source&#39;),
            keys=req_arg(spec, &#39;keys&#39;),
            tags=req_arg(spec, &#39;tags&#39;),
            replace=opt_arg(spec, &#39;replace&#39;, False),
            overwrite=opt_arg(spec, &#39;overwrite&#39;, False),
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hxl.filters.MergeDataFilter.keys"><code class="name">var <span class="ident">keys</span></code></dt>
<dd>
<div class="desc"><p>The shared keys for merging</p></div>
</dd>
<dt id="hxl.filters.MergeDataFilter.merge_source"><code class="name">var <span class="ident">merge_source</span></code></dt>
<dd>
<div class="desc"><p>The source dataset for pulling merged values</p></div>
</dd>
<dt id="hxl.filters.MergeDataFilter.merge_tags"><code class="name">var <span class="ident">merge_tags</span></code></dt>
<dd>
<div class="desc"><p>The merged values to pull from the merge_source</p></div>
</dd>
<dt id="hxl.filters.MergeDataFilter.overwrite"><code class="name">var <span class="ident">overwrite</span></code></dt>
<dd>
<div class="desc"><p>If true, overwrite non-empty values in existing columns</p></div>
</dd>
<dt id="hxl.filters.MergeDataFilter.queries"><code class="name">var <span class="ident">queries</span></code></dt>
<dd>
<div class="desc"><p>Query to filter rows to be merged</p></div>
</dd>
<dt id="hxl.filters.MergeDataFilter.replace"><code class="name">var <span class="ident">replace</span></code></dt>
<dd>
<div class="desc"><p>If True, replace columns when possible</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.MergeDataFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter the columns to add newly-merged ones.<br>
Note: this is called only once, the first time someone
accesses the Dataset.columns property, then the result is saved for future use.
As a side effect, builds the _merge_indices specs for generating the merged data.
@see hxl.filters.AbstractBaseFilter.filter_columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34;Filter the columns to add newly-merged ones.  
    Note: this is called only once, the first time someone
    accesses the Dataset.columns property, then the result is saved for future use.
    As a side effect, builds the _merge_indices specs for generating the merged data.
    @see hxl.filters.AbstractBaseFilter.filter_columns
    &#34;&#34;&#34;

    new_columns = list(self.source.columns)
    &#34;&#34;&#34;The new column list to return.&#34;&#34;&#34;
    
    merge_column_index = len(self.source.columns)
    &#34;&#34;&#34;Target index for merging into the output dataset&#34;&#34;&#34;
        
    # Check every pattern
    for pattern in self.merge_tags:

        # Check the pattern against every column
        for index, column in enumerate(self.merge_source.columns):

            seen_replacement = False
            &#34;&#34;&#34;We can replace inline exactly once for every pattern.&#34;&#34;&#34;

            if pattern.match(column):

                # Replace inside existing columns, if conditions are met
                if self.replace and not seen_replacement and pattern.find_column(self.source.columns):
                    # TODO: check for closest match
                    # TODO: allow for multiple replacements per pattern
                    self._merge_indices.append([index, pattern.find_column_index(self.source.columns), self.overwrite])
                    seen_replacement = True

                # Replace into a new column on the right
                else:
                    new_columns.append(column)
                    self._merge_indices.append([index, merge_column_index, True])
                    merge_column_index += 1

    return new_columns</code></pre>
</details>
</dd>
<dt id="hxl.filters.MergeDataFilter.filter_row"><code class="name flex">
<span>def <span class="ident">filter_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up a merged data row, replacing existing values if requested.
Uses the _merge_indices map created by filter_columns.
@param row: the data row to filter.
@returns: a list of filtered values for the row.
@see hxl.filters.AbstractStreamingFilter.filter_row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_row(self, row):
    &#34;&#34;&#34;Set up a merged data row, replacing existing values if requested.
    Uses the _merge_indices map created by filter_columns.
    @param row: the data row to filter.
    @returns: a list of filtered values for the row.
    @see hxl.filters.AbstractStreamingFilter.filter_row
    &#34;&#34;&#34;

    # First, check if we already have the merge map, and read it if not
    if self._merge_values is None:
        self._merge_values = self._read_merge()

    # Make an initial array of the correct length
    values = copy.copy(row.values)
    values += ([&#39;&#39;] * (len(self.columns) - len(row.values)))

    # Look up the merge values, based on the keys
    for key in self._make_keys(row):
        merge_values = self._merge_values.get(key)
        if merge_values:
            for i, spec in enumerate(self._merge_indices):
                if spec[2] or hxl.datatypes.is_empty(values[spec[1]]):
                    values[spec[1]] = merge_values[i]

    return values</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.RenameFilter"><code class="flex name class">
<span>class <span class="ident">RenameFilter</span></span>
<span>(</span><span>source, rename=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter class to rename columns in a HXL dataset.</p>
<p>This is the class supporting the hxlrename command-line utility.</p>
<p>Usage:</p>
<pre>
hxl.data(url).rename_columns('#foo:New header#bar')
</pre>
<p>Constructor
@param source: the Dataset for the data.
@param rename_map: map of tags to rename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RenameFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;
    Composable filter class to rename columns in a HXL dataset.

    This is the class supporting the hxlrename command-line utility.

    Usage:

    &lt;pre&gt;
    hxl.data(url).rename_columns(&#39;#foo:New header#bar&#39;)
    &lt;/pre&gt;
    &#34;&#34;&#34;

    def __init__(self, source, rename=[]):
        &#34;&#34;&#34;
        Constructor
        @param source: the Dataset for the data.
        @param rename_map: map of tags to rename
        &#34;&#34;&#34;
        super().__init__(source)
        if isinstance(rename, six.string_types):
            rename = [rename]
        self.rename = [RenameFilter.parse_rename(spec) for spec in rename]

    def filter_columns(self):
        &#34;&#34;&#34;Rename requested columns.&#34;&#34;&#34;
        return [self._rename_column(column) for column in self.source.columns]

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: a deep copy of the row&#39;s values&#34;&#34;&#34;
        return copy.copy(row.values)

    def _rename_column(self, column):
        &#34;&#34;&#34;@returns: a copy of the column object, with a new name if needed&#34;&#34;&#34;
        for spec in self.rename:
            norm = hxl.datatypes.normalise_string
            if spec[0].match(column) and (not spec[2] or norm(spec[2]) == norm(column.header)):
                new_column = copy.deepcopy(spec[1])
                if new_column.header is None:
                    new_column.header = column.header
                return new_column
        return copy.deepcopy(column)

    RENAME_PATTERN = r&#39;^\s*(?:([^#]*)#)?({token}(?:\s*[+-]{token})*)\s*:\s*(?:([^#]*)#)?({token}(?:\s*[+]{token})*)\s*$&#39;.format(
        token=hxl.datatypes.TOKEN_PATTERN
    )
    &#34;&#34;&#34;Regular expression for parsing a rename pattern&#34;&#34;&#34;

    @staticmethod
    def parse_rename(s):
        &#34;&#34;&#34;Parse a rename specification from the parameters.
        @param s: the specification to parse
        @returns: a tuple with the old pattern to match and new column spec
        @exception HXLFilterException: if the spec is not parseable
        &#34;&#34;&#34;
        if isinstance(s, six.string_types):
            result = re.match(RenameFilter.RENAME_PATTERN, s)
            if result:
                header = result.group(1)
                pattern = hxl.model.TagPattern.parse(result.group(2))
                column = hxl.model.Column.parse(&#39;#&#39; + result.group(4), header=result.group(3), use_exception=True)
                return (pattern, column, header)
            else:
                raise HXLFilterException(&#34;Bad rename expression: &#34; + s)
        else:
            return s

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a rename filter from a dict spec.
        @param source: the upstream data source
        @param spec: the JSON-like filter specification
        @returns: a L{RenameFilter} object
        &#34;&#34;&#34;
        return RenameFilter(
            source=source,
            rename=req_arg(spec, &#39;specs&#39;)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hxl.filters.RenameFilter.RENAME_PATTERN"><code class="name">var <span class="ident">RENAME_PATTERN</span></code></dt>
<dd>
<div class="desc"><p>Regular expression for parsing a rename pattern</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="hxl.filters.RenameFilter.parse_rename"><code class="name flex">
<span>def <span class="ident">parse_rename</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a rename specification from the parameters.
@param s: the specification to parse
@returns: a tuple with the old pattern to match and new column spec
@exception HXLFilterException: if the spec is not parseable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_rename(s):
    &#34;&#34;&#34;Parse a rename specification from the parameters.
    @param s: the specification to parse
    @returns: a tuple with the old pattern to match and new column spec
    @exception HXLFilterException: if the spec is not parseable
    &#34;&#34;&#34;
    if isinstance(s, six.string_types):
        result = re.match(RenameFilter.RENAME_PATTERN, s)
        if result:
            header = result.group(1)
            pattern = hxl.model.TagPattern.parse(result.group(2))
            column = hxl.model.Column.parse(&#39;#&#39; + result.group(4), header=result.group(3), use_exception=True)
            return (pattern, column, header)
        else:
            raise HXLFilterException(&#34;Bad rename expression: &#34; + s)
    else:
        return s</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.RenameFilter.filter_columns"><code class="name flex">
<span>def <span class="ident">filter_columns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename requested columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_columns(self):
    &#34;&#34;&#34;Rename requested columns.&#34;&#34;&#34;
    return [self._rename_column(column) for column in self.source.columns]</code></pre>
</details>
</dd>
<dt id="hxl.filters.RenameFilter.filter_row"><code class="name flex">
<span>def <span class="ident">filter_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: a deep copy of the row's values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_row(self, row):
    &#34;&#34;&#34;@returns: a deep copy of the row&#39;s values&#34;&#34;&#34;
    return copy.copy(row.values)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.ReplaceDataFilter"><code class="flex name class">
<span>class <span class="ident">ReplaceDataFilter</span></span>
<span>(</span><span>source, replacements, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter class to replace values in a HXL dataset.</p>
<p>This is the class supporting the hxlreplace console script.</p>
<p>Usage:</p>
<pre>
hxl.data(url).replace_data('foo', 'bar', '#activity')
</pre>
<p>Constructor
@param source: the HXL data source
@param original: a string or regular expression to replace (string must match the whole value, not just part)
@param replacements: list of replacement objects
@param queries: optional list of filter queries for rows where replacements should be applied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplaceDataFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;
    Composable filter class to replace values in a HXL dataset.

    This is the class supporting the hxlreplace console script.

    Usage:

    &lt;pre&gt;
    hxl.data(url).replace_data(&#39;foo&#39;, &#39;bar&#39;, &#39;#activity&#39;)
    &lt;/pre&gt;
    &#34;&#34;&#34;

    def __init__(self, source, replacements, queries=[]):
        &#34;&#34;&#34;
        Constructor
        @param source: the HXL data source
        @param original: a string or regular expression to replace (string must match the whole value, not just part)
        @param replacements: list of replacement objects
        @param queries: optional list of filter queries for rows where replacements should be applied.
        &#34;&#34;&#34;
        super(ReplaceDataFilter, self).__init__(source)
        self.replacements = replacements
        if isinstance(self.replacements, ReplaceDataFilter.Replacement):
            self.replacements = [self.replacements]
        self.queries = self._setup_queries(queries)

    def filter_row(self, row):
        &#34;&#34;&#34;@returns: the row values with replacements&#34;&#34;&#34;
        if hxl.model.RowQuery.match_list(row, self.queries):
            values = copy.copy(row.values)
            for index, value in enumerate(values):
                for replacement in self.replacements:
                    value = replacement.sub(row.columns[index], value)
                    values[index] = value
            return values
        else:
            return row.values

    class Replacement:
        &#34;&#34;&#34;Replacement specification.&#34;&#34;&#34;

        def __init__(self, original, replacement, patterns=None, is_regex=False):
            &#34;&#34;&#34;
            @param original: a string (case- and space-insensitive) or regular expression (sensitive) to replace
            @param replacement: the replacement string or regular expression substitution
            @param patterns: (optional) a list of tag patterns to limit the replacement to specific columns
            @param is_regex: (optional) True to use regular-expression processing (defaults to False)
            &#34;&#34;&#34;
            self.original = original
            if replacement is None:
                self.replacement = &#39;&#39;
            else:
                self.replacement = replacement
            if patterns:
                self.patterns = hxl.model.TagPattern.parse_list(patterns)
            else:
                self.patterns = None
            self.is_regex = is_regex
            if not self.is_regex:
                self.original = hxl.datatypes.normalise_string(self.original)

        def sub(self, column, value):
            &#34;&#34;&#34;
            Substitute inside the value, if appropriate.
            @param column: the column definition
            @param value: the cell value
            @returns: the value, possibly changed
            &#34;&#34;&#34;
            if self.patterns and not hxl.model.TagPattern.match_list(column, self.patterns):
                return value
            elif self.is_regex:
                return re.sub(self.original, self.replacement, str(value))
            elif self.original == hxl.datatypes.normalise_string(value):
                return self.replacement
            else:
                return value

        @staticmethod
        def parse_map(source):
            &#34;&#34;&#34;Parse a substitution map.&#34;&#34;&#34;
            replacements = []
            for row in source:
                if row.get(&#39;#x_pattern&#39;):
                    replacements.append(
                        ReplaceDataFilter.Replacement(
                            row.get(&#39;#x_pattern&#39;), row.get(&#39;#x_substitution&#39;),
                            row.get(&#39;#x_tag&#39;), row.get(&#39;#x_regex&#39;)
                        ))
            return replacements

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a replace-data filter from a dict spec.
        @param source: the upstream data source
        @param spec: a JSON-like filter specification
        @returns: a L{ReplaceDataFilter} object
        &#34;&#34;&#34;

        replacements = []

        if spec.get(&#39;filter&#39;) == &#39;replace_data_map&#39;:
            # using an external map
            replacements = ReplaceDataFilter.Replacement.parse_map(
                hxl.data(req_arg(spec, &#39;map_source&#39;))
            )
        elif spec.get(&#39;filter&#39;) == &#39;replace_data&#39;:
            # simple replacement
            replacements = [
                ReplaceDataFilter.Replacement(
                    original=req_arg(spec, &#39;original&#39;),
                    replacement=req_arg(spec, &#39;replacement&#39;),
                    patterns=opt_arg(spec, &#39;pattern&#39;, None),
                    is_regex=opt_arg(spec, &#39;use_regex&#39;, False)
                )
            ]

        return ReplaceDataFilter(
            source=source,
            replacements=replacements,
            queries=opt_arg(spec, &#39;queries&#39;, [])
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hxl.filters.ReplaceDataFilter.Replacement"><code class="name">var <span class="ident">Replacement</span></code></dt>
<dd>
<div class="desc"><p>Replacement specification.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.ReplaceDataFilter.filter_row"><code class="name flex">
<span>def <span class="ident">filter_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>@returns: the row values with replacements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_row(self, row):
    &#34;&#34;&#34;@returns: the row values with replacements&#34;&#34;&#34;
    if hxl.model.RowQuery.match_list(row, self.queries):
        values = copy.copy(row.values)
        for index, value in enumerate(values):
            for replacement in self.replacements:
                value = replacement.sub(row.columns[index], value)
                values[index] = value
        return values
    else:
        return row.values</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.RowCountFilter"><code class="flex name class">
<span>class <span class="ident">RowCountFilter</span></span>
<span>(</span><span>source, queries=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter class to count lines (and nothing else)</p>
<p>The output is identical to the input; the line count is
stored in the filter itself.
As a result, there is no corresponding
command-line utility.</p>
<p>Usage:</p>
<pre>
counter = hxl.data(url).row_counter();
// process the filter
print("{} lines".format(counter.row_count);
</pre>
<p>Construct a new streaming filter.
@param source: the source dataset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RowCountFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;
    Composable filter class to count lines (and nothing else)

    The output is identical to the input; the line count is
    stored in the filter itself.  As a result, there is no corresponding
    command-line utility.
    
    Usage:

    &lt;pre&gt;
    counter = hxl.data(url).row_counter();
    // process the filter
    print(&#34;{} lines&#34;.format(counter.row_count);
    &lt;/pre&gt;
    &#34;&#34;&#34;

    def __init__(self, source, queries=[]):
        super(RowCountFilter, self).__init__(source)
        self.row_count = 0
        self.queries = self._setup_queries(queries)

    def filter_row(self, row):
        if hxl.model.RowQuery.match_list(row, self.queries):
            self.row_count += 1
        return row.values</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.filter_row" href="#hxl.filters.AbstractStreamingFilter.filter_row">filter_row</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.RowFilter"><code class="flex name class">
<span>class <span class="ident">RowFilter</span></span>
<span>(</span><span>source, queries=[], reverse=False, mask=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter class to select rows from a HXL dataset.</p>
<p>Usage:</p>
<pre>
# include list
hxl.data(url).with_rows('org=OXFAM')

# exclude list
hxl.data(url).without_rows('org=OXFAM')
</pre>
<p>Constructor
@param source: the HXL data source
@param queries: a series of predicates for rows to include or ignore
@param reverse: True to reverse the sense of the select
@param mask: a series of predicates to limit the rows to test (default: [] to test all)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RowFilter(AbstractStreamingFilter):
    &#34;&#34;&#34;
    Composable filter class to select rows from a HXL dataset.

    Usage:

    &lt;pre&gt;
    # include list
    hxl.data(url).with_rows(&#39;org=OXFAM&#39;)

    # exclude list
    hxl.data(url).without_rows(&#39;org=OXFAM&#39;)
    &lt;/pre&gt;
    &#34;&#34;&#34;

    def __init__(self, source, queries=[], reverse=False, mask=[]):
        &#34;&#34;&#34;
        Constructor
        @param source: the HXL data source
        @param queries: a series of predicates for rows to include or ignore
        @param reverse: True to reverse the sense of the select
        @param mask: a series of predicates to limit the rows to test (default: [] to test all)
        &#34;&#34;&#34;
        super(RowFilter, self).__init__(source)
        self.queries = self._setup_queries(queries)
        self.mask = self._setup_queries(mask)
        self.reverse = reverse

        for query in self.queries:
            if query.needs_aggregate:
                if not self.source.is_cached:
                    self.source = self.source.cache()
                query.calc_aggregate(self.source)

    def filter_row(self, row):
        &#34;&#34;&#34;Filter data row-wise.
        @param row: the row to filter
        @returns: the row&#39;s values as an array, or None if it fails the filters
        &#34;&#34;&#34;
        if hxl.model.RowQuery.match_list(row, self.mask):
            if not hxl.model.RowQuery.match_list(row, self.queries, self.reverse):
                return None
        return row.values

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Construct a row filter from a dict spec.&#34;&#34;&#34;
        
        reverse = False
        if spec.get(&#39;filter&#39;) == &#39;without_rows&#39;:
            reverse = True

        return RowFilter(
            source=source,
            queries=req_arg(spec, &#39;queries&#39;),
            reverse=reverse,
            mask=opt_arg(spec, &#39;mask&#39;, [])
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.RowFilter.filter_row"><code class="name flex">
<span>def <span class="ident">filter_row</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter data row-wise.
@param row: the row to filter
@returns: the row's values as an array, or None if it fails the filters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_row(self, row):
    &#34;&#34;&#34;Filter data row-wise.
    @param row: the row to filter
    @returns: the row&#39;s values as an array, or None if it fails the filters
    &#34;&#34;&#34;
    if hxl.model.RowQuery.match_list(row, self.mask):
        if not hxl.model.RowQuery.match_list(row, self.queries, self.reverse):
            return None
    return row.values</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractStreamingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractStreamingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hxl.filters.SortFilter"><code class="flex name class">
<span>class <span class="ident">SortFilter</span></span>
<span>(</span><span>source, tags=[], reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Composable filter class to sort a HXL dataset.</p>
<p>This is the class supporting the hxlsort command-line utility.</p>
<p>Usage:</p>
<pre>
hxl.data(url).sort('sector,org,adm1')
</pre>
<p>@param source: a HXL data source
@param tags: list of TagPattern objects for sorting
@param reverse: True to reverse the sort order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SortFilter(AbstractCachingFilter):
    &#34;&#34;&#34;
    Composable filter class to sort a HXL dataset.

    This is the class supporting the hxlsort command-line utility.

    Usage:

    &lt;pre&gt;
    hxl.data(url).sort(&#39;sector,org,adm1&#39;)
    &lt;/pre&gt;
    &#34;&#34;&#34;

    def __init__(self, source, tags=[], reverse=False):
        &#34;&#34;&#34;
        @param source: a HXL data source
        @param tags: list of TagPattern objects for sorting
        @param reverse: True to reverse the sort order
        &#34;&#34;&#34;
        super(SortFilter, self).__init__(source)
        self.sort_tags = hxl.model.TagPattern.parse_list(tags)
        self.reverse = reverse
        self._iter = None

    def filter_rows(self):
        &#34;&#34;&#34;Return a sorted list of values, row by row.&#34;&#34;&#34;

        # Figure out the indices for sort keys
        indices = self._make_indices()

        def make_key(values):
            &#34;&#34;&#34;Closure, to get the object reference into the key method.&#34;&#34;&#34;
            return self._make_key(indices, values)

        return sorted(self.source.values, key=make_key, reverse=self.reverse)

    def _make_indices(self):
        &#34;&#34;&#34;Determine the indices of the data to sort.&#34;&#34;&#34;
        indices = []
        for pattern in self.sort_tags:
            index = pattern.find_column_index(self.columns)
            if index is not None:
                indices.append(index)
        return indices

    def _make_key(self, indices, values):
        &#34;&#34;&#34;
        Make a sort key from a an array of values.
        @param indices: an array of indices for the sort key (if empty, use all values).
        @param values: an array of values to sort
        @returns: a sort key as a tuple
        &#34;&#34;&#34;

        key = []

        if indices:
            for index in indices:
                key.append(SortFilter._make_sort_value(self.columns[index].tag, values[index]))
        else:
            # Sort everything, left to right
            for index, value in enumerate(values):
                if index &lt; len(self.columns):
                    key.append(SortFilter._make_sort_value(self.columns[index].tag, value))

        # convert the key to a tuple for sorting
        return tuple(key)

    @staticmethod
    def _make_sort_value(tag, value):
        &#34;&#34;&#34;
        Make a special sort value

        The sort value is is a tuple of a numeric value (possibly inf)
        and the original string value. This will ensure that numeric
        values sort properly, and string values sort after them.
        &#34;&#34;&#34;
        norm = hxl.datatypes.normalise_string(value)
        if tag == &#39;#date&#39;:
            try:
                return (float(&#39;inf&#39;), hxl.datatypes.normalise_date(norm))
            except ValueError:
                return (float(&#39;inf&#39;), norm)
        else:
            try:
                return (float(norm), norm)
            except:
                return (float(&#39;inf&#39;), norm)

    @staticmethod
    def _load(source, spec):
        &#34;&#34;&#34;Create a sort filter from a dict spec.&#34;&#34;&#34;
        return SortFilter(
            source = source,
            tags=opt_arg(spec, &#39;tags&#39;, []),
            reverse=opt_arg(spec, &#39;reverse&#39;, False)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hxl.filters.AbstractCachingFilter" href="#hxl.filters.AbstractCachingFilter">AbstractCachingFilter</a></li>
<li><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></li>
<li><a title="hxl.model.Dataset" href="model.html#hxl.model.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hxl.filters.SortFilter.filter_rows"><code class="name flex">
<span>def <span class="ident">filter_rows</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a sorted list of values, row by row.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_rows(self):
    &#34;&#34;&#34;Return a sorted list of values, row by row.&#34;&#34;&#34;

    # Figure out the indices for sort keys
    indices = self._make_indices()

    def make_key(values):
        &#34;&#34;&#34;Closure, to get the object reference into the key method.&#34;&#34;&#34;
        return self._make_key(indices, values)

    return sorted(self.source.values, key=make_key, reverse=self.reverse)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hxl.filters.AbstractCachingFilter" href="#hxl.filters.AbstractCachingFilter">AbstractCachingFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="hxl.filters.AbstractCachingFilter.add_columns" href="model.html#hxl.model.Dataset.add_columns">add_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.append" href="model.html#hxl.model.Dataset.append">append</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.append_external_list" href="model.html#hxl.model.Dataset.append_external_list">append_external_list</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.cache" href="model.html#hxl.model.Dataset.cache">cache</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.clean_data" href="model.html#hxl.model.Dataset.clean_data">clean_data</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.columns_hash" href="model.html#hxl.model.Dataset.columns_hash">columns_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.count" href="model.html#hxl.model.Dataset.count">count</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.data_hash" href="model.html#hxl.model.Dataset.data_hash">data_hash</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.dedup" href="model.html#hxl.model.Dataset.dedup">dedup</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.display_tags" href="model.html#hxl.model.Dataset.display_tags">display_tags</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.expand_lists" href="model.html#hxl.model.Dataset.expand_lists">expand_lists</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.explode" href="model.html#hxl.model.Dataset.explode">explode</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.fill_data" href="model.html#hxl.model.Dataset.fill_data">fill_data</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.gen_csv" href="model.html#hxl.model.Dataset.gen_csv">gen_csv</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.gen_json" href="model.html#hxl.model.Dataset.gen_json">gen_json</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.gen_raw" href="model.html#hxl.model.Dataset.gen_raw">gen_raw</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.get_column_indices" href="model.html#hxl.model.Dataset.get_column_indices">get_column_indices</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.get_value_set" href="model.html#hxl.model.Dataset.get_value_set">get_value_set</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.has_headers" href="model.html#hxl.model.Dataset.has_headers">has_headers</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.headers" href="model.html#hxl.model.Dataset.headers">headers</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.implode" href="model.html#hxl.model.Dataset.implode">implode</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.is_cached" href="#hxl.filters.AbstractCachingFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.jsonpath" href="model.html#hxl.model.Dataset.jsonpath">jsonpath</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.max" href="model.html#hxl.model.Dataset.max">max</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.merge_data" href="model.html#hxl.model.Dataset.merge_data">merge_data</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.min" href="model.html#hxl.model.Dataset.min">min</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.recipe" href="model.html#hxl.model.Dataset.recipe">recipe</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.rename_columns" href="model.html#hxl.model.Dataset.rename_columns">rename_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.replace_data" href="model.html#hxl.model.Dataset.replace_data">replace_data</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.replace_data_map" href="model.html#hxl.model.Dataset.replace_data_map">replace_data_map</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.row_counter" href="model.html#hxl.model.Dataset.row_counter">row_counter</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.sort" href="model.html#hxl.model.Dataset.sort">sort</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.tags" href="model.html#hxl.model.Dataset.tags">tags</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.validate" href="model.html#hxl.model.Dataset.validate">validate</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.values" href="model.html#hxl.model.Dataset.values">values</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.with_columns" href="model.html#hxl.model.Dataset.with_columns">with_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.with_rows" href="model.html#hxl.model.Dataset.with_rows">with_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.without_columns" href="model.html#hxl.model.Dataset.without_columns">without_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.without_rows" href="model.html#hxl.model.Dataset.without_rows">without_rows</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hxl" href="index.html">hxl</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="hxl.filters.LOAD_MAP" href="#hxl.filters.LOAD_MAP">LOAD_MAP</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hxl.filters.from_recipe" href="#hxl.filters.from_recipe">from_recipe</a></code></li>
<li><code><a title="hxl.filters.is_sourcey" href="#hxl.filters.is_sourcey">is_sourcey</a></code></li>
<li><code><a title="hxl.filters.list_product" href="#hxl.filters.list_product">list_product</a></code></li>
<li><code><a title="hxl.filters.opt_arg" href="#hxl.filters.opt_arg">opt_arg</a></code></li>
<li><code><a title="hxl.filters.req_arg" href="#hxl.filters.req_arg">req_arg</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hxl.filters.AbstractBaseFilter" href="#hxl.filters.AbstractBaseFilter">AbstractBaseFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.AbstractBaseFilter.columns" href="#hxl.filters.AbstractBaseFilter.columns">columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.filter_columns" href="#hxl.filters.AbstractBaseFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.is_cached" href="#hxl.filters.AbstractBaseFilter.is_cached">is_cached</a></code></li>
<li><code><a title="hxl.filters.AbstractBaseFilter.source" href="#hxl.filters.AbstractBaseFilter.source">source</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.AbstractCachingFilter" href="#hxl.filters.AbstractCachingFilter">AbstractCachingFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.AbstractCachingFilter.filter_rows" href="#hxl.filters.AbstractCachingFilter.filter_rows">filter_rows</a></code></li>
<li><code><a title="hxl.filters.AbstractCachingFilter.is_cached" href="#hxl.filters.AbstractCachingFilter.is_cached">is_cached</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.AbstractStreamingFilter" href="#hxl.filters.AbstractStreamingFilter">AbstractStreamingFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.AbstractStreamingFilter.filter_row" href="#hxl.filters.AbstractStreamingFilter.filter_row">filter_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.AddColumnsFilter" href="#hxl.filters.AddColumnsFilter">AddColumnsFilter</a></code></h4>
<ul class="two-column">
<li><code><a title="hxl.filters.AddColumnsFilter.SPEC_PATTERN" href="#hxl.filters.AddColumnsFilter.SPEC_PATTERN">SPEC_PATTERN</a></code></li>
<li><code><a title="hxl.filters.AddColumnsFilter.before" href="#hxl.filters.AddColumnsFilter.before">before</a></code></li>
<li><code><a title="hxl.filters.AddColumnsFilter.const_values" href="#hxl.filters.AddColumnsFilter.const_values">const_values</a></code></li>
<li><code><a title="hxl.filters.AddColumnsFilter.filter_columns" href="#hxl.filters.AddColumnsFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AddColumnsFilter.filter_row" href="#hxl.filters.AddColumnsFilter.filter_row">filter_row</a></code></li>
<li><code><a title="hxl.filters.AddColumnsFilter.parse_spec" href="#hxl.filters.AddColumnsFilter.parse_spec">parse_spec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.Aggregator" href="#hxl.filters.Aggregator">Aggregator</a></code></h4>
<ul class="two-column">
<li><code><a title="hxl.filters.Aggregator.AGGREGATOR_PATTERN" href="#hxl.filters.Aggregator.AGGREGATOR_PATTERN">AGGREGATOR_PATTERN</a></code></li>
<li><code><a title="hxl.filters.Aggregator.COL_PATTERN" href="#hxl.filters.Aggregator.COL_PATTERN">COL_PATTERN</a></code></li>
<li><code><a title="hxl.filters.Aggregator.TAG_PATTERN" href="#hxl.filters.Aggregator.TAG_PATTERN">TAG_PATTERN</a></code></li>
<li><code><a title="hxl.filters.Aggregator.evaluate_row" href="#hxl.filters.Aggregator.evaluate_row">evaluate_row</a></code></li>
<li><code><a title="hxl.filters.Aggregator.normalised" href="#hxl.filters.Aggregator.normalised">normalised</a></code></li>
<li><code><a title="hxl.filters.Aggregator.parse" href="#hxl.filters.Aggregator.parse">parse</a></code></li>
<li><code><a title="hxl.filters.Aggregator.parse_list" href="#hxl.filters.Aggregator.parse_list">parse_list</a></code></li>
<li><code><a title="hxl.filters.Aggregator.total" href="#hxl.filters.Aggregator.total">total</a></code></li>
<li><code><a title="hxl.filters.Aggregator.value" href="#hxl.filters.Aggregator.value">value</a></code></li>
<li><code><a title="hxl.filters.Aggregator.values" href="#hxl.filters.Aggregator.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.AppendFilter" href="#hxl.filters.AppendFilter">AppendFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.AppendFilter.add_extra_columns" href="#hxl.filters.AppendFilter.add_extra_columns">add_extra_columns</a></code></li>
<li><code><a title="hxl.filters.AppendFilter.append_sources" href="#hxl.filters.AppendFilter.append_sources">append_sources</a></code></li>
<li><code><a title="hxl.filters.AppendFilter.filter_columns" href="#hxl.filters.AppendFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.AppendFilter.parse_external_source_list" href="#hxl.filters.AppendFilter.parse_external_source_list">parse_external_source_list</a></code></li>
<li><code><a title="hxl.filters.AppendFilter.queries" href="#hxl.filters.AppendFilter.queries">queries</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.CacheFilter" href="#hxl.filters.CacheFilter">CacheFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.CacheFilter.filter_columns" href="#hxl.filters.CacheFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.CacheFilter.max_rows" href="#hxl.filters.CacheFilter.max_rows">max_rows</a></code></li>
<li><code><a title="hxl.filters.CacheFilter.overflow" href="#hxl.filters.CacheFilter.overflow">overflow</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.CleanDataFilter" href="#hxl.filters.CleanDataFilter">CleanDataFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.CleanDataFilter.filter_row" href="#hxl.filters.CleanDataFilter.filter_row">filter_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.ColumnFilter" href="#hxl.filters.ColumnFilter">ColumnFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.ColumnFilter.filter_columns" href="#hxl.filters.ColumnFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.ColumnFilter.filter_row" href="#hxl.filters.ColumnFilter.filter_row">filter_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.CountFilter" href="#hxl.filters.CountFilter">CountFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.CountFilter.filter_columns" href="#hxl.filters.CountFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.CountFilter.filter_rows" href="#hxl.filters.CountFilter.filter_rows">filter_rows</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.DeduplicationFilter" href="#hxl.filters.DeduplicationFilter">DeduplicationFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.DeduplicationFilter.filter_row" href="#hxl.filters.DeduplicationFilter.filter_row">filter_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.ExpandListsFilter" href="#hxl.filters.ExpandListsFilter">ExpandListsFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.ExpandListsFilter.filter_columns" href="#hxl.filters.ExpandListsFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.ExpandListsFilter.queries" href="#hxl.filters.ExpandListsFilter.queries">queries</a></code></li>
<li><code><a title="hxl.filters.ExpandListsFilter.scan_columns" href="#hxl.filters.ExpandListsFilter.scan_columns">scan_columns</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.ExplodeFilter" href="#hxl.filters.ExplodeFilter">ExplodeFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.ExplodeFilter.filter_columns" href="#hxl.filters.ExplodeFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.ExplodeFilter.header_attribute" href="#hxl.filters.ExplodeFilter.header_attribute">header_attribute</a></code></li>
<li><code><a title="hxl.filters.ExplodeFilter.value_attribute" href="#hxl.filters.ExplodeFilter.value_attribute">value_attribute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.FillDataFilter" href="#hxl.filters.FillDataFilter">FillDataFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.FillDataFilter.filter_row" href="#hxl.filters.FillDataFilter.filter_row">filter_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.HXLFilterException" href="#hxl.filters.HXLFilterException">HXLFilterException</a></code></h4>
</li>
<li>
<h4><code><a title="hxl.filters.ImplodeFilter" href="#hxl.filters.ImplodeFilter">ImplodeFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.ImplodeFilter.filter_columns" href="#hxl.filters.ImplodeFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.ImplodeFilter.process" href="#hxl.filters.ImplodeFilter.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.JSONPathFilter" href="#hxl.filters.JSONPathFilter">JSONPathFilter</a></code></h4>
</li>
<li>
<h4><code><a title="hxl.filters.MergeDataFilter" href="#hxl.filters.MergeDataFilter">MergeDataFilter</a></code></h4>
<ul class="two-column">
<li><code><a title="hxl.filters.MergeDataFilter.filter_columns" href="#hxl.filters.MergeDataFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.MergeDataFilter.filter_row" href="#hxl.filters.MergeDataFilter.filter_row">filter_row</a></code></li>
<li><code><a title="hxl.filters.MergeDataFilter.keys" href="#hxl.filters.MergeDataFilter.keys">keys</a></code></li>
<li><code><a title="hxl.filters.MergeDataFilter.merge_source" href="#hxl.filters.MergeDataFilter.merge_source">merge_source</a></code></li>
<li><code><a title="hxl.filters.MergeDataFilter.merge_tags" href="#hxl.filters.MergeDataFilter.merge_tags">merge_tags</a></code></li>
<li><code><a title="hxl.filters.MergeDataFilter.overwrite" href="#hxl.filters.MergeDataFilter.overwrite">overwrite</a></code></li>
<li><code><a title="hxl.filters.MergeDataFilter.queries" href="#hxl.filters.MergeDataFilter.queries">queries</a></code></li>
<li><code><a title="hxl.filters.MergeDataFilter.replace" href="#hxl.filters.MergeDataFilter.replace">replace</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.RenameFilter" href="#hxl.filters.RenameFilter">RenameFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.RenameFilter.RENAME_PATTERN" href="#hxl.filters.RenameFilter.RENAME_PATTERN">RENAME_PATTERN</a></code></li>
<li><code><a title="hxl.filters.RenameFilter.filter_columns" href="#hxl.filters.RenameFilter.filter_columns">filter_columns</a></code></li>
<li><code><a title="hxl.filters.RenameFilter.filter_row" href="#hxl.filters.RenameFilter.filter_row">filter_row</a></code></li>
<li><code><a title="hxl.filters.RenameFilter.parse_rename" href="#hxl.filters.RenameFilter.parse_rename">parse_rename</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.ReplaceDataFilter" href="#hxl.filters.ReplaceDataFilter">ReplaceDataFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.ReplaceDataFilter.Replacement" href="#hxl.filters.ReplaceDataFilter.Replacement">Replacement</a></code></li>
<li><code><a title="hxl.filters.ReplaceDataFilter.filter_row" href="#hxl.filters.ReplaceDataFilter.filter_row">filter_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.RowCountFilter" href="#hxl.filters.RowCountFilter">RowCountFilter</a></code></h4>
</li>
<li>
<h4><code><a title="hxl.filters.RowFilter" href="#hxl.filters.RowFilter">RowFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.RowFilter.filter_row" href="#hxl.filters.RowFilter.filter_row">filter_row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hxl.filters.SortFilter" href="#hxl.filters.SortFilter">SortFilter</a></code></h4>
<ul class="">
<li><code><a title="hxl.filters.SortFilter.filter_rows" href="#hxl.filters.SortFilter.filter_rows">filter_rows</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>